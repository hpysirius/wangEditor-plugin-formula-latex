/** MathJSON 0.12.3 */
function isSymbolObject(expr) {
    return expr !== null && typeof expr === 'object' && 'sym' in expr;
}
function isStringObject(expr) {
    return expr !== null && typeof expr === 'object' && 'str' in expr;
}
function isFunctionObject(expr) {
    return expr !== null && typeof expr === 'object' && 'fn' in expr;
}
function isDictionaryObject(expr) {
    return expr !== null && typeof expr === 'object' && 'dict' in expr;
}
function isValidIdentifier(s) {
    // An identifier must not contain any of these characters
    if (/[\u0000-\u0020\u0022\u0060\ufffe\uffff]/.test(s))
        return false;
    // A symbol name must not start with one these characters
    return !/^[\u0021\u0022\u0024-\u0029\u002e\u003a\u003f\u0040\u005b\u005d\u005e\u007b\u007d\u007e\+\-[0-9]]/.test(s);
}
/**  If expr is a string literal, return it.
 *
 * A string literal is a JSON string that begins and ends with
 * **U+0027 APOSTROPHE** : **`'`** or an object literal with a `str` key.
 */
function stringValue(expr) {
    if (expr === null || expr === undefined)
        return null;
    if (typeof expr === 'object' && 'str' in expr)
        return expr.str;
    if (typeof expr !== 'string')
        return null;
    if (expr.length < 2)
        return null;
    if (expr[0] !== "'" || expr[expr.length - 1] !== "'")
        return null;
    return expr.substring(1, expr.length - 1);
}
/**
 * The head of a function can be an identifier or an expression.
 *
 * Return `null` if the expression is not a function.
 *
 * Examples:
 * * `["Negate", 5]`  -> `"Negate"`
 * * `[["Prime", "f"], "x"]` -> `["Prime", "f"]`
 */
function head(expr) {
    if (expr === null || expr === undefined)
        return null;
    if (Array.isArray(expr)) {
        console.assert(expr.length > 0 &&
            (typeof expr[0] !== 'string' || isValidIdentifier(expr[0])));
        return expr[0];
    }
    if (isFunctionObject(expr))
        return expr.fn[0];
    return null;
}
/** Return the head of an expression, only if it's a string */
function headName(expr) {
    const h = head(expr);
    return typeof h === 'string' ? h : '';
}
/**
 * Return all the elements but the first one, i.e. the arguments of a
 * function.
 */
function ops(expr) {
    if (expr === null || expr === undefined)
        return null;
    if (Array.isArray(expr))
        return expr.slice(1);
    if (isFunctionObject(expr))
        return expr.fn.slice(1);
    return null;
}
/** Return the nth argument of a function expression */
function op(expr, n) {
    if (expr === null || expr === undefined)
        return null;
    if (Array.isArray(expr))
        return expr[n] ?? null;
    if (isFunctionObject(expr))
        return expr.fn[n] ?? null;
    return null;
}
function op1(expr) {
    return op(expr, 1);
}
function op2(expr) {
    return op(expr, 2);
}
function nops(expr) {
    if (expr === null || expr === undefined)
        return 0;
    if (Array.isArray(expr))
        return Math.max(0, expr.length - 1);
    if (isFunctionObject(expr))
        return Math.max(0, expr.fn.length - 1);
    return 0;
}
function symbol(expr) {
    if (expr === null || expr === undefined)
        return null;
    if (typeof expr === 'string') {
        // Is it a number?
        if (/^[+\-\.0-9]/.test(expr))
            return null;
        // Is it a string literal?
        if (expr.length >= 2 && expr[0] === "'" && expr[expr.length - 1] === "'")
            return null;
    }
    const s = isSymbolObject(expr) ? expr.sym : expr;
    if (typeof s !== 'string')
        return null;
    return s;
}
function keyValuePair(expr) {
    const h = head(expr);
    if (h === 'KeyValuePair' || h === 'Tuple' || h === 'Pair') {
        const key = stringValue(op1(expr));
        if (!key)
            return null;
        return [key, op2(expr) ?? 'Nothing'];
    }
    return null;
}
function dictionary(expr) {
    if (expr === null)
        return null;
    if (typeof expr === 'object' && 'dict' in expr)
        return expr.dict;
    const kv = keyValuePair(expr);
    if (kv)
        return { [kv[0]]: kv[1] };
    const h = head(expr);
    if (h === 'Dictionary') {
        const result = {};
        for (let i = 1; i < nops(expr); i++) {
            const kv = keyValuePair(op(expr, i));
            if (kv)
                result[kv[0]] = kv[1];
        }
        return result;
    }
    return null;
}
function applyRecursively(expr, fn) {
    const h = head(expr);
    if (h !== null) {
        return [fn(h), ...(ops(expr) ?? []).map(fn)];
    }
    const dict = dictionary(expr);
    if (dict !== null) {
        const keys = Object.keys(dict);
        const result = {};
        for (const key of keys)
            result[key] = fn(dict[key]);
        return { dict: result };
    }
    return fn(expr);
}
/**
 * Apply a function to the arguments of a function and return an array of T
 */
function mapArgs(expr, fn) {
    let args = null;
    if (Array.isArray(expr))
        args = expr;
    if (isFunctionObject(expr))
        args = expr.fn;
    if (args === null)
        return [];
    let i = 1;
    const result = [];
    while (i < args.length) {
        result.push(fn(args[i]));
        i += 1;
    }
    return result;
}

// This is the root of the `math-json` package (i.e.  `math-json.js` and
const version = '0.12.3';

export { applyRecursively, dictionary as getDictionary, stringValue as getStringValue, head, headName, isDictionaryObject, isFunctionObject, isStringObject, isSymbolObject, mapArgs, nops, op, symbol, version };
