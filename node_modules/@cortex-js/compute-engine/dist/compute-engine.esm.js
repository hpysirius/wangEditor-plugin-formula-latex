/** CortexJS Compute Engine 0.12.3 */
/** @internal */
function isSymbolEntry(entry) {
    return !('kind' in entry) || entry.kind === 'symbol';
}
/** @internal */
function isFunctionEntry(entry) {
    return !('kind' in entry) || entry.kind === 'function';
}
/** @internal */
function isMatchfixEntry(entry) {
    return 'kind' in entry && entry.kind === 'matchfix';
}
/** @internal */
function isInfixEntry(entry) {
    return 'kind' in entry && entry.kind === 'infix';
}
/** @internal */
function isPrefixEntry(entry) {
    return 'kind' in entry && entry.kind === 'prefix';
}
/** @internal */
function isPostfixEntry(entry) {
    return 'kind' in entry && entry.kind === 'postfix';
}
/** @internal */
function isEnvironmentEntry(entry) {
    return 'kind' in entry && entry.kind === 'environment';
}

/*!
 *  decimal.js v10.4.3
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */


// -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //


  // The maximum exponent magnitude.
  // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.
var EXP_LIMIT = 9e15,                      // 0 to 9e15

  // The limit on the value of `precision`, and on the value of the first argument to
  // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
  MAX_DIGITS = 1e9,                        // 0 to 1e9

  // Base conversion alphabet.
  NUMERALS = '0123456789abcdef',

  // The natural logarithm of 10 (1025 digits).
  LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',

  // Pi (1025 digits).
  PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',


  // The initial configuration properties of the Decimal constructor.
  DEFAULTS = {

    // These values must be integers within the stated ranges (inclusive).
    // Most of these values can be changed at run-time using the `Decimal.config` method.

    // The maximum number of significant digits of the result of a calculation or base conversion.
    // E.g. `Decimal.config({ precision: 20 });`
    precision: 20,                         // 1 to MAX_DIGITS

    // The rounding mode used when rounding to `precision`.
    //
    // ROUND_UP         0 Away from zero.
    // ROUND_DOWN       1 Towards zero.
    // ROUND_CEIL       2 Towards +Infinity.
    // ROUND_FLOOR      3 Towards -Infinity.
    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
    //
    // E.g.
    // `Decimal.rounding = 4;`
    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
    rounding: 4,                           // 0 to 8

    // The modulo mode used when calculating the modulus: a mod n.
    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
    // The remainder (r) is calculated as: r = a - n * q.
    //
    // UP         0 The remainder is positive if the dividend is negative, else is negative.
    // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
    // FLOOR      3 The remainder has the same sign as the divisor (Python %).
    // HALF_EVEN  6 The IEEE 754 remainder function.
    // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
    //
    // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
    // division (9) are commonly used for the modulus operation. The other rounding modes can also
    // be used, but they may not give useful results.
    modulo: 1,                             // 0 to 9

    // The exponent value at and beneath which `toString` returns exponential notation.
    // JavaScript numbers: -7
    toExpNeg: -7,                          // 0 to -EXP_LIMIT

    // The exponent value at and above which `toString` returns exponential notation.
    // JavaScript numbers: 21
    toExpPos:  21,                         // 0 to EXP_LIMIT

    // The minimum exponent value, beneath which underflow to zero occurs.
    // JavaScript numbers: -324  (5e-324)
    minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT

    // The maximum exponent value, above which overflow to Infinity occurs.
    // JavaScript numbers: 308  (1.7976931348623157e+308)
    maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT

    // Whether to use cryptographically-secure random number generation, if available.
    crypto: false                          // true/false
  },


// ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //


  inexact, quadrant,
  external = true,

  decimalError = '[DecimalError] ',
  invalidArgument = decimalError + 'Invalid argument: ',
  precisionLimitExceeded = decimalError + 'Precision limit exceeded',
  cryptoUnavailable = decimalError + 'crypto unavailable',
  tag = '[object Decimal]',

  mathfloor = Math.floor,
  mathpow = Math.pow,

  isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
  isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
  isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
  isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,

  BASE = 1e7,
  LOG_BASE = 7,
  MAX_SAFE_INTEGER = 9007199254740991,

  LN10_PRECISION = LN10.length - 1,
  PI_PRECISION = PI.length - 1,

  // Decimal.prototype object
  P = { toStringTag: tag };


// Decimal prototype methods


/*
 *  absoluteValue             abs
 *  ceil
 *  clampedTo                 clamp
 *  comparedTo                cmp
 *  cosine                    cos
 *  cubeRoot                  cbrt
 *  decimalPlaces             dp
 *  dividedBy                 div
 *  dividedToIntegerBy        divToInt
 *  equals                    eq
 *  floor
 *  greaterThan               gt
 *  greaterThanOrEqualTo      gte
 *  hyperbolicCosine          cosh
 *  hyperbolicSine            sinh
 *  hyperbolicTangent         tanh
 *  inverseCosine             acos
 *  inverseHyperbolicCosine   acosh
 *  inverseHyperbolicSine     asinh
 *  inverseHyperbolicTangent  atanh
 *  inverseSine               asin
 *  inverseTangent            atan
 *  isFinite
 *  isInteger                 isInt
 *  isNaN
 *  isNegative                isNeg
 *  isPositive                isPos
 *  isZero
 *  lessThan                  lt
 *  lessThanOrEqualTo         lte
 *  logarithm                 log
 *  [maximum]                 [max]
 *  [minimum]                 [min]
 *  minus                     sub
 *  modulo                    mod
 *  naturalExponential        exp
 *  naturalLogarithm          ln
 *  negated                   neg
 *  plus                      add
 *  precision                 sd
 *  round
 *  sine                      sin
 *  squareRoot                sqrt
 *  tangent                   tan
 *  times                     mul
 *  toBinary
 *  toDecimalPlaces           toDP
 *  toExponential
 *  toFixed
 *  toFraction
 *  toHexadecimal             toHex
 *  toNearest
 *  toNumber
 *  toOctal
 *  toPower                   pow
 *  toPrecision
 *  toSignificantDigits       toSD
 *  toString
 *  truncated                 trunc
 *  valueOf                   toJSON
 */


/*
 * Return a new Decimal whose value is the absolute value of this Decimal.
 *
 */
P.absoluteValue = P.abs = function () {
  var x = new this.constructor(this);
  if (x.s < 0) x.s = 1;
  return finalise(x);
};


/*
 * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
 * direction of positive Infinity.
 *
 */
P.ceil = function () {
  return finalise(new this.constructor(this), this.e + 1, 2);
};


/*
 * Return a new Decimal whose value is the value of this Decimal clamped to the range
 * delineated by `min` and `max`.
 *
 * min {number|string|Decimal}
 * max {number|string|Decimal}
 *
 */
P.clampedTo = P.clamp = function (min, max) {
  var k,
    x = this,
    Ctor = x.constructor;
  min = new Ctor(min);
  max = new Ctor(max);
  if (!min.s || !max.s) return new Ctor(NaN);
  if (min.gt(max)) throw Error(invalidArgument + max);
  k = x.cmp(min);
  return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);
};


/*
 * Return
 *   1    if the value of this Decimal is greater than the value of `y`,
 *  -1    if the value of this Decimal is less than the value of `y`,
 *   0    if they have the same value,
 *   NaN  if the value of either Decimal is NaN.
 *
 */
P.comparedTo = P.cmp = function (y) {
  var i, j, xdL, ydL,
    x = this,
    xd = x.d,
    yd = (y = new x.constructor(y)).d,
    xs = x.s,
    ys = y.s;

  // Either NaN or ±Infinity?
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }

  // Either zero?
  if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;

  // Signs differ?
  if (xs !== ys) return xs;

  // Compare exponents.
  if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;

  xdL = xd.length;
  ydL = yd.length;

  // Compare digit by digit.
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
  }

  // Compare lengths.
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};


/*
 * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [-1, 1]
 *
 * cos(0)         = 1
 * cos(-0)        = 1
 * cos(Infinity)  = NaN
 * cos(-Infinity) = NaN
 * cos(NaN)       = NaN
 *
 */
P.cosine = P.cos = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.d) return new Ctor(NaN);

  // cos(0) = cos(-0) = 1
  if (!x.d[0]) return new Ctor(1);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;

  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
};


/*
 *
 * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 *  cbrt(0)  =  0
 *  cbrt(-0) = -0
 *  cbrt(1)  =  1
 *  cbrt(-1) = -1
 *  cbrt(N)  =  N
 *  cbrt(-I) = -I
 *  cbrt(I)  =  I
 *
 * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
 *
 */
P.cubeRoot = P.cbrt = function () {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite() || x.isZero()) return new Ctor(x);
  external = false;

  // Initial estimate.
  s = x.s * mathpow(x.s * x, 1 / 3);

   // Math.cbrt underflow/overflow?
   // Pass x to Math.pow as integer, then adjust the exponent of the result.
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e = x.e;

    // Adjust n exponent so it is a multiple of 3 away from x exponent.
    if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
    s = mathpow(n, 1 / 3);

    // Rarely, e may be one less than the result exponent value.
    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));

    if (s == 1 / 0) {
      n = '5e' + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf('e') + 1) + e;
    }

    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }

  sd = (e = Ctor.precision) + 3;

  // Halley's method.
  // TODO? Compare Newton's method.
  for (;;) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);

    // TODO? Replace with for-loop and checkRoundingDigits.
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);

      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
      // , i.e. approaching a rounding boundary, continue the iteration.
      if (n == '9999' || !rep && n == '4999') {

        // On the first iteration only, check to see if rounding up gives the exact result as the
        // nines may infinitely repeat.
        if (!rep) {
          finalise(t, e + 1, 0);

          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }

        sd += 4;
        rep = 1;
      } else {

        // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
        // If not, then there are further digits and m will be truthy.
        if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

          // Truncate to the first rounding digit.
          finalise(r, e + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }

        break;
      }
    }
  }

  external = true;

  return finalise(r, e, Ctor.rounding, m);
};


/*
 * Return the number of decimal places of the value of this Decimal.
 *
 */
P.decimalPlaces = P.dp = function () {
  var w,
    d = this.d,
    n = NaN;

  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;

    // Subtract the number of trailing zeros of the last word.
    w = d[w];
    if (w) for (; w % 10 == 0; w /= 10) n--;
    if (n < 0) n = 0;
  }

  return n;
};


/*
 *  n / 0 = I
 *  n / N = N
 *  n / I = 0
 *  0 / n = 0
 *  0 / 0 = N
 *  0 / N = N
 *  0 / I = 0
 *  N / n = N
 *  N / 0 = N
 *  N / N = N
 *  N / I = N
 *  I / n = I
 *  I / 0 = I
 *  I / N = N
 *  I / I = N
 *
 * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 */
P.dividedBy = P.div = function (y) {
  return divide(this, new this.constructor(y));
};


/*
 * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
 * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.
 *
 */
P.dividedToIntegerBy = P.divToInt = function (y) {
  var x = this,
    Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};


/*
 * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
 *
 */
P.equals = P.eq = function (y) {
  return this.cmp(y) === 0;
};


/*
 * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
 * direction of negative Infinity.
 *
 */
P.floor = function () {
  return finalise(new this.constructor(this), this.e + 1, 3);
};


/*
 * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
 * false.
 *
 */
P.greaterThan = P.gt = function (y) {
  return this.cmp(y) > 0;
};


/*
 * Return true if the value of this Decimal is greater than or equal to the value of `y`,
 * otherwise return false.
 *
 */
P.greaterThanOrEqualTo = P.gte = function (y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
};


/*
 * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this
 * Decimal.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [1, Infinity]
 *
 * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...
 *
 * cosh(0)         = 1
 * cosh(-0)        = 1
 * cosh(Infinity)  = Infinity
 * cosh(-Infinity) = Infinity
 * cosh(NaN)       = NaN
 *
 *  x        time taken (ms)   result
 * 1000      9                 9.8503555700852349694e+433
 * 10000     25                4.4034091128314607936e+4342
 * 100000    171               1.4033316802130615897e+43429
 * 1000000   3817              1.5166076984010437725e+434294
 * 10000000  abandoned after 2 minute wait
 *
 * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))
 *
 */
P.hyperbolicCosine = P.cosh = function () {
  var k, n, pr, rm, len,
    x = this,
    Ctor = x.constructor,
    one = new Ctor(1);

  if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero()) return one;

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;

  // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
  // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))

  // Estimate the optimum number of times to use the argument reduction.
  // TODO? Estimation reused from cosine() and may not be optimal here.
  if (len < 32) {
    k = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    n = '2.3283064365386962890625e-10';
  }

  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);

  // Reverse argument reduction
  var cosh2_x,
    i = k,
    d8 = new Ctor(8);
  for (; i--;) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }

  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
};


/*
 * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this
 * Decimal.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [-Infinity, Infinity]
 *
 * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...
 *
 * sinh(0)         = 0
 * sinh(-0)        = -0
 * sinh(Infinity)  = Infinity
 * sinh(-Infinity) = -Infinity
 * sinh(NaN)       = NaN
 *
 * x        time taken (ms)
 * 10       2 ms
 * 100      5 ms
 * 1000     14 ms
 * 10000    82 ms
 * 100000   886 ms            1.4033316802130615897e+43429
 * 200000   2613 ms
 * 300000   5407 ms
 * 400000   8824 ms
 * 500000   13026 ms          8.7080643612718084129e+217146
 * 1000000  48543 ms
 *
 * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))
 *
 */
P.hyperbolicSine = P.sinh = function () {
  var k, pr, rm, len,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite() || x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;

  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {

    // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
    // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
    // 3 multiplications and 1 addition

    // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
    // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
    // 4 multiplications and 2 additions

    // Estimate the optimum number of times to use the argument reduction.
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;

    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x, true);

    // Reverse argument reduction
    var sinh2_x,
      d5 = new Ctor(5),
      d16 = new Ctor(16),
      d20 = new Ctor(20);
    for (; k--;) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(x, pr, rm, true);
};


/*
 * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this
 * Decimal.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [-1, 1]
 *
 * tanh(x) = sinh(x) / cosh(x)
 *
 * tanh(0)         = 0
 * tanh(-0)        = -0
 * tanh(Infinity)  = 1
 * tanh(-Infinity) = -1
 * tanh(NaN)       = NaN
 *
 */
P.hyperbolicTangent = P.tanh = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(x.s);
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;

  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};


/*
 * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
 * this Decimal.
 *
 * Domain: [-1, 1]
 * Range: [0, pi]
 *
 * acos(x) = pi/2 - asin(x)
 *
 * acos(0)       = pi/2
 * acos(-0)      = pi/2
 * acos(1)       = 0
 * acos(-1)      = pi
 * acos(1/2)     = pi/3
 * acos(-1/2)    = 2*pi/3
 * acos(|x| > 1) = NaN
 * acos(NaN)     = NaN
 *
 */
P.inverseCosine = P.acos = function () {
  var halfPi,
    x = this,
    Ctor = x.constructor,
    k = x.abs().cmp(1),
    pr = Ctor.precision,
    rm = Ctor.rounding;

  if (k !== -1) {
    return k === 0
      // |x| is 1
      ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)
      // |x| > 1 or x is NaN
      : new Ctor(NaN);
  }

  if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

  // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

  Ctor.precision = pr + 6;
  Ctor.rounding = 1;

  x = x.asin();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return halfPi.minus(x);
};


/*
 * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the
 * value of this Decimal.
 *
 * Domain: [1, Infinity]
 * Range: [0, Infinity]
 *
 * acosh(x) = ln(x + sqrt(x^2 - 1))
 *
 * acosh(x < 1)     = NaN
 * acosh(NaN)       = NaN
 * acosh(Infinity)  = Infinity
 * acosh(-Infinity) = NaN
 * acosh(0)         = NaN
 * acosh(-0)        = NaN
 * acosh(1)         = 0
 * acosh(-1)        = NaN
 *
 */
P.inverseHyperbolicCosine = P.acosh = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;

  x = x.times(x).minus(1).sqrt().plus(x);

  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.ln();
};


/*
 * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
 * of this Decimal.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [-Infinity, Infinity]
 *
 * asinh(x) = ln(x + sqrt(x^2 + 1))
 *
 * asinh(NaN)       = NaN
 * asinh(Infinity)  = Infinity
 * asinh(-Infinity) = -Infinity
 * asinh(0)         = 0
 * asinh(-0)        = -0
 *
 */
P.inverseHyperbolicSine = P.asinh = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite() || x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;

  x = x.times(x).plus(1).sqrt().plus(x);

  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.ln();
};


/*
 * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the
 * value of this Decimal.
 *
 * Domain: [-1, 1]
 * Range: [-Infinity, Infinity]
 *
 * atanh(x) = 0.5 * ln((1 + x) / (1 - x))
 *
 * atanh(|x| > 1)   = NaN
 * atanh(NaN)       = NaN
 * atanh(Infinity)  = NaN
 * atanh(-Infinity) = NaN
 * atanh(0)         = 0
 * atanh(-0)        = -0
 * atanh(1)         = Infinity
 * atanh(-1)        = -Infinity
 *
 */
P.inverseHyperbolicTangent = P.atanh = function () {
  var pr, rm, wpr, xsd,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(NaN);
  if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();

  if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);

  Ctor.precision = wpr = xsd - x.e;

  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);

  Ctor.precision = pr + 4;
  Ctor.rounding = 1;

  x = x.ln();

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.times(0.5);
};


/*
 * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this
 * Decimal.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [-pi/2, pi/2]
 *
 * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))
 *
 * asin(0)       = 0
 * asin(-0)      = -0
 * asin(1/2)     = pi/6
 * asin(-1/2)    = -pi/6
 * asin(1)       = pi/2
 * asin(-1)      = -pi/2
 * asin(|x| > 1) = NaN
 * asin(NaN)     = NaN
 *
 * TODO? Compare performance of Taylor series.
 *
 */
P.inverseSine = P.asin = function () {
  var halfPi, k,
    pr, rm,
    x = this,
    Ctor = x.constructor;

  if (x.isZero()) return new Ctor(x);

  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;

  if (k !== -1) {

    // |x| is 1
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }

    // |x| > 1 or x is NaN
    return new Ctor(NaN);
  }

  // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

  Ctor.precision = pr + 6;
  Ctor.rounding = 1;

  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.times(2);
};


/*
 * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value
 * of this Decimal.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [-pi/2, pi/2]
 *
 * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
 *
 * atan(0)         = 0
 * atan(-0)        = -0
 * atan(1)         = pi/4
 * atan(-1)        = -pi/4
 * atan(Infinity)  = pi/2
 * atan(-Infinity) = -pi/2
 * atan(NaN)       = NaN
 *
 */
P.inverseTangent = P.atan = function () {
  var i, j, k, n, px, t, r, wpr, x2,
    x = this,
    Ctor = x.constructor,
    pr = Ctor.precision,
    rm = Ctor.rounding;

  if (!x.isFinite()) {
    if (!x.s) return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }

  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;

  // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);

  // Argument reduction
  // Ensure |x| < 0.42
  // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

  k = Math.min(28, wpr / LOG_BASE + 2 | 0);

  for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

  external = false;

  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;

  // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
  for (; i !== -1;) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));

    px = px.times(x2);
    r = t.plus(px.div(n += 2));

    if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);
  }

  if (k) r = r.times(2 << (k - 1));

  external = true;

  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};


/*
 * Return true if the value of this Decimal is a finite number, otherwise return false.
 *
 */
P.isFinite = function () {
  return !!this.d;
};


/*
 * Return true if the value of this Decimal is an integer, otherwise return false.
 *
 */
P.isInteger = P.isInt = function () {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};


/*
 * Return true if the value of this Decimal is NaN, otherwise return false.
 *
 */
P.isNaN = function () {
  return !this.s;
};


/*
 * Return true if the value of this Decimal is negative, otherwise return false.
 *
 */
P.isNegative = P.isNeg = function () {
  return this.s < 0;
};


/*
 * Return true if the value of this Decimal is positive, otherwise return false.
 *
 */
P.isPositive = P.isPos = function () {
  return this.s > 0;
};


/*
 * Return true if the value of this Decimal is 0 or -0, otherwise return false.
 *
 */
P.isZero = function () {
  return !!this.d && this.d[0] === 0;
};


/*
 * Return true if the value of this Decimal is less than `y`, otherwise return false.
 *
 */
P.lessThan = P.lt = function (y) {
  return this.cmp(y) < 0;
};


/*
 * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
 *
 */
P.lessThanOrEqualTo = P.lte = function (y) {
  return this.cmp(y) < 1;
};


/*
 * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * If no base is specified, return log[10](arg).
 *
 * log[base](arg) = ln(arg) / ln(base)
 *
 * The result will always be correctly rounded if the base of the log is 10, and 'almost always'
 * otherwise:
 *
 * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen
 * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error
 * between the result and the correctly rounded result will be one ulp (unit in the last place).
 *
 * log[-b](a)       = NaN
 * log[0](a)        = NaN
 * log[1](a)        = NaN
 * log[NaN](a)      = NaN
 * log[Infinity](a) = NaN
 * log[b](0)        = -Infinity
 * log[b](-0)       = -Infinity
 * log[b](-a)       = NaN
 * log[b](1)        = 0
 * log[b](Infinity) = Infinity
 * log[b](NaN)      = NaN
 *
 * [base] {number|string|Decimal} The base of the logarithm.
 *
 */
P.logarithm = P.log = function (base) {
  var isBase10, d, denominator, k, inf, num, sd, r,
    arg = this,
    Ctor = arg.constructor,
    pr = Ctor.precision,
    rm = Ctor.rounding,
    guard = 5;

  // Default base is 10.
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;

    // Return NaN if base is negative, or non-finite, or is 0 or 1.
    if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);

    isBase10 = base.eq(10);
  }

  d = arg.d;

  // Is arg negative, non-finite, 0 or 1?
  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }

  // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
  // integer power of 10.
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k = d[0]; k % 10 === 0;) k /= 10;
      inf = k !== 1;
    }
  }

  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);

  // The result will have 5 rounding digits.
  r = divide(num, denominator, sd, 1);

  // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
  // calculate 10 further digits.
  //
  // If the result is known to have an infinite decimal expansion, repeat this until it is clear
  // that the result is above or below the boundary. Otherwise, if after calculating the 10
  // further digits, the last 14 are nines, round up and assume the result is exact.
  // Also assume the result is exact if the last 14 are zero.
  //
  // Example of a result that will be incorrectly rounded:
  // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
  // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
  // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
  // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
  // place is still 2.6.
  if (checkRoundingDigits(r.d, k = pr, rm)) {

    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);

      if (!inf) {

        // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }

        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }

  external = true;

  return finalise(r, pr, rm);
};


/*
 * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.
 *
 * arguments {number|string|Decimal}
 *
P.max = function () {
  Array.prototype.push.call(arguments, this);
  return maxOrMin(this.constructor, arguments, 'lt');
};
 */


/*
 * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.
 *
 * arguments {number|string|Decimal}
 *
P.min = function () {
  Array.prototype.push.call(arguments, this);
  return maxOrMin(this.constructor, arguments, 'gt');
};
 */


/*
 *  n - 0 = n
 *  n - N = N
 *  n - I = -I
 *  0 - n = -n
 *  0 - 0 = 0
 *  0 - N = N
 *  0 - I = -I
 *  N - n = N
 *  N - 0 = N
 *  N - N = N
 *  N - I = N
 *  I - n = I
 *  I - 0 = I
 *  I - N = N
 *  I - I = N
 *
 * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 */
P.minus = P.sub = function (y) {
  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,
    x = this,
    Ctor = x.constructor;

  y = new Ctor(y);

  // If either is not finite...
  if (!x.d || !y.d) {

    // Return NaN if either is NaN.
    if (!x.s || !y.s) y = new Ctor(NaN);

    // Return y negated if x is finite and y is ±Infinity.
    else if (x.d) y.s = -y.s;

    // Return x if y is finite and x is ±Infinity.
    // Return x if both are ±Infinity with different signs.
    // Return NaN if both are ±Infinity with the same sign.
    else y = new Ctor(y.d || x.s !== y.s ? x : NaN);

    return y;
  }

  // If signs differ...
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }

  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;

  // If either is zero...
  if (!xd[0] || !yd[0]) {

    // Return y negated if x is zero and y is non-zero.
    if (yd[0]) y.s = -y.s;

    // Return x if y is zero and x is non-zero.
    else if (xd[0]) y = new Ctor(x);

    // Return zero if both are zero.
    // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
    else return new Ctor(rm === 3 ? -0 : 0);

    return external ? finalise(y, pr, rm) : y;
  }

  // x and y are finite, non-zero numbers with the same sign.

  // Calculate base 1e7 exponents.
  e = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);

  xd = xd.slice();
  k = xe - e;

  // If base 1e7 exponents differ...
  if (k) {
    xLTy = k < 0;

    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }

    // Numbers with massively different exponents would result in a very high number of
    // zeros needing to be prepended, but this can be avoided while still ensuring correct
    // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

    if (k > i) {
      k = i;
      d.length = 1;
    }

    // Prepend zeros to equalise exponents.
    d.reverse();
    for (i = k; i--;) d.push(0);
    d.reverse();

  // Base 1e7 exponents equal.
  } else {

    // Check digits to determine which is the bigger number.

    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy) len = i;

    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }

    k = 0;
  }

  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }

  len = xd.length;

  // Append zeros to `xd` if shorter.
  // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.
  for (i = yd.length - len; i > 0; --i) xd[len++] = 0;

  // Subtract yd from xd.
  for (i = yd.length; i > k;) {

    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }

    xd[i] -= yd[i];
  }

  // Remove trailing zeros.
  for (; xd[--len] === 0;) xd.pop();

  // Remove leading zeros and adjust exponent accordingly.
  for (; xd[0] === 0; xd.shift()) --e;

  // Zero?
  if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);

  y.d = xd;
  y.e = getBase10Exponent(xd, e);

  return external ? finalise(y, pr, rm) : y;
};


/*
 *   n % 0 =  N
 *   n % N =  N
 *   n % I =  n
 *   0 % n =  0
 *  -0 % n = -0
 *   0 % 0 =  N
 *   0 % N =  N
 *   0 % I =  0
 *   N % n =  N
 *   N % 0 =  N
 *   N % N =  N
 *   N % I =  N
 *   I % n =  N
 *   I % 0 =  N
 *   I % N =  N
 *   I % I =  N
 *
 * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 * The result depends on the modulo mode.
 *
 */
P.modulo = P.mod = function (y) {
  var q,
    x = this,
    Ctor = x.constructor;

  y = new Ctor(y);

  // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.
  if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);

  // Return x if y is ±Infinity or x is ±0.
  if (!y.d || x.d && !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }

  // Prevent rounding of intermediate calculations.
  external = false;

  if (Ctor.modulo == 9) {

    // Euclidian division: q = sign(y) * floor(x / abs(y))
    // result = x - q * y    where  0 <= result < abs(y)
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }

  q = q.times(y);

  external = true;

  return x.minus(q);
};


/*
 * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
 * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 */
P.naturalExponential = P.exp = function () {
  return naturalExponential(this);
};


/*
 * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
 * rounded to `precision` significant digits using rounding mode `rounding`.
 *
 */
P.naturalLogarithm = P.ln = function () {
  return naturalLogarithm(this);
};


/*
 * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
 * -1.
 *
 */
P.negated = P.neg = function () {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
};


/*
 *  n + 0 = n
 *  n + N = N
 *  n + I = I
 *  0 + n = n
 *  0 + 0 = 0
 *  0 + N = N
 *  0 + I = I
 *  N + n = N
 *  N + 0 = N
 *  N + N = N
 *  N + I = N
 *  I + n = I
 *  I + 0 = I
 *  I + N = N
 *  I + I = I
 *
 * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 */
P.plus = P.add = function (y) {
  var carry, d, e, i, k, len, pr, rm, xd, yd,
    x = this,
    Ctor = x.constructor;

  y = new Ctor(y);

  // If either is not finite...
  if (!x.d || !y.d) {

    // Return NaN if either is NaN.
    if (!x.s || !y.s) y = new Ctor(NaN);

    // Return x if y is finite and x is ±Infinity.
    // Return x if both are ±Infinity with the same sign.
    // Return NaN if both are ±Infinity with different signs.
    // Return y if x is finite and y is ±Infinity.
    else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);

    return y;
  }

   // If signs differ...
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }

  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;

  // If either is zero...
  if (!xd[0] || !yd[0]) {

    // Return x if y is zero.
    // Return y if y is non-zero.
    if (!yd[0]) y = new Ctor(x);

    return external ? finalise(y, pr, rm) : y;
  }

  // x and y are finite, non-zero numbers with the same sign.

  // Calculate base 1e7 exponents.
  k = mathfloor(x.e / LOG_BASE);
  e = mathfloor(y.e / LOG_BASE);

  xd = xd.slice();
  i = k - e;

  // If base 1e7 exponents differ...
  if (i) {

    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }

    // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;

    if (i > len) {
      i = len;
      d.length = 1;
    }

    // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
    d.reverse();
    for (; i--;) d.push(0);
    d.reverse();
  }

  len = xd.length;
  i = yd.length;

  // If yd is longer than xd, swap xd and yd so xd points to the longer array.
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }

  // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
  for (carry = 0; i;) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }

  if (carry) {
    xd.unshift(carry);
    ++e;
  }

  // Remove trailing zeros.
  // No need to check for zero, as +x + +y != 0 && -x + -y != 0
  for (len = xd.length; xd[--len] == 0;) xd.pop();

  y.d = xd;
  y.e = getBase10Exponent(xd, e);

  return external ? finalise(y, pr, rm) : y;
};


/*
 * Return the number of significant digits of the value of this Decimal.
 *
 * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
 *
 */
P.precision = P.sd = function (z) {
  var k,
    x = this;

  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

  if (x.d) {
    k = getPrecision(x.d);
    if (z && x.e + 1 > k) k = x.e + 1;
  } else {
    k = NaN;
  }

  return k;
};


/*
 * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
 * rounding mode `rounding`.
 *
 */
P.round = function () {
  var x = this,
    Ctor = x.constructor;

  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
};


/*
 * Return a new Decimal whose value is the sine of the value in radians of this Decimal.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [-1, 1]
 *
 * sin(x) = x - x^3/3! + x^5/5! - ...
 *
 * sin(0)         = 0
 * sin(-0)        = -0
 * sin(Infinity)  = NaN
 * sin(-Infinity) = NaN
 * sin(NaN)       = NaN
 *
 */
P.sine = P.sin = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(NaN);
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;

  x = sine(Ctor, toLessThanHalfPi(Ctor, x));

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
};


/*
 * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 *  sqrt(-n) =  N
 *  sqrt(N)  =  N
 *  sqrt(-I) =  N
 *  sqrt(I)  =  I
 *  sqrt(0)  =  0
 *  sqrt(-0) = -0
 *
 */
P.squareRoot = P.sqrt = function () {
  var m, n, sd, r, rep, t,
    x = this,
    d = x.d,
    e = x.e,
    s = x.s,
    Ctor = x.constructor;

  // Negative/NaN/Infinity/zero?
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }

  external = false;

  // Initial estimate.
  s = Math.sqrt(+x);

  // Math.sqrt underflow/overflow?
  // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);

    if ((n.length + e) % 2 == 0) n += '0';
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

    if (s == 1 / 0) {
      n = '5e' + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf('e') + 1) + e;
    }

    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }

  sd = (e = Ctor.precision) + 3;

  // Newton-Raphson iteration.
  for (;;) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);

    // TODO? Replace with for-loop and checkRoundingDigits.
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);

      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
      // 4999, i.e. approaching a rounding boundary, continue the iteration.
      if (n == '9999' || !rep && n == '4999') {

        // On the first iteration only, check to see if rounding up gives the exact result as the
        // nines may infinitely repeat.
        if (!rep) {
          finalise(t, e + 1, 0);

          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }

        sd += 4;
        rep = 1;
      } else {

        // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
        // If not, then there are further digits and m will be truthy.
        if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

          // Truncate to the first rounding digit.
          finalise(r, e + 1, 1);
          m = !r.times(r).eq(x);
        }

        break;
      }
    }
  }

  external = true;

  return finalise(r, e, Ctor.rounding, m);
};


/*
 * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [-Infinity, Infinity]
 *
 * tan(0)         = 0
 * tan(-0)        = -0
 * tan(Infinity)  = NaN
 * tan(-Infinity) = NaN
 * tan(NaN)       = NaN
 *
 */
P.tangent = P.tan = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(NaN);
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;

  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
};


/*
 *  n * 0 = 0
 *  n * N = N
 *  n * I = I
 *  0 * n = 0
 *  0 * 0 = 0
 *  0 * N = N
 *  0 * I = N
 *  N * n = N
 *  N * 0 = N
 *  N * N = N
 *  N * I = N
 *  I * n = I
 *  I * 0 = N
 *  I * N = N
 *  I * I = I
 *
 * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 */
P.times = P.mul = function (y) {
  var carry, e, i, k, r, rL, t, xdL, ydL,
    x = this,
    Ctor = x.constructor,
    xd = x.d,
    yd = (y = new Ctor(y)).d;

  y.s *= x.s;

   // If either is NaN, ±Infinity or ±0...
  if (!xd || !xd[0] || !yd || !yd[0]) {

    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd

      // Return NaN if either is NaN.
      // Return NaN if x is ±0 and y is ±Infinity, or y is ±0 and x is ±Infinity.
      ? NaN

      // Return ±Infinity if either is ±Infinity.
      // Return ±0 if either is ±0.
      : !xd || !yd ? y.s / 0 : y.s * 0);
  }

  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;

  // Ensure xd points to the longer array.
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }

  // Initialise the result array with zeros.
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--;) r.push(0);

  // Multiply!
  for (i = ydL; --i >= 0;) {
    carry = 0;
    for (k = xdL + i; k > i;) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }

    r[k] = (r[k] + carry) % BASE | 0;
  }

  // Remove trailing zeros.
  for (; !r[--rL];) r.pop();

  if (carry) ++e;
  else r.shift();

  y.d = r;
  y.e = getBase10Exponent(r, e);

  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
};


/*
 * Return a string representing the value of this Decimal in base 2, round to `sd` significant
 * digits using rounding mode `rm`.
 *
 * If the optional `sd` argument is present then return binary exponential notation.
 *
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P.toBinary = function (sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};


/*
 * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
 * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
 *
 * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
 *
 * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P.toDecimalPlaces = P.toDP = function (dp, rm) {
  var x = this,
    Ctor = x.constructor;

  x = new Ctor(x);
  if (dp === void 0) return x;

  checkInt32(dp, 0, MAX_DIGITS);

  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);

  return finalise(x, dp + x.e + 1, rm);
};


/*
 * Return a string representing the value of this Decimal in exponential notation rounded to
 * `dp` fixed decimal places using rounding mode `rounding`.
 *
 * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P.toExponential = function (dp, rm) {
  var str,
    x = this,
    Ctor = x.constructor;

  if (dp === void 0) {
    str = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    x = finalise(new Ctor(x), dp + 1, rm);
    str = finiteToString(x, true, dp + 1);
  }

  return x.isNeg() && !x.isZero() ? '-' + str : str;
};


/*
 * Return a string representing the value of this Decimal in normal (fixed-point) notation to
 * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
 * omitted.
 *
 * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
 *
 * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
 * (-0).toFixed(3) is '0.000'.
 * (-0.5).toFixed(0) is '-0'.
 *
 */
P.toFixed = function (dp, rm) {
  var str, y,
    x = this,
    Ctor = x.constructor;

  if (dp === void 0) {
    str = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str = finiteToString(y, false, dp + y.e + 1);
  }

  // To determine whether to add the minus sign look at the value before it was rounded,
  // i.e. look at `x` rather than `y`.
  return x.isNeg() && !x.isZero() ? '-' + str : str;
};


/*
 * Return an array representing the value of this Decimal as a simple fraction with an integer
 * numerator and an integer denominator.
 *
 * The denominator will be a positive non-zero value less than or equal to the specified maximum
 * denominator. If a maximum denominator is not specified, the denominator will be the lowest
 * value necessary to represent the number exactly.
 *
 * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.
 *
 */
P.toFraction = function (maxD) {
  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,
    x = this,
    xd = x.d,
    Ctor = x.constructor;

  if (!xd) return new Ctor(x);

  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);

  d = new Ctor(d1);
  e = d.e = getPrecision(xd) - x.e - 1;
  k = e % LOG_BASE;
  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);

  if (maxD == null) {

    // d is 10**e, the minimum max-denominator needed.
    maxD = e > 0 ? d : n1;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
    maxD = n.gt(d) ? (e > 0 ? d : n1) : n;
  }

  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE * 2;

  for (;;)  {
    q = divide(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1) break;
    d0 = d1;
    d1 = d2;
    d2 = n1;
    n1 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }

  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n1));
  d0 = d0.plus(d2.times(d1));
  n0.s = n1.s = x.s;

  // Determine which fraction is closer to x, n0/d0 or n1/d1?
  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1
      ? [n1, d1] : [n0, d0];

  Ctor.precision = pr;
  external = true;

  return r;
};


/*
 * Return a string representing the value of this Decimal in base 16, round to `sd` significant
 * digits using rounding mode `rm`.
 *
 * If the optional `sd` argument is present then return binary exponential notation.
 *
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P.toHexadecimal = P.toHex = function (sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};


/*
 * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding
 * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.
 *
 * The return value will always have the same sign as this Decimal, unless either this Decimal
 * or `y` is NaN, in which case the return value will be also be NaN.
 *
 * The return value is not affected by the value of `precision`.
 *
 * y {number|string|Decimal} The magnitude to round to a multiple of.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 * 'toNearest() rounding mode not an integer: {rm}'
 * 'toNearest() rounding mode out of range: {rm}'
 *
 */
P.toNearest = function (y, rm) {
  var x = this,
    Ctor = x.constructor;

  x = new Ctor(x);

  if (y == null) {

    // If x is not finite, return x.
    if (!x.d) return x;

    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }

    // If x is not finite, return x if y is not NaN, else NaN.
    if (!x.d) return y.s ? x : y;

    // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.
    if (!y.d) {
      if (y.s) y.s = x.s;
      return y;
    }
  }

  // If y is not zero, calculate the nearest multiple of y to x.
  if (y.d[0]) {
    external = false;
    x = divide(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);

  // If y is zero, return zero with the sign of x.
  } else {
    y.s = x.s;
    x = y;
  }

  return x;
};


/*
 * Return the value of this Decimal converted to a number primitive.
 * Zero keeps its sign.
 *
 */
P.toNumber = function () {
  return +this;
};


/*
 * Return a string representing the value of this Decimal in base 8, round to `sd` significant
 * digits using rounding mode `rm`.
 *
 * If the optional `sd` argument is present then return binary exponential notation.
 *
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P.toOctal = function (sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};


/*
 * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded
 * to `precision` significant digits using rounding mode `rounding`.
 *
 * ECMAScript compliant.
 *
 *   pow(x, NaN)                           = NaN
 *   pow(x, ±0)                            = 1

 *   pow(NaN, non-zero)                    = NaN
 *   pow(abs(x) > 1, +Infinity)            = +Infinity
 *   pow(abs(x) > 1, -Infinity)            = +0
 *   pow(abs(x) == 1, ±Infinity)           = NaN
 *   pow(abs(x) < 1, +Infinity)            = +0
 *   pow(abs(x) < 1, -Infinity)            = +Infinity
 *   pow(+Infinity, y > 0)                 = +Infinity
 *   pow(+Infinity, y < 0)                 = +0
 *   pow(-Infinity, odd integer > 0)       = -Infinity
 *   pow(-Infinity, even integer > 0)      = +Infinity
 *   pow(-Infinity, odd integer < 0)       = -0
 *   pow(-Infinity, even integer < 0)      = +0
 *   pow(+0, y > 0)                        = +0
 *   pow(+0, y < 0)                        = +Infinity
 *   pow(-0, odd integer > 0)              = -0
 *   pow(-0, even integer > 0)             = +0
 *   pow(-0, odd integer < 0)              = -Infinity
 *   pow(-0, even integer < 0)             = +Infinity
 *   pow(finite x < 0, finite non-integer) = NaN
 *
 * For non-integer or very large exponents pow(x, y) is calculated using
 *
 *   x^y = exp(y*ln(x))
 *
 * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the
 * probability of an incorrectly rounded result
 * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14
 * i.e. 1 in 250,000,000,000,000
 *
 * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).
 *
 * y {number|string|Decimal} The power to which to raise this Decimal.
 *
 */
P.toPower = P.pow = function (y) {
  var e, k, pr, r, rm, s,
    x = this,
    Ctor = x.constructor,
    yn = +(y = new Ctor(y));

  // Either ±Infinity, NaN or ±0?
  if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));

  x = new Ctor(x);

  if (x.eq(1)) return x;

  pr = Ctor.precision;
  rm = Ctor.rounding;

  if (y.eq(1)) return finalise(x, pr, rm);

  // y exponent
  e = mathfloor(y.e / LOG_BASE);

  // If y is a small integer use the 'exponentiation by squaring' algorithm.
  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }

  s = x.s;

  // if x is negative
  if (s < 0) {

    // if y is not an integer
    if (e < y.d.length - 1) return new Ctor(NaN);

    // Result is positive if x is negative and the last digit of integer y is even.
    if ((y.d[e] & 1) == 0) s = 1;

    // if x.eq(-1)
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s;
      return x;
    }
  }

  // Estimate result exponent.
  // x^y = 10^e,  where e = y * log10(x)
  // log10(x) = log10(x_significand) + x_exponent
  // log10(x_significand) = ln(x_significand) / ln(10)
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k)
    ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))
    : new Ctor(k + '').e;

  // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

  // Overflow/underflow?
  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);

  external = false;
  Ctor.rounding = x.s = 1;

  // Estimate the extra guard digits needed to ensure five correct rounding digits from
  // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
  // new Decimal(2.32456).pow('2087987436534566.46411')
  // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815
  k = Math.min(12, (e + '').length);

  // r = x^y = exp(y*ln(x))
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);

  // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)
  if (r.d) {

    // Truncate to the required precision plus five rounding digits.
    r = finalise(r, pr + 5, 1);

    // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
    // the result.
    if (checkRoundingDigits(r.d, pr, rm)) {
      e = pr + 10;

      // Truncate to the increased precision plus five rounding digits.
      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);

      // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }

  r.s = s;
  external = true;
  Ctor.rounding = rm;

  return finalise(r, pr, rm);
};


/*
 * Return a string representing the value of this Decimal rounded to `sd` significant digits
 * using rounding mode `rounding`.
 *
 * Return exponential notation if `sd` is less than the number of digits necessary to represent
 * the integer part of the value in normal notation.
 *
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P.toPrecision = function (sd, rm) {
  var str,
    x = this,
    Ctor = x.constructor;

  if (sd === void 0) {
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    x = finalise(new Ctor(x), sd, rm);
    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
  }

  return x.isNeg() && !x.isZero() ? '-' + str : str;
};


/*
 * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
 * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
 * omitted.
 *
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 * 'toSD() digits out of range: {sd}'
 * 'toSD() digits not an integer: {sd}'
 * 'toSD() rounding mode not an integer: {rm}'
 * 'toSD() rounding mode out of range: {rm}'
 *
 */
P.toSignificantDigits = P.toSD = function (sd, rm) {
  var x = this,
    Ctor = x.constructor;

  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  }

  return finalise(new Ctor(x), sd, rm);
};


/*
 * Return a string representing the value of this Decimal.
 *
 * Return exponential notation if this Decimal has a positive exponent equal to or greater than
 * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
 *
 */
P.toString = function () {
  var x = this,
    Ctor = x.constructor,
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

  return x.isNeg() && !x.isZero() ? '-' + str : str;
};


/*
 * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.
 *
 */
P.truncated = P.trunc = function () {
  return finalise(new this.constructor(this), this.e + 1, 1);
};


/*
 * Return a string representing the value of this Decimal.
 * Unlike `toString`, negative zero will include the minus sign.
 *
 */
P.valueOf = P.toJSON = function () {
  var x = this,
    Ctor = x.constructor,
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

  return x.isNeg() ? '-' + str : str;
};


// Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.


/*
 *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,
 *                           finiteToString, naturalExponential, naturalLogarithm
 *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,
 *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random
 *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm
 *  convertBase              toStringBinary, parseOther
 *  cos                      P.cos
 *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,
 *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,
 *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,
 *                           taylorSeries, atan2, parseOther
 *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,
 *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,
 *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,
 *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,
 *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,
 *                           P.truncated, divide, getLn10, getPi, naturalExponential,
 *                           naturalLogarithm, ceil, floor, round, trunc
 *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,
 *                           toStringBinary
 *  getBase10Exponent        P.minus, P.plus, P.times, parseOther
 *  getLn10                  P.logarithm, naturalLogarithm
 *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2
 *  getPrecision             P.precision, P.toFraction
 *  getZeroString            digitsToString, finiteToString
 *  intPow                   P.toPower, parseOther
 *  isOdd                    toLessThanHalfPi
 *  maxOrMin                 max, min
 *  naturalExponential       P.naturalExponential, P.toPower
 *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,
 *                           P.toPower, naturalExponential
 *  nonFiniteToString        finiteToString, toStringBinary
 *  parseDecimal             Decimal
 *  parseOther               Decimal
 *  sin                      P.sin
 *  taylorSeries             P.cosh, P.sinh, cos, sin
 *  toLessThanHalfPi         P.cos, P.sin
 *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal
 *  truncate                 intPow
 *
 *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,
 *                           naturalLogarithm, config, parseOther, random, Decimal
 */


function digitsToString(d) {
  var i, k, ws,
    indexOfLastWord = d.length - 1,
    str = '',
    w = d[0];

  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + '';
      k = LOG_BASE - ws.length;
      if (k) str += getZeroString(k);
      str += ws;
    }

    w = d[i];
    ws = w + '';
    k = LOG_BASE - ws.length;
    if (k) str += getZeroString(k);
  } else if (w === 0) {
    return '0';
  }

  // Remove trailing zeros of last w.
  for (; w % 10 === 0;) w /= 10;

  return str + w;
}


function checkInt32(i, min, max) {
  if (i !== ~~i || i < min || i > max) {
    throw Error(invalidArgument + i);
  }
}


/*
 * Check 5 rounding digits if `repeating` is null, 4 otherwise.
 * `repeating == null` if caller is `log` or `pow`,
 * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.
 */
function checkRoundingDigits(d, i, rm, repeating) {
  var di, k, r, rd;

  // Get the length of the first word of the array d.
  for (k = d[0]; k >= 10; k /= 10) --i;

  // Is the rounding digit in the first word of d?
  if (--i < 0) {
    i += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE);
    i %= LOG_BASE;
  }

  // i is the index (0 - 6) of the rounding digit.
  // E.g. if within the word 3487563 the first rounding digit is 5,
  // then i = 4, k = 1000, rd = 3487563 % 1000 = 563
  k = mathpow(10, LOG_BASE - i);
  rd = d[di] % k | 0;

  if (repeating == null) {
    if (i < 3) {
      if (i == 0) rd = rd / 100 | 0;
      else if (i == 1) rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&
        (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||
          (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0) rd = rd / 1000 | 0;
      else if (i == 1) rd = rd / 100 | 0;
      else if (i == 2) rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k ||
      (!repeating && rm > 3) && rd + 1 == k / 2) &&
        (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
    }
  }

  return r;
}


// Convert string of `baseIn` to an array of numbers of `baseOut`.
// Eg. convertBase('255', 10, 16) returns [15, 15].
// Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
function convertBase(str, baseIn, baseOut) {
  var j,
    arr = [0],
    arrL,
    i = 0,
    strL = str.length;

  for (; i < strL;) {
    for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i++));
    for (j = 0; j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === void 0) arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }

  return arr.reverse();
}


/*
 * cos(x) = 1 - x^2/2! + x^4/4! - ...
 * |x| < pi/2
 *
 */
function cosine(Ctor, x) {
  var k, len, y;

  if (x.isZero()) return x;

  // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1
  // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1

  // Estimate the optimum number of times to use the argument reduction.
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y = '2.3283064365386962890625e-10';
  }

  Ctor.precision += k;

  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));

  // Reverse argument reduction
  for (var i = k; i--;) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }

  Ctor.precision -= k;

  return x;
}


/*
 * Perform division in the specified base.
 */
var divide = (function () {

  // Assumes non-zero x and k, and hence non-zero result.
  function multiplyInteger(x, k, base) {
    var temp,
      carry = 0,
      i = x.length;

    for (x = x.slice(); i--;) {
      temp = x[i] * k + carry;
      x[i] = temp % base | 0;
      carry = temp / base | 0;
    }

    if (carry) x.unshift(carry);

    return x;
  }

  function compare(a, b, aL, bL) {
    var i, r;

    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0; i < aL; i++) {
        if (a[i] != b[i]) {
          r = a[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }

    return r;
  }

  function subtract(a, b, aL, base) {
    var i = 0;

    // Subtract b from a.
    for (; aL--;) {
      a[aL] -= i;
      i = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i * base + a[aL] - b[aL];
    }

    // Remove leading zeros.
    for (; !a[0] && a.length > 1;) a.shift();
  }

  return function (x, y, pr, rm, dp, base) {
    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,
      yL, yz,
      Ctor = x.constructor,
      sign = x.s == y.s ? 1 : -1,
      xd = x.d,
      yd = y.d;

    // Either NaN, Infinity or 0?
    if (!xd || !xd[0] || !yd || !yd[0]) {

      return new Ctor(// Return NaN if either NaN, or both Infinity or 0.
        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :

        // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
        xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);
    }

    if (base) {
      logBase = 1;
      e = x.e - y.e;
    } else {
      base = BASE;
      logBase = LOG_BASE;
      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
    }

    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign);
    qd = q.d = [];

    // Result exponent may be one less than e.
    // The digit array of a Decimal from toStringBinary may have trailing zeros.
    for (i = 0; yd[i] == (xd[i] || 0); i++);

    if (yd[i] > (xd[i] || 0)) e--;

    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x.e - y.e) + 1;
    } else {
      sd = pr;
    }

    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {

      // Convert precision in number of base 10 digits to base 1e7 digits.
      sd = sd / logBase + 2 | 0;
      i = 0;

      // divisor < 1e7
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;

        // k is the carry.
        for (; (i < xL || k) && sd--; i++) {
          t = k * base + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k = t % yd | 0;
        }

        more = k || i < xL;

      // divisor >= 1e7
      } else {

        // Normalise xd and yd so highest order digit of yd is >= base/2
        k = base / (yd[0] + 1) | 0;

        if (k > 1) {
          yd = multiplyInteger(yd, k, base);
          xd = multiplyInteger(xd, k, base);
          yL = yd.length;
          xL = xd.length;
        }

        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;

        // Add zeros to make remainder as long as divisor.
        for (; remL < yL;) rem[remL++] = 0;

        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];

        if (yd[1] >= base / 2) ++yd0;

        do {
          k = 0;

          // Compare divisor and remainder.
          cmp = compare(yd, rem, yL, remL);

          // If divisor < remainder.
          if (cmp < 0) {

            // Calculate trial digit, k.
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

            // k will be how many times the divisor goes into the current remainder.
            k = rem0 / yd0 | 0;

            //  Algorithm:
            //  1. product = divisor * trial digit (k)
            //  2. if product > remainder: product -= divisor, k--
            //  3. remainder -= product
            //  4. if product was < remainder at 2:
            //    5. compare new remainder and divisor
            //    6. If remainder > divisor: remainder -= divisor, k++

            if (k > 1) {
              if (k >= base) k = base - 1;

              // product = divisor * trial digit.
              prod = multiplyInteger(yd, k, base);
              prodL = prod.length;
              remL = rem.length;

              // Compare product and remainder.
              cmp = compare(prod, rem, prodL, remL);

              // product > remainder.
              if (cmp == 1) {
                k--;

                // Subtract divisor from product.
                subtract(prod, yL < prodL ? yz : yd, prodL, base);
              }
            } else {

              // cmp is -1.
              // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
              // to avoid it. If k is 1 there is a need to compare yd and rem again below.
              if (k == 0) cmp = k = 1;
              prod = yd.slice();
            }

            prodL = prod.length;
            if (prodL < remL) prod.unshift(0);

            // Subtract product from remainder.
            subtract(rem, prod, remL, base);

            // If product was < previous remainder.
            if (cmp == -1) {
              remL = rem.length;

              // Compare divisor and new remainder.
              cmp = compare(yd, rem, yL, remL);

              // If divisor < new remainder, subtract divisor from remainder.
              if (cmp < 1) {
                k++;

                // Subtract divisor from remainder.
                subtract(rem, yL < remL ? yz : yd, remL, base);
              }
            }

            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }    // if cmp === 1, k will be 0

          // Add the next digit, k, to the result array.
          qd[i++] = k;

          // Update the remainder.
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }

        } while ((xi++ < xL || rem[0] !== void 0) && sd--);

        more = rem[0] !== void 0;
      }

      // Leading zero?
      if (!qd[0]) qd.shift();
    }

    // logBase is 1 when divide is being used for base conversion.
    if (logBase == 1) {
      q.e = e;
      inexact = more;
    } else {

      // To calculate q.e, first get the number of digits of qd[0].
      for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
      q.e = i + e * logBase - 1;

      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }

    return q;
  };
})();


/*
 * Round `x` to `sd` significant digits using rounding mode `rm`.
 * Check for over/under-flow.
 */
 function finalise(x, sd, rm, isTruncated) {
  var digits, i, j, k, rd, roundUp, w, xd, xdi,
    Ctor = x.constructor;

  // Don't round if sd is null or undefined.
  out: if (sd != null) {
    xd = x.d;

    // Infinity/NaN.
    if (!xd) return x;

    // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
    // w: the word of xd containing rd, a base 1e7 number.
    // xdi: the index of w within xd.
    // digits: the number of digits of w.
    // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
    // they had leading zeros)
    // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).

    // Get the length of the first word of the digits array xd.
    for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
    i = sd - digits;

    // Is the rounding digit in the first word of xd?
    if (i < 0) {
      i += LOG_BASE;
      j = sd;
      w = xd[xdi = 0];

      // Get the rounding digit at index j of w.
      rd = w / mathpow(10, digits - j - 1) % 10 | 0;
    } else {
      xdi = Math.ceil((i + 1) / LOG_BASE);
      k = xd.length;
      if (xdi >= k) {
        if (isTruncated) {

          // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.
          for (; k++ <= xdi;) xd.push(0);
          w = rd = 0;
          digits = 1;
          i %= LOG_BASE;
          j = i - LOG_BASE + 1;
        } else {
          break out;
        }
      } else {
        w = k = xd[xdi];

        // Get the number of digits of w.
        for (digits = 1; k >= 10; k /= 10) digits++;

        // Get the index of rd within w.
        i %= LOG_BASE;

        // Get the index of rd within w, adjusted for leading zeros.
        // The number of leading zeros of w is given by LOG_BASE - digits.
        j = i - LOG_BASE + digits;

        // Get the rounding digit at index j of w.
        rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
      }
    }

    // Are there any non-zero digits after the rounding digit?
    isTruncated = isTruncated || sd < 0 ||
      xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));

    // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right
    // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression
    // will give 714.

    roundUp = rm < 4
      ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
      : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&

        // Check whether the digit to the left of the rounding digit is odd.
        ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||
          rm == (x.s < 0 ? 8 : 7));

    if (sd < 1 || !xd[0]) {
      xd.length = 0;
      if (roundUp) {

        // Convert sd to decimal places.
        sd -= x.e + 1;

        // 1, 0.1, 0.01, 0.001, 0.0001 etc.
        xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
        x.e = -sd || 0;
      } else {

        // Zero.
        xd[0] = x.e = 0;
      }

      return x;
    }

    // Remove excess digits.
    if (i == 0) {
      xd.length = xdi;
      k = 1;
      xdi--;
    } else {
      xd.length = xdi + 1;
      k = mathpow(10, LOG_BASE - i);

      // E.g. 56700 becomes 56000 if 7 is the rounding digit.
      // j > 0 means i > number of leading zeros of w.
      xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
    }

    if (roundUp) {
      for (;;) {

        // Is the digit to be rounded up in the first word of xd?
        if (xdi == 0) {

          // i will be the length of xd[0] before k is added.
          for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
          j = xd[0] += k;
          for (k = 1; j >= 10; j /= 10) k++;

          // if i != k the length has increased.
          if (i != k) {
            x.e++;
            if (xd[0] == BASE) xd[0] = 1;
          }

          break;
        } else {
          xd[xdi] += k;
          if (xd[xdi] != BASE) break;
          xd[xdi--] = 0;
          k = 1;
        }
      }
    }

    // Remove trailing zeros.
    for (i = xd.length; xd[--i] === 0;) xd.pop();
  }

  if (external) {

    // Overflow?
    if (x.e > Ctor.maxE) {

      // Infinity.
      x.d = null;
      x.e = NaN;

    // Underflow?
    } else if (x.e < Ctor.minE) {

      // Zero.
      x.e = 0;
      x.d = [0];
      // Ctor.underflow = true;
    } // else Ctor.underflow = false;
  }

  return x;
}


function finiteToString(x, isExp, sd) {
  if (!x.isFinite()) return nonFiniteToString(x);
  var k,
    e = x.e,
    str = digitsToString(x.d),
    len = str.length;

  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + '.' + str.slice(1);
    }

    str = str + (x.e < 0 ? 'e' : 'e+') + x.e;
  } else if (e < 0) {
    str = '0.' + getZeroString(-e - 1) + str;
    if (sd && (k = sd - len) > 0) str += getZeroString(k);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
  } else {
    if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len) str += '.';
      str += getZeroString(k);
    }
  }

  return str;
}


// Calculate the base 10 exponent from the base 1e7 exponent.
function getBase10Exponent(digits, e) {
  var w = digits[0];

  // Add the number of digits of the first word of the digits array.
  for ( e *= LOG_BASE; w >= 10; w /= 10) e++;
  return e;
}


function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {

    // Reset global state in case the exception is caught.
    external = true;
    if (pr) Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}


function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}


function getPrecision(digits) {
  var w = digits.length - 1,
    len = w * LOG_BASE + 1;

  w = digits[w];

  // If non-zero...
  if (w) {

    // Subtract the number of trailing zeros of the last word.
    for (; w % 10 == 0; w /= 10) len--;

    // Add the number of digits of the first word.
    for (w = digits[0]; w >= 10; w /= 10) len++;
  }

  return len;
}


function getZeroString(k) {
  var zs = '';
  for (; k--;) zs += '0';
  return zs;
}


/*
 * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an
 * integer of type number.
 *
 * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.
 *
 */
function intPow(Ctor, x, n, pr) {
  var isTruncated,
    r = new Ctor(1),

    // Max n of 9007199254740991 takes 53 loop iterations.
    // Maximum digits array length; leaves [28, 34] guard digits.
    k = Math.ceil(pr / LOG_BASE + 4);

  external = false;

  for (;;) {
    if (n % 2) {
      r = r.times(x);
      if (truncate(r.d, k)) isTruncated = true;
    }

    n = mathfloor(n / 2);
    if (n === 0) {

      // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0) ++r.d[n];
      break;
    }

    x = x.times(x);
    truncate(x.d, k);
  }

  external = true;

  return r;
}


function isOdd(n) {
  return n.d[n.d.length - 1] & 1;
}


/*
 * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.
 */
function maxOrMin(Ctor, args, ltgt) {
  var y,
    x = new Ctor(args[0]),
    i = 0;

  for (; ++i < args.length;) {
    y = new Ctor(args[i]);
    if (!y.s) {
      x = y;
      break;
    } else if (x[ltgt](y)) {
      x = y;
    }
  }

  return x;
}


/*
 * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant
 * digits.
 *
 * Taylor/Maclaurin series.
 *
 * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
 *
 * Argument reduction:
 *   Repeat x = x / 32, k += 5, until |x| < 0.1
 *   exp(x) = exp(x / 2^k)^(2^k)
 *
 * Previously, the argument was initially reduced by
 * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
 * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
 * found to be slower than just dividing repeatedly by 32 as above.
 *
 * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
 * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
 * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
 *
 *  exp(Infinity)  = Infinity
 *  exp(-Infinity) = 0
 *  exp(NaN)       = NaN
 *  exp(±0)        = 1
 *
 *  exp(x) is non-terminating for any finite, non-zero x.
 *
 *  The result will always be correctly rounded.
 *
 */
function naturalExponential(x, sd) {
  var denominator, guard, j, pow, sum, t, wpr,
    rep = 0,
    i = 0,
    k = 0,
    Ctor = x.constructor,
    rm = Ctor.rounding,
    pr = Ctor.precision;

  // 0/NaN/Infinity?
  if (!x.d || !x.d[0] || x.e > 17) {

    return new Ctor(x.d
      ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0
      : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }

  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }

  t = new Ctor(0.03125);

  // while abs(x) >= 0.1
  while (x.e > -2) {

    // x = x / 2^5
    x = x.times(t);
    k += 5;
  }

  // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision
  // necessary to ensure the first 4 rounding digits are correct.
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow = sum = new Ctor(1);
  Ctor.precision = wpr;

  for (;;) {
    pow = finalise(pow.times(x), wpr, 1);
    denominator = denominator.times(++i);
    t = sum.plus(divide(pow, denominator, wpr, 1));

    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      j = k;
      while (j--) sum = finalise(sum.times(sum), wpr, 1);

      // Check to see if the first 4 rounding digits are [49]999.
      // If so, repeat the summation with a higher precision, otherwise
      // e.g. with precision: 18, rounding: 1
      // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)
      // `wpr - guard` is the index of first rounding digit.
      if (sd == null) {

        if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow = t = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise(sum, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum;
      }
    }

    sum = t;
  }
}


/*
 * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant
 * digits.
 *
 *  ln(-n)        = NaN
 *  ln(0)         = -Infinity
 *  ln(-0)        = -Infinity
 *  ln(1)         = 0
 *  ln(Infinity)  = Infinity
 *  ln(-Infinity) = NaN
 *  ln(NaN)       = NaN
 *
 *  ln(n) (n != 1) is non-terminating.
 *
 */
function naturalLogarithm(y, sd) {
  var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,
    n = 1,
    guard = 10,
    x = y,
    xd = x.d,
    Ctor = x.constructor,
    rm = Ctor.rounding,
    pr = Ctor.precision;

  // Is x negative or Infinity, NaN, 0 or 1?
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }

  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }

  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);

  if (Math.abs(e = x.e) < 1.5e15) {

    // Argument reduction.
    // The series converges faster the closer the argument is to 1, so using
    // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
    // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
    // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
    // later be divided by this number, then separate out the power of 10 using
    // ln(a*10^b) = ln(a) + b*ln(10).

    // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
    //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
    // max n is 6 (gives 0.7 - 1.3)
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }

    e = x.e;

    if (c0 > 1) {
      x = new Ctor('0.' + c);
      e++;
    } else {
      x = new Ctor(c0 + '.' + c.slice(1));
    }
  } else {

    // The argument reduction method above may result in overflow if the argument y is a massive
    // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
    // function using ln(x*10^e) = ln(x) + e*ln(10).
    t = getLn10(Ctor, wpr + 2, pr).times(e + '');
    x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;

    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }

  // x1 is x reduced to a value near 1.
  x1 = x;

  // Taylor series.
  // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
  // where x = (y - 1)/(y + 1)    (|x| < 1)
  sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;

  for (;;) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));

    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      sum = sum.times(2);

      // Reverse the argument reduction. Check that e is not 0 because, besides preventing an
      // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.
      if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
      sum = divide(sum, new Ctor(n), wpr, 1);

      // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has
      // been repeated previously) and the first 4 rounding digits 9999?
      // If so, restart the summation with a higher precision, otherwise
      // e.g. with precision: 12, rounding: 1
      // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.
      // `wpr - guard` is the index of first rounding digit.
      if (sd == null) {
        if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum;
      }
    }

    sum = t;
    denominator += 2;
  }
}


// ±Infinity, NaN.
function nonFiniteToString(x) {
  // Unsigned.
  return String(x.s * x.s / 0);
}


/*
 * Parse the value of a new Decimal `x` from string `str`.
 */
function parseDecimal(x, str) {
  var e, i, len;

  // Decimal point?
  if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

  // Exponential form?
  if ((i = str.search(/e/i)) > 0) {

    // Determine exponent.
    if (e < 0) e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {

    // Integer.
    e = str.length;
  }

  // Determine leading zeros.
  for (i = 0; str.charCodeAt(i) === 48; i++);

  // Determine trailing zeros.
  for (len = str.length; str.charCodeAt(len - 1) === 48; --len);
  str = str.slice(i, len);

  if (str) {
    len -= i;
    x.e = e = e - i - 1;
    x.d = [];

    // Transform base

    // e is the base 10 exponent.
    // i is where to slice str to get the first word of the digits array.
    i = (e + 1) % LOG_BASE;
    if (e < 0) i += LOG_BASE;

    if (i < len) {
      if (i) x.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }

    for (; i--;) str += '0';
    x.d.push(+str);

    if (external) {

      // Overflow?
      if (x.e > x.constructor.maxE) {

        // Infinity.
        x.d = null;
        x.e = NaN;

      // Underflow?
      } else if (x.e < x.constructor.minE) {

        // Zero.
        x.e = 0;
        x.d = [0];
        // x.constructor.underflow = true;
      } // else x.constructor.underflow = false;
    }
  } else {

    // Zero.
    x.e = 0;
    x.d = [0];
  }

  return x;
}


/*
 * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.
 */
function parseOther(x, str) {
  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;

  if (str.indexOf('_') > -1) {
    str = str.replace(/(\d)_(?=\d)/g, '$1');
    if (isDecimal.test(str)) return parseDecimal(x, str);
  } else if (str === 'Infinity' || str === 'NaN') {
    if (!+str) x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }

  if (isHex.test(str))  {
    base = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str))  {
    base = 2;
  } else if (isOctal.test(str))  {
    base = 8;
  } else {
    throw Error(invalidArgument + str);
  }

  // Is there a binary exponent part?
  i = str.search(/p/i);

  if (i > 0) {
    p = +str.slice(i + 1);
    str = str.substring(2, i);
  } else {
    str = str.slice(2);
  }

  // Convert `str` as an integer then divide the result by `base` raised to a power such that the
  // fraction part will be restored.
  i = str.indexOf('.');
  isFloat = i >= 0;
  Ctor = x.constructor;

  if (isFloat) {
    str = str.replace('.', '');
    len = str.length;
    i = len - i;

    // log[10](16) = 1.2041... , log[10](88) = 1.9444....
    divisor = intPow(Ctor, new Ctor(base), i, i * 2);
  }

  xd = convertBase(str, base, BASE);
  xe = xd.length - 1;

  // Remove trailing zeros.
  for (i = xe; xd[i] === 0; --i) xd.pop();
  if (i < 0) return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;

  // At what precision to perform the division to ensure exact conversion?
  // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)
  // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412
  // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.
  // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount
  // Therefore using 4 * the number of digits of str will always be enough.
  if (isFloat) x = divide(x, divisor, len * 4);

  // Multiply by the binary exponent part if present.
  if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;

  return x;
}


/*
 * sin(x) = x - x^3/3! + x^5/5! - ...
 * |x| < pi/2
 *
 */
function sine(Ctor, x) {
  var k,
    len = x.d.length;

  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
  }

  // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)
  // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)
  // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))

  // Estimate the optimum number of times to use the argument reduction.
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;

  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);

  // Reverse argument reduction
  var sin2_x,
    d5 = new Ctor(5),
    d16 = new Ctor(16),
    d20 = new Ctor(20);
  for (; k--;) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }

  return x;
}


// Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.
function taylorSeries(Ctor, n, x, y, isHyperbolic) {
  var j, t, u, x2,
    pr = Ctor.precision,
    k = Math.ceil(pr / LOG_BASE);

  external = false;
  x2 = x.times(x);
  u = new Ctor(y);

  for (;;) {
    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y);

    if (t.d[k] !== void 0) {
      for (j = k; t.d[j] === u.d[j] && j--;);
      if (j == -1) break;
    }

    j = u;
    u = y;
    y = t;
    t = j;
  }

  external = true;
  t.d.length = k + 1;

  return t;
}


// Exponent e must be positive and non-zero.
function tinyPow(b, e) {
  var n = b;
  while (--e) n *= b;
  return n;
}


// Return the absolute value of `x` reduced to less than or equal to half pi.
function toLessThanHalfPi(Ctor, x) {
  var t,
    isNeg = x.s < 0,
    pi = getPi(Ctor, Ctor.precision, 1),
    halfPi = pi.times(0.5);

  x = x.abs();

  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x;
  }

  t = x.divToInt(pi);

  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x = x.minus(t.times(pi));

    // 0 <= x < pi
    if (x.lte(halfPi)) {
      quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);
      return x;
    }

    quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);
  }

  return x.minus(pi).abs();
}


/*
 * Return the value of Decimal `x` as a string in base `baseOut`.
 *
 * If the optional `sd` argument is present include a binary exponent suffix.
 */
function toStringBinary(x, baseOut, sd, rm) {
  var base, e, i, k, len, roundUp, str, xd, y,
    Ctor = x.constructor,
    isExp = sd !== void 0;

  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }

  if (!x.isFinite()) {
    str = nonFiniteToString(x);
  } else {
    str = finiteToString(x);
    i = str.indexOf('.');

    // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:
    // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))
    // minBinaryExponent = floor(decimalExponent * log[2](10))
    // log[2](10) = 3.321928094887362347870319429489390175864

    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }

    // Convert the number as an integer then divide the result by its base raised to a power such
    // that the fraction part will be restored.

    // Non-integer.
    if (i >= 0) {
      str = str.replace('.', '');
      y = new Ctor(1);
      y.e = str.length - i;
      y.d = convertBase(finiteToString(y), 10, base);
      y.e = y.d.length;
    }

    xd = convertBase(str, 10, base);
    e = len = xd.length;

    // Remove trailing zeros.
    for (; xd[--len] == 0;) xd.pop();

    if (!xd[0]) {
      str = isExp ? '0p+0' : '0';
    } else {
      if (i < 0) {
        e--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e;
        x = divide(x, y, sd, rm, 0, base);
        xd = x.d;
        e = x.e;
        roundUp = inexact;
      }

      // The rounding digit, i.e. the digit after the digit that may be rounded up.
      i = xd[sd];
      k = base / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;

      roundUp = rm < 4
        ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))
        : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||
          rm === (x.s < 0 ? 8 : 7));

      xd.length = sd;

      if (roundUp) {

        // Rounding up may mean the previous digit has to be rounded up and so on.
        for (; ++xd[--sd] > base - 1;) {
          xd[sd] = 0;
          if (!sd) {
            ++e;
            xd.unshift(1);
          }
        }
      }

      // Determine trailing zeros.
      for (len = xd.length; !xd[len - 1]; --len);

      // E.g. [4, 11, 15] becomes 4bf.
      for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);

      // Add binary exponent suffix?
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len; len % i; len++) str += '0';
            xd = convertBase(str, base, baseOut);
            for (len = xd.length; !xd[len - 1]; --len);

            // xd[0] will always be be 1
            for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);
          } else {
            str = str.charAt(0) + '.' + str.slice(1);
          }
        }

        str =  str + (e < 0 ? 'p' : 'p+') + e;
      } else if (e < 0) {
        for (; ++e;) str = '0' + str;
        str = '0.' + str;
      } else {
        if (++e > len) for (e -= len; e-- ;) str += '0';
        else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;
  }

  return x.s < 0 ? '-' + str : str;
}


// Does not strip trailing zeros.
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}


// Decimal methods


/*
 *  abs
 *  acos
 *  acosh
 *  add
 *  asin
 *  asinh
 *  atan
 *  atanh
 *  atan2
 *  cbrt
 *  ceil
 *  clamp
 *  clone
 *  config
 *  cos
 *  cosh
 *  div
 *  exp
 *  floor
 *  hypot
 *  ln
 *  log
 *  log2
 *  log10
 *  max
 *  min
 *  mod
 *  mul
 *  pow
 *  random
 *  round
 *  set
 *  sign
 *  sin
 *  sinh
 *  sqrt
 *  sub
 *  sum
 *  tan
 *  tanh
 *  trunc
 */


/*
 * Return a new Decimal whose value is the absolute value of `x`.
 *
 * x {number|string|Decimal}
 *
 */
function abs(x) {
  return new this(x).abs();
}


/*
 * Return a new Decimal whose value is the arccosine in radians of `x`.
 *
 * x {number|string|Decimal}
 *
 */
function acos(x) {
  return new this(x).acos();
}


/*
 * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function acosh(x) {
  return new this(x).acosh();
}


/*
 * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 * y {number|string|Decimal}
 *
 */
function add$1(x, y) {
  return new this(x).plus(y);
}


/*
 * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 *
 */
function asin(x) {
  return new this(x).asin();
}


/*
 * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function asinh(x) {
  return new this(x).asinh();
}


/*
 * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 *
 */
function atan(x) {
  return new this(x).atan();
}


/*
 * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function atanh(x) {
  return new this(x).atanh();
}


/*
 * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
 * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [-pi, pi]
 *
 * y {number|string|Decimal} The y-coordinate.
 * x {number|string|Decimal} The x-coordinate.
 *
 * atan2(±0, -0)               = ±pi
 * atan2(±0, +0)               = ±0
 * atan2(±0, -x)               = ±pi for x > 0
 * atan2(±0, x)                = ±0 for x > 0
 * atan2(-y, ±0)               = -pi/2 for y > 0
 * atan2(y, ±0)                = pi/2 for y > 0
 * atan2(±y, -Infinity)        = ±pi for finite y > 0
 * atan2(±y, +Infinity)        = ±0 for finite y > 0
 * atan2(±Infinity, x)         = ±pi/2 for finite x
 * atan2(±Infinity, -Infinity) = ±3*pi/4
 * atan2(±Infinity, +Infinity) = ±pi/4
 * atan2(NaN, x) = NaN
 * atan2(y, NaN) = NaN
 *
 */
function atan2(y, x) {
  y = new this(y);
  x = new this(x);
  var r,
    pr = this.precision,
    rm = this.rounding,
    wpr = pr + 4;

  // Either NaN
  if (!y.s || !x.s) {
    r = new this(NaN);

  // Both ±Infinity
  } else if (!y.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y.s;

  // x is ±Infinity or y is ±0
  } else if (!x.d || y.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;

  // y is ±Infinity or x is ±0
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;

  // Both non-zero and finite
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }

  return r;
}


/*
 * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 *
 */
function cbrt(x) {
  return new this(x).cbrt();
}


/*
 * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.
 *
 * x {number|string|Decimal}
 *
 */
function ceil(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}


/*
 * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.
 *
 * x {number|string|Decimal}
 * min {number|string|Decimal}
 * max {number|string|Decimal}
 *
 */
function clamp(x, min, max) {
  return new this(x).clamp(min, max);
}


/*
 * Configure global settings for a Decimal constructor.
 *
 * `obj` is an object with one or more of the following properties,
 *
 *   precision  {number}
 *   rounding   {number}
 *   toExpNeg   {number}
 *   toExpPos   {number}
 *   maxE       {number}
 *   minE       {number}
 *   modulo     {number}
 *   crypto     {boolean|number}
 *   defaults   {true}
 *
 * E.g. Decimal.config({ precision: 20, rounding: 4 })
 *
 */
function config(obj) {
  if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
  var i, p, v,
    useDefaults = obj.defaults === true,
    ps = [
      'precision', 1, MAX_DIGITS,
      'rounding', 0, 8,
      'toExpNeg', -EXP_LIMIT, 0,
      'toExpPos', 0, EXP_LIMIT,
      'maxE', 0, EXP_LIMIT,
      'minE', -EXP_LIMIT, 0,
      'modulo', 0, 9
    ];

  for (i = 0; i < ps.length; i += 3) {
    if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
      else throw Error(invalidArgument + p + ': ' + v);
    }
  }

  if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != 'undefined' && crypto &&
          (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ': ' + v);
    }
  }

  return this;
}


/*
 * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function cos(x) {
  return new this(x).cos();
}


/*
 * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function cosh(x) {
  return new this(x).cosh();
}


/*
 * Create and return a Decimal constructor with the same configuration properties as this Decimal
 * constructor.
 *
 */
function clone(obj) {
  var i, p, ps;

  /*
   * The Decimal constructor and exported function.
   * Return a new Decimal instance.
   *
   * v {number|string|Decimal} A numeric value.
   *
   */
  function Decimal(v) {
    var e, i, t,
      x = this;

    // Decimal called without new.
    if (!(x instanceof Decimal)) return new Decimal(v);

    // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
    // which points to Object.
    x.constructor = Decimal;

    // Duplicate.
    if (isDecimalInstance(v)) {
      x.s = v.s;

      if (external) {
        if (!v.d || v.e > Decimal.maxE) {

          // Infinity.
          x.e = NaN;
          x.d = null;
        } else if (v.e < Decimal.minE) {

          // Zero.
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v.e;
          x.d = v.d.slice();
        }
      } else {
        x.e = v.e;
        x.d = v.d ? v.d.slice() : v.d;
      }

      return;
    }

    t = typeof v;

    if (t === 'number') {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }

      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }

      // Fast path for small integers.
      if (v === ~~v && v < 1e7) {
        for (e = 0, i = v; i >= 10; i /= 10) e++;

        if (external) {
          if (e > Decimal.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e < Decimal.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e;
            x.d = [v];
          }
        } else {
          x.e = e;
          x.d = [v];
        }

        return;

      // Infinity, NaN.
      } else if (v * 0 !== 0) {
        if (!v) x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }

      return parseDecimal(x, v.toString());

    } else if (t !== 'string') {
      throw Error(invalidArgument + v);
    }

    // Minus sign?
    if ((i = v.charCodeAt(0)) === 45) {
      v = v.slice(1);
      x.s = -1;
    } else {
      // Plus sign?
      if (i === 43) v = v.slice(1);
      x.s = 1;
    }

    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
  }

  Decimal.prototype = P;

  Decimal.ROUND_UP = 0;
  Decimal.ROUND_DOWN = 1;
  Decimal.ROUND_CEIL = 2;
  Decimal.ROUND_FLOOR = 3;
  Decimal.ROUND_HALF_UP = 4;
  Decimal.ROUND_HALF_DOWN = 5;
  Decimal.ROUND_HALF_EVEN = 6;
  Decimal.ROUND_HALF_CEIL = 7;
  Decimal.ROUND_HALF_FLOOR = 8;
  Decimal.EUCLID = 9;

  Decimal.config = Decimal.set = config;
  Decimal.clone = clone;
  Decimal.isDecimal = isDecimalInstance;

  Decimal.abs = abs;
  Decimal.acos = acos;
  Decimal.acosh = acosh;        // ES6
  Decimal.add = add$1;
  Decimal.asin = asin;
  Decimal.asinh = asinh;        // ES6
  Decimal.atan = atan;
  Decimal.atanh = atanh;        // ES6
  Decimal.atan2 = atan2;
  Decimal.cbrt = cbrt;          // ES6
  Decimal.ceil = ceil;
  Decimal.clamp = clamp;
  Decimal.cos = cos;
  Decimal.cosh = cosh;          // ES6
  Decimal.div = div;
  Decimal.exp = exp;
  Decimal.floor = floor;
  Decimal.hypot = hypot;        // ES6
  Decimal.ln = ln;
  Decimal.log = log;
  Decimal.log10 = log10;        // ES6
  Decimal.log2 = log2;          // ES6
  Decimal.max = max;
  Decimal.min = min;
  Decimal.mod = mod;
  Decimal.mul = mul$1;
  Decimal.pow = pow$1;
  Decimal.random = random;
  Decimal.round = round;
  Decimal.sign = sign;          // ES6
  Decimal.sin = sin;
  Decimal.sinh = sinh;          // ES6
  Decimal.sqrt = sqrt;
  Decimal.sub = sub;
  Decimal.sum = sum;
  Decimal.tan = tan;
  Decimal.tanh = tanh;          // ES6
  Decimal.trunc = trunc;        // ES6

  if (obj === void 0) obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];
      for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
    }
  }

  Decimal.config(obj);

  return Decimal;
}


/*
 * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 * y {number|string|Decimal}
 *
 */
function div(x, y) {
  return new this(x).div(y);
}


/*
 * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} The power to which to raise the base of the natural log.
 *
 */
function exp(x) {
  return new this(x).exp();
}


/*
 * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.
 *
 * x {number|string|Decimal}
 *
 */
function floor(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}


/*
 * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,
 * rounded to `precision` significant digits using rounding mode `rounding`.
 *
 * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)
 *
 * arguments {number|string|Decimal}
 *
 */
function hypot() {
  var i, n,
    t = new this(0);

  external = false;

  for (i = 0; i < arguments.length;) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }

  external = true;

  return t.sqrt();
}


/*
 * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),
 * otherwise return false.
 *
 */
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}


/*
 * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 *
 */
function ln(x) {
  return new this(x).ln();
}


/*
 * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base
 * is specified, rounded to `precision` significant digits using rounding mode `rounding`.
 *
 * log[y](x)
 *
 * x {number|string|Decimal} The argument of the logarithm.
 * y {number|string|Decimal} The base of the logarithm.
 *
 */
function log(x, y) {
  return new this(x).log(y);
}


/*
 * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 *
 */
function log2(x) {
  return new this(x).log(2);
}


/*
 * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 *
 */
function log10(x) {
  return new this(x).log(10);
}


/*
 * Return a new Decimal whose value is the maximum of the arguments.
 *
 * arguments {number|string|Decimal}
 *
 */
function max() {
  return maxOrMin(this, arguments, 'lt');
}


/*
 * Return a new Decimal whose value is the minimum of the arguments.
 *
 * arguments {number|string|Decimal}
 *
 */
function min() {
  return maxOrMin(this, arguments, 'gt');
}


/*
 * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits
 * using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 * y {number|string|Decimal}
 *
 */
function mod(x, y) {
  return new this(x).mod(y);
}


/*
 * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 * y {number|string|Decimal}
 *
 */
function mul$1(x, y) {
  return new this(x).mul(y);
}


/*
 * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} The base.
 * y {number|string|Decimal} The exponent.
 *
 */
function pow$1(x, y) {
  return new this(x).pow(y);
}


/*
 * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with
 * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros
 * are produced).
 *
 * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.
 *
 */
function random(sd) {
  var d, e, k, n,
    i = 0,
    r = new this(1),
    rd = [];

  if (sd === void 0) sd = this.precision;
  else checkInt32(sd, 1, MAX_DIGITS);

  k = Math.ceil(sd / LOG_BASE);

  if (!this.crypto) {
    for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;

  // Browsers supporting crypto.getRandomValues.
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));

    for (; i < k;) {
      n = d[i];

      // 0 <= n < 4294967296
      // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).
      if (n >= 4.29e9) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {

        // 0 <= n <= 4289999999
        // 0 <= (n % 1e7) <= 9999999
        rd[i++] = n % 1e7;
      }
    }

  // Node.js supporting crypto.randomBytes.
  } else if (crypto.randomBytes) {

    // buffer
    d = crypto.randomBytes(k *= 4);

    for (; i < k;) {

      // 0 <= n < 2147483648
      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);

      // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).
      if (n >= 2.14e9) {
        crypto.randomBytes(4).copy(d, i);
      } else {

        // 0 <= n <= 2139999999
        // 0 <= (n % 1e7) <= 9999999
        rd.push(n % 1e7);
        i += 4;
      }
    }

    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }

  k = rd[--i];
  sd %= LOG_BASE;

  // Convert trailing digits to zeros according to sd.
  if (k && sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i] = (k / n | 0) * n;
  }

  // Remove trailing words which are zero.
  for (; rd[i] === 0; i--) rd.pop();

  // Zero?
  if (i < 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;

    // Remove leading words which are zero and adjust exponent accordingly.
    for (; rd[0] === 0; e -= LOG_BASE) rd.shift();

    // Count the digits of the first word of rd to determine leading zeros.
    for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;

    // Adjust the exponent for leading zeros of the first word of rd.
    if (k < LOG_BASE) e -= LOG_BASE - k;
  }

  r.e = e;
  r.d = rd;

  return r;
}


/*
 * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.
 *
 * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).
 *
 * x {number|string|Decimal}
 *
 */
function round(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}


/*
 * Return
 *   1    if x > 0,
 *  -1    if x < 0,
 *   0    if x is 0,
 *  -0    if x is -0,
 *   NaN  otherwise
 *
 * x {number|string|Decimal}
 *
 */
function sign(x) {
  x = new this(x);
  return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;
}


/*
 * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits
 * using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function sin(x) {
  return new this(x).sin();
}


/*
 * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function sinh(x) {
  return new this(x).sinh();
}


/*
 * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 *
 */
function sqrt(x) {
  return new this(x).sqrt();
}


/*
 * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits
 * using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 * y {number|string|Decimal}
 *
 */
function sub(x, y) {
  return new this(x).sub(y);
}


/*
 * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * Only the result is rounded, not the intermediate calculations.
 *
 * arguments {number|string|Decimal}
 *
 */
function sum() {
  var i = 0,
    args = arguments,
    x = new this(args[i]);

  external = false;
  for (; x.s && ++i < args.length;) x = x.plus(args[i]);
  external = true;

  return finalise(x, this.precision, this.rounding);
}


/*
 * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function tan(x) {
  return new this(x).tan();
}


/*
 * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function tanh(x) {
  return new this(x).tanh();
}


/*
 * Return a new Decimal whose value is `x` truncated to an integer.
 *
 * x {number|string|Decimal}
 *
 */
function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}


P[Symbol.for('nodejs.util.inspect.custom')] = P.toString;
P[Symbol.toStringTag] = 'Decimal';

// Create and configure initial Decimal constructor.
var Decimal = P.constructor = clone(DEFAULTS);

// Create the internal constants from their string values.
LN10 = new Decimal(LN10);
PI = new Decimal(PI);

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var complex = {exports: {}};

/**
 * @license Complex.js v2.1.1 12/05/2020
 *
 * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/

(function (module, exports) {
	/**
	 *
	 * This class allows the manipulation of complex numbers.
	 * You can pass a complex number in different formats. Either as object, double, string or two integer parameters.
	 *
	 * Object form
	 * { re: <real>, im: <imaginary> }
	 * { arg: <angle>, abs: <radius> }
	 * { phi: <angle>, r: <radius> }
	 *
	 * Array / Vector form
	 * [ real, imaginary ]
	 *
	 * Double form
	 * 99.3 - Single double value
	 *
	 * String form
	 * '23.1337' - Simple real number
	 * '15+3i' - a simple complex number
	 * '3-i' - a simple complex number
	 *
	 * Example:
	 *
	 * var c = new Complex('99.3+8i');
	 * c.mul({r: 3, i: 9}).div(4.9).sub(3, 2);
	 *
	 */

	(function(root) {

	  var cosh = Math.cosh || function(x) {
	    return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
	  };

	  var sinh = Math.sinh || function(x) {
	    return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
	  };

	  /**
	   * Calculates cos(x) - 1 using Taylor series if x is small (-¼π ≤ x ≤ ¼π).
	   *
	   * @param {number} x
	   * @returns {number} cos(x) - 1
	   */
	  var cosm1 = function(x) {

	    var b = Math.PI / 4;
	    if (-b > x || x > b) {
	      return Math.cos(x) - 1.0;
	    }

	    /* Calculate horner form of polynomial of taylor series in Q
	    var fac = 1, alt = 1, pol = {};
	    for (var i = 0; i <= 16; i++) {
	      fac*= i || 1;
	      if (i % 2 == 0) {
	        pol[i] = new Fraction(1, alt * fac);
	        alt = -alt;
	      }
	    }
	    console.log(new Polynomial(pol).toHorner()); // (((((((1/20922789888000x^2-1/87178291200)x^2+1/479001600)x^2-1/3628800)x^2+1/40320)x^2-1/720)x^2+1/24)x^2-1/2)x^2+1
	    */

	    var xx = x * x;
	    return xx * (
	      xx * (
	        xx * (
	          xx * (
	            xx * (
	              xx * (
	                xx * (
	                  xx / 20922789888000
	                  - 1 / 87178291200)
	                + 1 / 479001600)
	              - 1 / 3628800)
	            + 1 / 40320)
	          - 1 / 720)
	        + 1 / 24)
	      - 1 / 2);
	  };

	  var hypot = function(x, y) {

	    var a = Math.abs(x);
	    var b = Math.abs(y);

	    if (a < 3000 && b < 3000) {
	      return Math.sqrt(a * a + b * b);
	    }

	    if (a < b) {
	      a = b;
	      b = x / y;
	    } else {
	      b = y / x;
	    }
	    return a * Math.sqrt(1 + b * b);
	  };

	  var parser_exit = function() {
	    throw SyntaxError('Invalid Param');
	  };

	  /**
	   * Calculates log(sqrt(a^2+b^2)) in a way to avoid overflows
	   *
	   * @param {number} a
	   * @param {number} b
	   * @returns {number}
	   */
	  function logHypot(a, b) {

	    var _a = Math.abs(a);
	    var _b = Math.abs(b);

	    if (a === 0) {
	      return Math.log(_b);
	    }

	    if (b === 0) {
	      return Math.log(_a);
	    }

	    if (_a < 3000 && _b < 3000) {
	      return Math.log(a * a + b * b) * 0.5;
	    }

	    /* I got 4 ideas to compute this property without overflow:
	     *
	     * Testing 1000000 times with random samples for a,b ∈ [1, 1000000000] against a big decimal library to get an error estimate
	     *
	     * 1. Only eliminate the square root: (OVERALL ERROR: 3.9122483030951116e-11)

	     Math.log(a * a + b * b) / 2

	     *
	     *
	     * 2. Try to use the non-overflowing pythagoras: (OVERALL ERROR: 8.889760039210159e-10)

	     var fn = function(a, b) {
	     a = Math.abs(a);
	     b = Math.abs(b);
	     var t = Math.min(a, b);
	     a = Math.max(a, b);
	     t = t / a;

	     return Math.log(a) + Math.log(1 + t * t) / 2;
	     };

	     * 3. Abuse the identity cos(atan(y/x) = x / sqrt(x^2+y^2): (OVERALL ERROR: 3.4780178737037204e-10)

	     Math.log(a / Math.cos(Math.atan2(b, a)))

	     * 4. Use 3. and apply log rules: (OVERALL ERROR: 1.2014087502620896e-9)

	     Math.log(a) - Math.log(Math.cos(Math.atan2(b, a)))

	     */

	     a = a / 2;
	     b = b / 2;

	    return 0.5 * Math.log(a * a + b * b) + Math.LN2;
	  }

	  var parse = function(a, b) {

	    var z = { 're': 0, 'im': 0 };

	    if (a === undefined || a === null) {
	      z['re'] =
	      z['im'] = 0;
	    } else if (b !== undefined) {
	      z['re'] = a;
	      z['im'] = b;
	    } else
	      switch (typeof a) {

	        case 'object':

	          if ('im' in a && 're' in a) {
	            z['re'] = a['re'];
	            z['im'] = a['im'];
	          } else if ('abs' in a && 'arg' in a) {
	            if (!Number.isFinite(a['abs']) && Number.isFinite(a['arg'])) {
	              return Complex['INFINITY'];
	            }
	            z['re'] = a['abs'] * Math.cos(a['arg']);
	            z['im'] = a['abs'] * Math.sin(a['arg']);
	          } else if ('r' in a && 'phi' in a) {
	            if (!Number.isFinite(a['r']) && Number.isFinite(a['phi'])) {
	              return Complex['INFINITY'];
	            }
	            z['re'] = a['r'] * Math.cos(a['phi']);
	            z['im'] = a['r'] * Math.sin(a['phi']);
	          } else if (a.length === 2) { // Quick array check
	            z['re'] = a[0];
	            z['im'] = a[1];
	          } else {
	            parser_exit();
	          }
	          break;

	        case 'string':

	          z['im'] = /* void */
	          z['re'] = 0;

	          var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
	          var plus = 1;
	          var minus = 0;

	          if (tokens === null) {
	            parser_exit();
	          }

	          for (var i = 0; i < tokens.length; i++) {

	            var c = tokens[i];

	            if (c === ' ' || c === '\t' || c === '\n') ; else if (c === '+') {
	              plus++;
	            } else if (c === '-') {
	              minus++;
	            } else if (c === 'i' || c === 'I') {

	              if (plus + minus === 0) {
	                parser_exit();
	              }

	              if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) {
	                z['im'] += parseFloat((minus % 2 ? '-' : '') + tokens[i + 1]);
	                i++;
	              } else {
	                z['im'] += parseFloat((minus % 2 ? '-' : '') + '1');
	              }
	              plus = minus = 0;

	            } else {

	              if (plus + minus === 0 || isNaN(c)) {
	                parser_exit();
	              }

	              if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') {
	                z['im'] += parseFloat((minus % 2 ? '-' : '') + c);
	                i++;
	              } else {
	                z['re'] += parseFloat((minus % 2 ? '-' : '') + c);
	              }
	              plus = minus = 0;
	            }
	          }

	          // Still something on the stack
	          if (plus + minus > 0) {
	            parser_exit();
	          }
	          break;

	        case 'number':
	          z['im'] = 0;
	          z['re'] = a;
	          break;

	        default:
	          parser_exit();
	      }

	    if (isNaN(z['re']) || isNaN(z['im'])) ;

	    return z;
	  };

	  /**
	   * @constructor
	   * @returns {Complex}
	   */
	  function Complex(a, b) {

	    if (!(this instanceof Complex)) {
	      return new Complex(a, b);
	    }

	    var z = parse(a, b);

	    this['re'] = z['re'];
	    this['im'] = z['im'];
	  }

	  Complex.prototype = {

	    're': 0,
	    'im': 0,

	    /**
	     * Calculates the sign of a complex number, which is a normalized complex
	     *
	     * @returns {Complex}
	     */
	    'sign': function() {

	      var abs = this['abs']();

	      return new Complex(
	        this['re'] / abs,
	        this['im'] / abs);
	    },

	    /**
	     * Adds two complex numbers
	     *
	     * @returns {Complex}
	     */
	    'add': function(a, b) {

	      var z = new Complex(a, b);

	      // Infinity + Infinity = NaN
	      if (this['isInfinite']() && z['isInfinite']()) {
	        return Complex['NAN'];
	      }

	      // Infinity + z = Infinity { where z != Infinity }
	      if (this['isInfinite']() || z['isInfinite']()) {
	        return Complex['INFINITY'];
	      }

	      return new Complex(
	        this['re'] + z['re'],
	        this['im'] + z['im']);
	    },

	    /**
	     * Subtracts two complex numbers
	     *
	     * @returns {Complex}
	     */
	    'sub': function(a, b) {

	      var z = new Complex(a, b);

	      // Infinity - Infinity = NaN
	      if (this['isInfinite']() && z['isInfinite']()) {
	        return Complex['NAN'];
	      }

	      // Infinity - z = Infinity { where z != Infinity }
	      if (this['isInfinite']() || z['isInfinite']()) {
	        return Complex['INFINITY'];
	      }

	      return new Complex(
	        this['re'] - z['re'],
	        this['im'] - z['im']);
	    },

	    /**
	     * Multiplies two complex numbers
	     *
	     * @returns {Complex}
	     */
	    'mul': function(a, b) {

	      var z = new Complex(a, b);

	      // Infinity * 0 = NaN
	      if ((this['isInfinite']() && z['isZero']()) || (this['isZero']() && z['isInfinite']())) {
	        return Complex['NAN'];
	      }

	      // Infinity * z = Infinity { where z != 0 }
	      if (this['isInfinite']() || z['isInfinite']()) {
	        return Complex['INFINITY'];
	      }

	      // Short circuit for real values
	      if (z['im'] === 0 && this['im'] === 0) {
	        return new Complex(this['re'] * z['re'], 0);
	      }

	      return new Complex(
	        this['re'] * z['re'] - this['im'] * z['im'],
	        this['re'] * z['im'] + this['im'] * z['re']);
	    },

	    /**
	     * Divides two complex numbers
	     *
	     * @returns {Complex}
	     */
	    'div': function(a, b) {

	      var z = new Complex(a, b);

	      // 0 / 0 = NaN and Infinity / Infinity = NaN
	      if ((this['isZero']() && z['isZero']()) || (this['isInfinite']() && z['isInfinite']())) {
	        return Complex['NAN'];
	      }

	      // Infinity / 0 = Infinity
	      if (this['isInfinite']() || z['isZero']()) {
	        return Complex['INFINITY'];
	      }

	      // 0 / Infinity = 0
	      if (this['isZero']() || z['isInfinite']()) {
	        return Complex['ZERO'];
	      }

	      a = this['re'];
	      b = this['im'];

	      var c = z['re'];
	      var d = z['im'];
	      var t, x;

	      if (0 === d) {
	        // Divisor is real
	        return new Complex(a / c, b / c);
	      }

	      if (Math.abs(c) < Math.abs(d)) {

	        x = c / d;
	        t = c * x + d;

	        return new Complex(
	          (a * x + b) / t,
	          (b * x - a) / t);

	      } else {

	        x = d / c;
	        t = d * x + c;

	        return new Complex(
	          (a + b * x) / t,
	          (b - a * x) / t);
	      }
	    },

	    /**
	     * Calculate the power of two complex numbers
	     *
	     * @returns {Complex}
	     */
	    'pow': function(a, b) {

	      var z = new Complex(a, b);

	      a = this['re'];
	      b = this['im'];

	      if (z['isZero']()) {
	        return Complex['ONE'];
	      }

	      // If the exponent is real
	      if (z['im'] === 0) {

	        if (b === 0 && a > 0) {

	          return new Complex(Math.pow(a, z['re']), 0);

	        } else if (a === 0) { // If base is fully imaginary

	          switch ((z['re'] % 4 + 4) % 4) {
	            case 0:
	              return new Complex(Math.pow(b, z['re']), 0);
	            case 1:
	              return new Complex(0, Math.pow(b, z['re']));
	            case 2:
	              return new Complex(-Math.pow(b, z['re']), 0);
	            case 3:
	              return new Complex(0, -Math.pow(b, z['re']));
	          }
	        }
	      }

	      /* I couldn't find a good formula, so here is a derivation and optimization
	       *
	       * z_1^z_2 = (a + bi)^(c + di)
	       *         = exp((c + di) * log(a + bi)
	       *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))
	       * =>...
	       * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
	       * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
	       *
	       * =>...
	       * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
	       * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
	       *
	       * =>
	       * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))
	       * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))
	       *
	       */

	      if (a === 0 && b === 0 && z['re'] > 0 && z['im'] >= 0) {
	        return Complex['ZERO'];
	      }

	      var arg = Math.atan2(b, a);
	      var loh = logHypot(a, b);

	      a = Math.exp(z['re'] * loh - z['im'] * arg);
	      b = z['im'] * loh + z['re'] * arg;
	      return new Complex(
	        a * Math.cos(b),
	        a * Math.sin(b));
	    },

	    /**
	     * Calculate the complex square root
	     *
	     * @returns {Complex}
	     */
	    'sqrt': function() {

	      var a = this['re'];
	      var b = this['im'];
	      var r = this['abs']();

	      var re, im;

	      if (a >= 0) {

	        if (b === 0) {
	          return new Complex(Math.sqrt(a), 0);
	        }

	        re = 0.5 * Math.sqrt(2.0 * (r + a));
	      } else {
	        re = Math.abs(b) / Math.sqrt(2 * (r - a));
	      }

	      if (a <= 0) {
	        im = 0.5 * Math.sqrt(2.0 * (r - a));
	      } else {
	        im = Math.abs(b) / Math.sqrt(2 * (r + a));
	      }

	      return new Complex(re, b < 0 ? -im : im);
	    },

	    /**
	     * Calculate the complex exponent
	     *
	     * @returns {Complex}
	     */
	    'exp': function() {

	      var tmp = Math.exp(this['re']);

	      if (this['im'] === 0) ;
	      return new Complex(
	        tmp * Math.cos(this['im']),
	        tmp * Math.sin(this['im']));
	    },

	    /**
	     * Calculate the complex exponent and subtracts one.
	     *
	     * This may be more accurate than `Complex(x).exp().sub(1)` if
	     * `x` is small.
	     *
	     * @returns {Complex}
	     */
	    'expm1': function() {

	      /**
	       * exp(a + i*b) - 1
	       = exp(a) * (cos(b) + j*sin(b)) - 1
	       = expm1(a)*cos(b) + cosm1(b) + j*exp(a)*sin(b)
	       */

	      var a = this['re'];
	      var b = this['im'];

	      return new Complex(
	        Math.expm1(a) * Math.cos(b) + cosm1(b),
	        Math.exp(a) * Math.sin(b));
	    },

	    /**
	     * Calculate the natural log
	     *
	     * @returns {Complex}
	     */
	    'log': function() {

	      var a = this['re'];
	      var b = this['im'];

	      return new Complex(
	        logHypot(a, b),
	        Math.atan2(b, a));
	    },

	    /**
	     * Calculate the magnitude of the complex number
	     *
	     * @returns {number}
	     */
	    'abs': function() {

	      return hypot(this['re'], this['im']);
	    },

	    /**
	     * Calculate the angle of the complex number
	     *
	     * @returns {number}
	     */
	    'arg': function() {

	      return Math.atan2(this['im'], this['re']);
	    },

	    /**
	     * Calculate the sine of the complex number
	     *
	     * @returns {Complex}
	     */
	    'sin': function() {

	      // sin(z) = ( e^iz - e^-iz ) / 2i 
	      //        = sin(a)cosh(b) + i cos(a)sinh(b)

	      var a = this['re'];
	      var b = this['im'];

	      return new Complex(
	        Math.sin(a) * cosh(b),
	        Math.cos(a) * sinh(b));
	    },

	    /**
	     * Calculate the cosine
	     *
	     * @returns {Complex}
	     */
	    'cos': function() {

	      // cos(z) = ( e^iz + e^-iz ) / 2 
	      //        = cos(a)cosh(b) - i sin(a)sinh(b)

	      var a = this['re'];
	      var b = this['im'];

	      return new Complex(
	        Math.cos(a) * cosh(b),
	        -Math.sin(a) * sinh(b));
	    },

	    /**
	     * Calculate the tangent
	     *
	     * @returns {Complex}
	     */
	    'tan': function() {

	      // tan(z) = sin(z) / cos(z) 
	      //        = ( e^iz - e^-iz ) / ( i( e^iz + e^-iz ) )
	      //        = ( e^2iz - 1 ) / i( e^2iz + 1 )
	      //        = ( sin(2a) + i sinh(2b) ) / ( cos(2a) + cosh(2b) )

	      var a = 2 * this['re'];
	      var b = 2 * this['im'];
	      var d = Math.cos(a) + cosh(b);

	      return new Complex(
	        Math.sin(a) / d,
	        sinh(b) / d);
	    },

	    /**
	     * Calculate the cotangent
	     *
	     * @returns {Complex}
	     */
	    'cot': function() {

	      // cot(c) = i(e^(ci) + e^(-ci)) / (e^(ci) - e^(-ci))

	      var a = 2 * this['re'];
	      var b = 2 * this['im'];
	      var d = Math.cos(a) - cosh(b);

	      return new Complex(
	        -Math.sin(a) / d,
	        sinh(b) / d);
	    },

	    /**
	     * Calculate the secant
	     *
	     * @returns {Complex}
	     */
	    'sec': function() {

	      // sec(c) = 2 / (e^(ci) + e^(-ci))

	      var a = this['re'];
	      var b = this['im'];
	      var d = 0.5 * cosh(2 * b) + 0.5 * Math.cos(2 * a);

	      return new Complex(
	        Math.cos(a) * cosh(b) / d,
	        Math.sin(a) * sinh(b) / d);
	    },

	    /**
	     * Calculate the cosecans
	     *
	     * @returns {Complex}
	     */
	    'csc': function() {

	      // csc(c) = 2i / (e^(ci) - e^(-ci))

	      var a = this['re'];
	      var b = this['im'];
	      var d = 0.5 * cosh(2 * b) - 0.5 * Math.cos(2 * a);

	      return new Complex(
	        Math.sin(a) * cosh(b) / d,
	        -Math.cos(a) * sinh(b) / d);
	    },

	    /**
	     * Calculate the complex arcus sinus
	     *
	     * @returns {Complex}
	     */
	    'asin': function() {

	      // asin(c) = -i * log(ci + sqrt(1 - c^2))

	      var a = this['re'];
	      var b = this['im'];

	      var t1 = new Complex(
	        b * b - a * a + 1,
	        -2 * a * b)['sqrt']();

	      var t2 = new Complex(
	        t1['re'] - b,
	        t1['im'] + a)['log']();

	      return new Complex(t2['im'], -t2['re']);
	    },

	    /**
	     * Calculate the complex arcus cosinus
	     *
	     * @returns {Complex}
	     */
	    'acos': function() {

	      // acos(c) = i * log(c - i * sqrt(1 - c^2))

	      var a = this['re'];
	      var b = this['im'];

	      var t1 = new Complex(
	        b * b - a * a + 1,
	        -2 * a * b)['sqrt']();

	      var t2 = new Complex(
	        t1['re'] - b,
	        t1['im'] + a)['log']();

	      return new Complex(Math.PI / 2 - t2['im'], t2['re']);
	    },

	    /**
	     * Calculate the complex arcus tangent
	     *
	     * @returns {Complex}
	     */
	    'atan': function() {

	      // atan(c) = i / 2 log((i + x) / (i - x))

	      var a = this['re'];
	      var b = this['im'];

	      if (a === 0) {

	        if (b === 1) {
	          return new Complex(0, Infinity);
	        }

	        if (b === -1) {
	          return new Complex(0, -Infinity);
	        }
	      }

	      var d = a * a + (1.0 - b) * (1.0 - b);

	      var t1 = new Complex(
	        (1 - b * b - a * a) / d,
	        -2 * a / d).log();

	      return new Complex(-0.5 * t1['im'], 0.5 * t1['re']);
	    },

	    /**
	     * Calculate the complex arcus cotangent
	     *
	     * @returns {Complex}
	     */
	    'acot': function() {

	      // acot(c) = i / 2 log((c - i) / (c + i))

	      var a = this['re'];
	      var b = this['im'];

	      if (b === 0) {
	        return new Complex(Math.atan2(1, a), 0);
	      }

	      var d = a * a + b * b;
	      return (d !== 0)
	        ? new Complex(
	          a / d,
	          -b / d).atan()
	        : new Complex(
	          (a !== 0) ? a / 0 : 0,
	          (b !== 0) ? -b / 0 : 0).atan();
	    },

	    /**
	     * Calculate the complex arcus secant
	     *
	     * @returns {Complex}
	     */
	    'asec': function() {

	      // asec(c) = -i * log(1 / c + sqrt(1 - i / c^2))

	      var a = this['re'];
	      var b = this['im'];

	      if (a === 0 && b === 0) {
	        return new Complex(0, Infinity);
	      }

	      var d = a * a + b * b;
	      return (d !== 0)
	        ? new Complex(
	          a / d,
	          -b / d).acos()
	        : new Complex(
	          (a !== 0) ? a / 0 : 0,
	          (b !== 0) ? -b / 0 : 0).acos();
	    },

	    /**
	     * Calculate the complex arcus cosecans
	     *
	     * @returns {Complex}
	     */
	    'acsc': function() {

	      // acsc(c) = -i * log(i / c + sqrt(1 - 1 / c^2))

	      var a = this['re'];
	      var b = this['im'];

	      if (a === 0 && b === 0) {
	        return new Complex(Math.PI / 2, Infinity);
	      }

	      var d = a * a + b * b;
	      return (d !== 0)
	        ? new Complex(
	          a / d,
	          -b / d).asin()
	        : new Complex(
	          (a !== 0) ? a / 0 : 0,
	          (b !== 0) ? -b / 0 : 0).asin();
	    },

	    /**
	     * Calculate the complex sinh
	     *
	     * @returns {Complex}
	     */
	    'sinh': function() {

	      // sinh(c) = (e^c - e^-c) / 2

	      var a = this['re'];
	      var b = this['im'];

	      return new Complex(
	        sinh(a) * Math.cos(b),
	        cosh(a) * Math.sin(b));
	    },

	    /**
	     * Calculate the complex cosh
	     *
	     * @returns {Complex}
	     */
	    'cosh': function() {

	      // cosh(c) = (e^c + e^-c) / 2

	      var a = this['re'];
	      var b = this['im'];

	      return new Complex(
	        cosh(a) * Math.cos(b),
	        sinh(a) * Math.sin(b));
	    },

	    /**
	     * Calculate the complex tanh
	     *
	     * @returns {Complex}
	     */
	    'tanh': function() {

	      // tanh(c) = (e^c - e^-c) / (e^c + e^-c)

	      var a = 2 * this['re'];
	      var b = 2 * this['im'];
	      var d = cosh(a) + Math.cos(b);

	      return new Complex(
	        sinh(a) / d,
	        Math.sin(b) / d);
	    },

	    /**
	     * Calculate the complex coth
	     *
	     * @returns {Complex}
	     */
	    'coth': function() {

	      // coth(c) = (e^c + e^-c) / (e^c - e^-c)

	      var a = 2 * this['re'];
	      var b = 2 * this['im'];
	      var d = cosh(a) - Math.cos(b);

	      return new Complex(
	        sinh(a) / d,
	        -Math.sin(b) / d);
	    },

	    /**
	     * Calculate the complex coth
	     *
	     * @returns {Complex}
	     */
	    'csch': function() {

	      // csch(c) = 2 / (e^c - e^-c)

	      var a = this['re'];
	      var b = this['im'];
	      var d = Math.cos(2 * b) - cosh(2 * a);

	      return new Complex(
	        -2 * sinh(a) * Math.cos(b) / d,
	        2 * cosh(a) * Math.sin(b) / d);
	    },

	    /**
	     * Calculate the complex sech
	     *
	     * @returns {Complex}
	     */
	    'sech': function() {

	      // sech(c) = 2 / (e^c + e^-c)

	      var a = this['re'];
	      var b = this['im'];
	      var d = Math.cos(2 * b) + cosh(2 * a);

	      return new Complex(
	        2 * cosh(a) * Math.cos(b) / d,
	        -2 * sinh(a) * Math.sin(b) / d);
	    },

	    /**
	     * Calculate the complex asinh
	     *
	     * @returns {Complex}
	     */
	    'asinh': function() {

	      // asinh(c) = log(c + sqrt(c^2 + 1))

	      var tmp = this['im'];
	      this['im'] = -this['re'];
	      this['re'] = tmp;
	      var res = this['asin']();

	      this['re'] = -this['im'];
	      this['im'] = tmp;
	      tmp = res['re'];

	      res['re'] = -res['im'];
	      res['im'] = tmp;
	      return res;
	    },

	    /**
	     * Calculate the complex acosh
	     *
	     * @returns {Complex}
	     */
	    'acosh': function() {

	      // acosh(c) = log(c + sqrt(c^2 - 1))

	      var res = this['acos']();
	      if (res['im'] <= 0) {
	        var tmp = res['re'];
	        res['re'] = -res['im'];
	        res['im'] = tmp;
	      } else {
	        var tmp = res['im'];
	        res['im'] = -res['re'];
	        res['re'] = tmp;
	      }
	      return res;
	    },

	    /**
	     * Calculate the complex atanh
	     *
	     * @returns {Complex}
	     */
	    'atanh': function() {

	      // atanh(c) = log((1+c) / (1-c)) / 2

	      var a = this['re'];
	      var b = this['im'];

	      var noIM = a > 1 && b === 0;
	      var oneMinus = 1 - a;
	      var onePlus = 1 + a;
	      var d = oneMinus * oneMinus + b * b;

	      var x = (d !== 0)
	        ? new Complex(
	          (onePlus * oneMinus - b * b) / d,
	          (b * oneMinus + onePlus * b) / d)
	        : new Complex(
	          (a !== -1) ? (a / 0) : 0,
	          (b !== 0) ? (b / 0) : 0);

	      var temp = x['re'];
	      x['re'] = logHypot(x['re'], x['im']) / 2;
	      x['im'] = Math.atan2(x['im'], temp) / 2;
	      if (noIM) {
	        x['im'] = -x['im'];
	      }
	      return x;
	    },

	    /**
	     * Calculate the complex acoth
	     *
	     * @returns {Complex}
	     */
	    'acoth': function() {

	      // acoth(c) = log((c+1) / (c-1)) / 2

	      var a = this['re'];
	      var b = this['im'];

	      if (a === 0 && b === 0) {
	        return new Complex(0, Math.PI / 2);
	      }

	      var d = a * a + b * b;
	      return (d !== 0)
	        ? new Complex(
	          a / d,
	          -b / d).atanh()
	        : new Complex(
	          (a !== 0) ? a / 0 : 0,
	          (b !== 0) ? -b / 0 : 0).atanh();
	    },

	    /**
	     * Calculate the complex acsch
	     *
	     * @returns {Complex}
	     */
	    'acsch': function() {

	      // acsch(c) = log((1+sqrt(1+c^2))/c)

	      var a = this['re'];
	      var b = this['im'];

	      if (b === 0) {

	        return new Complex(
	          (a !== 0)
	            ? Math.log(a + Math.sqrt(a * a + 1))
	            : Infinity, 0);
	      }

	      var d = a * a + b * b;
	      return (d !== 0)
	        ? new Complex(
	          a / d,
	          -b / d).asinh()
	        : new Complex(
	          (a !== 0) ? a / 0 : 0,
	          (b !== 0) ? -b / 0 : 0).asinh();
	    },

	    /**
	     * Calculate the complex asech
	     *
	     * @returns {Complex}
	     */
	    'asech': function() {

	      // asech(c) = log((1+sqrt(1-c^2))/c)

	      var a = this['re'];
	      var b = this['im'];

	      if (this['isZero']()) {
	        return Complex['INFINITY'];
	      }

	      var d = a * a + b * b;
	      return (d !== 0)
	        ? new Complex(
	          a / d,
	          -b / d).acosh()
	        : new Complex(
	          (a !== 0) ? a / 0 : 0,
	          (b !== 0) ? -b / 0 : 0).acosh();
	    },

	    /**
	     * Calculate the complex inverse 1/z
	     *
	     * @returns {Complex}
	     */
	    'inverse': function() {

	      // 1 / 0 = Infinity and 1 / Infinity = 0
	      if (this['isZero']()) {
	        return Complex['INFINITY'];
	      }

	      if (this['isInfinite']()) {
	        return Complex['ZERO'];
	      }

	      var a = this['re'];
	      var b = this['im'];

	      var d = a * a + b * b;

	      return new Complex(a / d, -b / d);
	    },

	    /**
	     * Returns the complex conjugate
	     *
	     * @returns {Complex}
	     */
	    'conjugate': function() {

	      return new Complex(this['re'], -this['im']);
	    },

	    /**
	     * Gets the negated complex number
	     *
	     * @returns {Complex}
	     */
	    'neg': function() {

	      return new Complex(-this['re'], -this['im']);
	    },

	    /**
	     * Ceils the actual complex number
	     *
	     * @returns {Complex}
	     */
	    'ceil': function(places) {

	      places = Math.pow(10, places || 0);

	      return new Complex(
	        Math.ceil(this['re'] * places) / places,
	        Math.ceil(this['im'] * places) / places);
	    },

	    /**
	     * Floors the actual complex number
	     *
	     * @returns {Complex}
	     */
	    'floor': function(places) {

	      places = Math.pow(10, places || 0);

	      return new Complex(
	        Math.floor(this['re'] * places) / places,
	        Math.floor(this['im'] * places) / places);
	    },

	    /**
	     * Ceils the actual complex number
	     *
	     * @returns {Complex}
	     */
	    'round': function(places) {

	      places = Math.pow(10, places || 0);

	      return new Complex(
	        Math.round(this['re'] * places) / places,
	        Math.round(this['im'] * places) / places);
	    },

	    /**
	     * Compares two complex numbers
	     *
	     * **Note:** new Complex(Infinity).equals(Infinity) === false
	     *
	     * @returns {boolean}
	     */
	    'equals': function(a, b) {

	      var z = new Complex(a, b);

	      return Math.abs(z['re'] - this['re']) <= Complex['EPSILON'] &&
	        Math.abs(z['im'] - this['im']) <= Complex['EPSILON'];
	    },

	    /**
	     * Clones the actual object
	     *
	     * @returns {Complex}
	     */
	    'clone': function() {

	      return new Complex(this['re'], this['im']);
	    },

	    /**
	     * Gets a string of the actual complex number
	     *
	     * @returns {string}
	     */
	    'toString': function() {

	      var a = this['re'];
	      var b = this['im'];
	      var ret = "";

	      if (this['isNaN']()) {
	        return 'NaN';
	      }

	      if (this['isInfinite']()) {
	        return 'Infinity';
	      }

	      if (Math.abs(a) < Complex['EPSILON']) {
	        a = 0;
	      }

	      if (Math.abs(b) < Complex['EPSILON']) {
	        b = 0;
	      }

	      // If is real number
	      if (b === 0) {
	        return ret + a;
	      }

	      if (a !== 0) {
	        ret += a;
	        ret += " ";
	        if (b < 0) {
	          b = -b;
	          ret += "-";
	        } else {
	          ret += "+";
	        }
	        ret += " ";
	      } else if (b < 0) {
	        b = -b;
	        ret += "-";
	      }

	      if (1 !== b) { // b is the absolute imaginary part
	        ret += b;
	      }
	      return ret + "i";
	    },

	    /**
	     * Returns the actual number as a vector
	     *
	     * @returns {Array}
	     */
	    'toVector': function() {

	      return [this['re'], this['im']];
	    },

	    /**
	     * Returns the actual real value of the current object
	     *
	     * @returns {number|null}
	     */
	    'valueOf': function() {

	      if (this['im'] === 0) {
	        return this['re'];
	      }
	      return null;
	    },

	    /**
	     * Determines whether a complex number is not on the Riemann sphere.
	     *
	     * @returns {boolean}
	     */
	    'isNaN': function() {
	      return isNaN(this['re']) || isNaN(this['im']);
	    },

	    /**
	     * Determines whether or not a complex number is at the zero pole of the
	     * Riemann sphere.
	     *
	     * @returns {boolean}
	     */
	    'isZero': function() {
	      return this['im'] === 0 && this['re'] === 0;
	    },

	    /**
	     * Determines whether a complex number is not at the infinity pole of the
	     * Riemann sphere.
	     *
	     * @returns {boolean}
	     */
	    'isFinite': function() {
	      return isFinite(this['re']) && isFinite(this['im']);
	    },

	    /**
	     * Determines whether or not a complex number is at the infinity pole of the
	     * Riemann sphere.
	     *
	     * @returns {boolean}
	     */
	    'isInfinite': function() {
	      return !(this['isNaN']() || this['isFinite']());
	    }
	  };

	  Complex['ZERO'] = new Complex(0, 0);
	  Complex['ONE'] = new Complex(1, 0);
	  Complex['I'] = new Complex(0, 1);
	  Complex['PI'] = new Complex(Math.PI, 0);
	  Complex['E'] = new Complex(Math.E, 0);
	  Complex['INFINITY'] = new Complex(Infinity, Infinity);
	  Complex['NAN'] = new Complex(NaN, NaN);
	  Complex['EPSILON'] = 1e-15;

	  {
	    Object.defineProperty(Complex, "__esModule", { 'value': true });
	    Complex['default'] = Complex;
	    Complex['Complex'] = Complex;
	    module['exports'] = Complex;
	  }

	})();
} (complex));

var Complex = /*@__PURE__*/getDefaultExportFromCjs(complex.exports);

function stringToCodepoints(string) {
    const result = [];
    for (let i = 0; i < string.length; i++) {
        let code = string.charCodeAt(i);
        // if (code === 0x0d && string.charCodeAt(i + 1) === 0x0a) {
        //   code = 0x0a;
        //   i++;
        // }
        // if (code === 0x0d || code === 0x0c) code = 0x0a;
        // if (code === 0x00) code = 0xfffd;
        // Decode a surrogate pair into an astral codepoint.
        if (code >= 0xd800 && code <= 0xdbff) {
            const nextCode = string.charCodeAt(i + 1);
            if (nextCode >= 0xdc00 && nextCode <= 0xdfff) {
                const lead = code - 0xd800;
                const trail = nextCode - 0xdc00;
                code = 2 ** 16 + lead * 2 ** 10 + trail;
                // N = ((H - 0xD800) * 0x400) + (L - 0xDC00) + 0x10000;
                i++;
            }
        }
        result.push(code);
    }
    return result;
}
const ZWJ = 0x200d; // Zero-width joiner
// const ZWSP = 0x200b; // Zero-width space
// Regional indicator: a pair of codepoints indicating some flags
const REGIONAL_INDICATOR = [0x1f1e6, 0x1f1ff];
function isEmojiCombinator(code) {
    // Zero-width joiner
    if (code === ZWJ)
        return true;
    // VS-15: text presentation, VS-16: Emoji presentation
    if (code === 0xfe0e || code === 0xfe0f)
        return true;
    // EMOJI_MODIFIER_FITZPATRICK_TYPE 1-6
    if (code >= 0x1f3fb && code <= 0x1f3fb + 5)
        return true;
    // Red hair..white hair
    if (code >= 0x1f9b0 && code <= 0x1f9b0 + 4)
        return true;
    // EMOJI_TAG
    if (code >= 0xe0020 && code <= 0xe0020 + 96)
        return true;
    return false;
}
function isRegionalIndicator(code) {
    return code >= REGIONAL_INDICATOR[0] && code <= REGIONAL_INDICATOR[1];
}
/**
 * Return a string or an array of graphemes.
 *
 * This includes:
 * - emoji with skin and hair modifiers
 * - emoji combination (for example "female pilot")
 * - text emoji with an emoji presentation style modifier
 *      - U+1F512 U+FE0E 🔒︎
 *      - U+1F512 U+FE0F 🔒️
 * - flags represented as two regional indicator codepoints
 * - flags represented as a flag emoji + zwj + an emoji tag
 * - other combinations (for example, rainbow flag)
 */
function splitGraphemes(string) {
    // If it's all ASCII, short-circuit the grapheme splitting...
    if (/^[\u0020-\u00FF]*$/.test(string))
        return string;
    const result = [];
    const codePoints = stringToCodepoints(string);
    let index = 0;
    while (index < codePoints.length) {
        const code = codePoints[index++];
        const next = codePoints[index];
        // Combine sequences
        if (next === ZWJ) {
            // Zero-width joiner sequences are:
            // ZWJ_SEQUENCE := (CHAR + ZWJ)+
            const baseIndex = index - 1;
            index += 2;
            while (codePoints[index] === ZWJ) {
                index += 2;
            }
            result.push(String.fromCodePoint(...codePoints.slice(baseIndex, 2 * index - baseIndex + 1)));
        }
        else if (isEmojiCombinator(next)) {
            // Combine emoji sequences
            // See http://unicode.org/reports/tr51/#def_emoji_tag_sequence
            const baseIndex = index - 1; // The previous character is the 'base'
            while (isEmojiCombinator(codePoints[index])) {
                index += codePoints[index] === ZWJ ? 2 : 1;
            }
            result.push(String.fromCodePoint(...codePoints.slice(baseIndex, 2 * index - baseIndex - 1)));
        }
        else if (isRegionalIndicator(code)) {
            // Some (but not all) flags are represented by a sequence of two
            // "regional indicators" codepoints.
            index += 1;
            result.push(String.fromCodePoint(...codePoints.slice(index - 2, 2)));
        }
        else {
            result.push(String.fromCodePoint(code));
        }
    }
    return result;
}

/**
 * ## Reference
 * TeX source code:
 * {@link  http://tug.org/texlive/devsrc/Build/source/texk/web2c/tex.web | Tex.web}
 *
 */
/**
 * Given a LaTeX expression represented as a character string,
 * the Lexer class will scan and return Tokens for the lexical
 * units in the string.
 *
 * @param s A string of LaTeX
 */
class Tokenizer {
    constructor(s) {
        this.obeyspaces = false;
        this.s = splitGraphemes(s);
        this.pos = 0;
    }
    /**
     * @return True if we reached the end of the stream
     */
    end() {
        return this.pos >= this.s.length;
    }
    /**
     * Return the next char and advance
     */
    get() {
        return this.pos < this.s.length ? this.s[this.pos++] : '';
    }
    /**
     * Return the next char, but do not advance
     */
    peek() {
        return this.s[this.pos];
    }
    /**
     * Return the next substring matching regEx and advance.
     */
    match(regEx) {
        // this.s can either be a string, if it's made up only of ASCII chars
        // or an array of graphemes, if it's more complicated.
        let execResult;
        if (typeof this.s === 'string') {
            execResult = regEx.exec(this.s.slice(this.pos));
        }
        else {
            execResult = regEx.exec(this.s.slice(this.pos).join(''));
        }
        if (execResult?.[0]) {
            this.pos += execResult[0].length;
            return execResult[0];
        }
        return null;
    }
    /**
     * Return the next token, or null.
     */
    next() {
        // If we've reached the end, exit
        if (this.end())
            return null;
        // Handle white space
        // In text mode, spaces are significant,
        // however they are coalesced unless \obeyspaces
        if (!this.obeyspaces && this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]+/)) {
            // Note that browsers are inconsistent in their definitions of the
            // `\s` metacharacter, so we use an explicit pattern instead.
            // - IE:          `[ \f\n\r\t\v]`
            // - Chrome:      `[ \f\n\r\t\v\u00A0]`
            // - Firefox:     `[ \f\n\r\t\v\u00A0\u2028\u2029]`
            // - \f \u000C: form feed (FORM FEED)
            // - \n \u000A: linefeed (LINE FEED)
            // - \r \u000D: carriage return
            // - \t \u0009: tab (CHARACTER TABULATION)
            // - \v \u000B: vertical tab (LINE TABULATION)
            // - \u00A0: NON-BREAKING SPACE
            // - \u2028: LINE SEPARATOR
            // - \u2029: PARAGRAPH SEPARATOR
            return '<space>';
        }
        else if (this.obeyspaces &&
            this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]/)) {
            // Don't coalesce when this.obeyspaces is true (different regex from above)
            return '<space>';
        }
        const next = this.get();
        // Is it a command?
        if (next === '\\') {
            if (!this.end()) {
                // A command is either a string of letters and asterisks...
                let command = this.match(/^[a-zA-Z*]+/);
                if (command) {
                    // Spaces after a 'control word' are ignored
                    // (but not after a 'control symbol' (single char)
                    this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]*/);
                }
                else {
                    // ... or a single non-letter character
                    command = this.get();
                    if (command === ' ') {
                        // The `\ ` command is equivalent to a single space
                        return '<space>';
                    }
                }
                return '\\' + command;
            }
        }
        else if (next === '{') {
            // This is a group start
            return '<{>';
        }
        else if (next === '}') {
            // This is a group end
            return '<}>';
        }
        else if (next === '^') {
            if (this.peek() === '^') {
                // It might be a ^^ command (inline hex character)
                this.get();
                // There can be zero to six carets with the same number of hex digits
                const hex = this.match(/^(\^(\^(\^(\^[0-9a-f])?[0-9a-f])?[0-9a-f])?[0-9a-f])?[0-9a-f][0-9a-f]/);
                if (hex) {
                    return String.fromCodePoint(parseInt(hex.slice(hex.lastIndexOf('^') + 1), 16));
                }
            }
            return next;
        }
        else if (next === '#') {
            // This could be either a param token, or a literal # (used for
            // colorspecs, for example). A param token is a '#' followed by
            // - a digit 0-9 followed by a non-alpha, non-digit
            // - or '?'.
            // Otherwise, it's a literal '#'.
            if (!this.end()) {
                let isParam = false;
                if (/[0-9?]/.test(this.peek())) {
                    // Could be a param
                    isParam = true;
                    // Need to look ahead to the following char
                    if (this.pos + 1 < this.s.length) {
                        const after = this.s[this.pos + 1];
                        isParam = /[^0-9A-Za-z]/.test(after);
                    }
                }
                if (isParam) {
                    return '#' + this.get();
                }
                return '#';
            }
        }
        else if (next === '$') {
            // Mode switch
            if (this.peek() === '$') {
                // $$
                this.get();
                return '<$$>';
            }
            // $
            return '<$>';
        }
        return next;
    }
}
// Some primitive commands need to be handled in the expansion phase
// (the 'gullet')
function expand$1(lex, args) {
    let result = [];
    let token = lex.next();
    if (token) {
        if (token === '\\relax') ;
        else if (token === '\\noexpand') {
            // Do not expand the next token
            token = lex.next();
            if (token) {
                result.push(token);
            }
        }
        else if (token === '\\obeyspaces') {
            lex.obeyspaces = true;
        }
        else if (token === '\\space' || token === '~') {
            // The `\space` command is equivalent to a single space
            // The ~ is an 'active character' (a single character macro)
            // that maps to <space>
            result.push('<space>');
        }
        else if (token === '\\bgroup') {
            // Begin group, synonym for opening brace
            result.push('<{>');
        }
        else if (token === '\\egroup') {
            // End group, synonym for closing brace
            result.push('<}>');
        }
        else if (token === '\\string') {
            // Turn the next token into a string
            token = lex.next();
            if (token) {
                if (token[0] === '\\') {
                    Array.from(token).forEach((x) => result.push(x === '\\' ? '\\backslash' : x));
                }
                else if (token === '<{>') {
                    result.push('\\{');
                }
                else if (token === '<space>') {
                    result.push('~');
                }
                else if (token === '<}>') {
                    result.push('\\}');
                }
            }
        }
        else if (token === '\\csname') {
            // Turn the next tokens, until `\endcsname`, into a command
            while (lex.peek() === '<space>') {
                lex.next();
            }
            let command = '';
            let done = false;
            let tokens = [];
            do {
                if (tokens.length === 0) {
                    // We're out of tokens to look at, get some more
                    if (/^#[0-9?]$/.test(lex.peek())) {
                        // Expand parameters (but not commands)
                        const param = lex.get().slice(1);
                        tokens = tokenize(args?.[param] ?? args?.['?'] ?? '\\placeholder{}', args);
                        token = tokens[0];
                    }
                    else {
                        token = lex.next();
                        tokens = token ? [token] : [];
                    }
                }
                done = tokens.length === 0;
                if (!done && token === '\\endcsname') {
                    done = true;
                    tokens.shift();
                }
                if (!done) {
                    done =
                        token === '<$>' ||
                            token === '<$$>' ||
                            token === '<{>' ||
                            token === '<}>' ||
                            (!!token && token.length > 1 && token[0] === '\\');
                }
                if (!done) {
                    command += tokens.shift();
                }
            } while (!done);
            if (command) {
                result.push('\\' + command);
            }
            result = result.concat(tokens);
        }
        else if (token === '\\endcsname') ;
        else if (token.length > 1 && token[0] === '#') {
            // It's a parameter to expand
            const param = token.slice(1);
            result = result.concat(tokenize(args?.[param] ?? args?.['?'] ?? '\\placeholder{}', args));
        }
        else {
            result.push(token);
        }
    }
    return result;
}
/**
 * Create Tokens from a stream of LaTeX
 *
 * @param s - A string of LaTeX. It can include comments (with the `%`
 * marker) and multiple lines.
 */
function tokenize(s, args) {
    // Merge multiple lines into one, and remove comments
    const lines = s.toString().split(/\r?\n/);
    let stream = '';
    let sep = '';
    for (const line of lines) {
        stream += sep;
        sep = ' ';
        // Remove everything after a % (comment marker)
        // (but \% should be preserved...)
        const m = line.match(/((?:\\%)|[^%])*/);
        if (m !== null)
            stream += m[0];
    }
    const tokenizer = new Tokenizer(stream);
    const result = [];
    do
        result.push(...expand$1(tokenizer, args));
    while (!tokenizer.end());
    return result;
}
function joinLatex(segments) {
    let sep = '';
    let result = '';
    for (const segment of segments) {
        if (segment) {
            if (/[a-zA-Z*]/.test(segment[0])) {
                // If the segment begins with a char that *could* be in a command
                // name... insert a separator (if one was needed for the previous segment)
                result += sep;
            }
            // If the segment ends in a command...
            if (/\\[a-zA-Z]+\*?$/.test(segment)) {
                // ... potentially add a space before the next segment
                sep = ' ';
            }
            else {
                sep = '';
            }
            result += segment;
        }
    }
    return result;
}
function tokensToString(tokens) {
    let flat = [];
    if (Array.isArray(tokens)) {
        for (const item of tokens) {
            if (Array.isArray(item)) {
                flat = [...flat, ...item];
            }
            else {
                flat.push(item);
            }
        }
    }
    else {
        flat = [tokens];
    }
    const result = joinLatex(flat.map((token) => {
        return ({
            '<space>': ' ',
            '<$$>': '$$',
            '<$>': '$',
            '<{>': '{',
            '<}>': '}',
        }[token] ?? token);
    }));
    return result;
}

const DEFINITIONS_ALGEBRA = [
    {
        name: 'To',
        trigger: ['\\to'],
        kind: 'infix',
        precedence: 270, // MathML rightwards arrow
    },
];

function isNumberExpression(expr) {
    if (expr === null)
        return false;
    if (typeof expr === 'number')
        return true;
    if (isNumberObject(expr))
        return true;
    if (typeof expr === 'string' && /^[+-]?[0-9]/.test(expr))
        return true;
    return false;
}
function isNumberObject(expr) {
    return expr !== null && typeof expr === 'object' && 'num' in expr;
}
function isSymbolObject(expr) {
    return expr !== null && typeof expr === 'object' && 'sym' in expr;
}
function isStringObject(expr) {
    return expr !== null && typeof expr === 'object' && 'str' in expr;
}
function isFunctionObject(expr) {
    return expr !== null && typeof expr === 'object' && 'fn' in expr;
}
function isValidIdentifier(s) {
    // An identifier must not contain any of these characters
    if (/[\u0000-\u0020\u0022\u0060\ufffe\uffff]/.test(s))
        return false;
    // A symbol name must not start with one these characters
    return !/^[\u0021\u0022\u0024-\u0029\u002e\u003a\u003f\u0040\u005b\u005d\u005e\u007b\u007d\u007e\+\-[0-9]]/.test(s);
}
/**  If expr is a string literal, return it.
 *
 * A string literal is a JSON string that begins and ends with
 * **U+0027 APOSTROPHE** : **`'`** or an object literal with a `str` key.
 */
function stringValue(expr) {
    if (expr === null || expr === undefined)
        return null;
    if (typeof expr === 'object' && 'str' in expr)
        return expr.str;
    if (typeof expr !== 'string')
        return null;
    if (expr.length < 2)
        return null;
    if (expr[0] !== "'" || expr[expr.length - 1] !== "'")
        return null;
    return expr.substring(1, expr.length - 1);
}
function stripText(expr) {
    if (expr === null || expr === undefined || stringValue(expr) !== null)
        return null;
    const h = head(expr);
    if (h !== null) {
        return [
            h,
            ...(ops(expr) ?? []).map((x) => stripText(x)).filter((x) => x !== null),
        ];
    }
    return expr;
}
/**
 * The head of a function can be an identifier or an expression.
 *
 * Return `null` if the expression is not a function.
 *
 * Examples:
 * * `["Negate", 5]`  -> `"Negate"`
 * * `[["Prime", "f"], "x"]` -> `["Prime", "f"]`
 */
function head(expr) {
    if (expr === null || expr === undefined)
        return null;
    if (Array.isArray(expr)) {
        console.assert(expr.length > 0 &&
            (typeof expr[0] !== 'string' || isValidIdentifier(expr[0])));
        return expr[0];
    }
    if (isFunctionObject(expr))
        return expr.fn[0];
    return null;
}
/** Return the head of an expression, only if it's a string */
function headName(expr) {
    const h = head(expr);
    return typeof h === 'string' ? h : '';
}
/**
 * Return all the elements but the first one, i.e. the arguments of a
 * function.
 */
function ops(expr) {
    if (expr === null || expr === undefined)
        return null;
    if (Array.isArray(expr))
        return expr.slice(1);
    if (isFunctionObject(expr))
        return expr.fn.slice(1);
    return null;
}
/** Return the nth argument of a function expression */
function op(expr, n) {
    if (expr === null || expr === undefined)
        return null;
    if (Array.isArray(expr))
        return expr[n] ?? null;
    if (isFunctionObject(expr))
        return expr.fn[n] ?? null;
    return null;
}
function op1(expr) {
    return op(expr, 1);
}
function op2(expr) {
    return op(expr, 2);
}
function nops(expr) {
    if (expr === null || expr === undefined)
        return 0;
    if (Array.isArray(expr))
        return Math.max(0, expr.length - 1);
    if (isFunctionObject(expr))
        return Math.max(0, expr.fn.length - 1);
    return 0;
}
function symbol(expr) {
    if (expr === null || expr === undefined)
        return null;
    if (typeof expr === 'string') {
        // Is it a number?
        if (/^[+\-\.0-9]/.test(expr))
            return null;
        // Is it a string literal?
        if (expr.length >= 2 && expr[0] === "'" && expr[expr.length - 1] === "'")
            return null;
    }
    const s = isSymbolObject(expr) ? expr.sym : expr;
    if (typeof s !== 'string')
        return null;
    return s;
}
function keyValuePair(expr) {
    const h = head(expr);
    if (h === 'KeyValuePair' || h === 'Tuple' || h === 'Pair') {
        const key = stringValue(op1(expr));
        if (!key)
            return null;
        return [key, op2(expr) ?? 'Nothing'];
    }
    return null;
}
function dictionary(expr) {
    if (expr === null)
        return null;
    if (typeof expr === 'object' && 'dict' in expr)
        return expr.dict;
    const kv = keyValuePair(expr);
    if (kv)
        return { [kv[0]]: kv[1] };
    const h = head(expr);
    if (h === 'Dictionary') {
        const result = {};
        for (let i = 1; i < nops(expr); i++) {
            const kv = keyValuePair(op(expr, i));
            if (kv)
                result[kv[0]] = kv[1];
        }
        return result;
    }
    return null;
}
function machineValueOfString(s) {
    s = s
        .toLowerCase()
        .replace(/[nd]$/g, '')
        .replace(/[\u0009-\u000d\u0020\u00a0]/g, '');
    if (s === 'nan')
        return NaN;
    if (s === '+infinity')
        return Infinity;
    if (s === '-infinity')
        return -Infinity;
    // Are there some repeating decimals?
    if (/\([0-9]+\)/.test(s)) {
        const [_, body, repeat, trail] = s.match(/(.+)\(([0-9]+)\)(.*)$/) ?? [];
        s = body + repeat.repeat(Math.ceil(16 / repeat.length)) + (trail ?? '');
    }
    // CAUTION: By using parseFloat, numbers with a precision greater than
    // machine range will be truncated. Numbers with an exponent outside of the
    // machine range will be returned as `Infinity` or `-Infinity`
    return parseFloat(s);
}
// CAUTION: `machineValue()` will return a truncated value if the number has
// a precision outside of the machine range.
function machineValue(expr) {
    if (expr === null || expr === undefined)
        return null;
    if (typeof expr === 'number')
        return expr;
    if (isNumberObject(expr))
        return machineValueOfString(expr.num);
    if (typeof expr === 'string')
        return machineValueOfString(expr);
    return null;
}
/**
 * Return a rational (numer over denom) representation of the expression,
 * if possible, `null` otherwise.
 *
 * The expression can be:
 * - Some symbols: "Infinity", "Half"...
 * - ["Power", d, -1]
 * - ["Power", n, 1]
 * - ["Divide", n, d]
 *
 * The denominator is always > 0.
 */
function rationalValue(expr) {
    if (expr === undefined || expr === null)
        return null;
    if (symbol(expr) === 'Half')
        return [1, 2];
    const h = head(expr);
    if (!h)
        return null;
    let numer = null;
    let denom = null;
    if (h === 'Negate') {
        const r = rationalValue(op1(expr));
        if (r)
            return [-r[0], r[1]];
    }
    if (h === 'Rational' || h === 'Divide') {
        numer = machineValue(op1(expr)) ?? NaN;
        denom = machineValue(op2(expr)) ?? NaN;
    }
    if (h === 'Power') {
        const exponent = machineValue(op2(expr));
        if (exponent === 1) {
            numer = machineValue(op1(expr));
            denom = 1;
        }
        else if (exponent === -1) {
            numer = 1;
            denom = machineValue(op1(expr));
        }
    }
    if (h === 'Multiply' &&
        head(op2(expr)) === 'Power' &&
        machineValue(op2(op2(expr))) === -1) {
        numer = machineValue(op1(expr));
        denom = machineValue(op1(op2(expr)));
    }
    if (numer === null || denom === null)
        return null;
    if (Number.isInteger(numer) && Number.isInteger(denom))
        return [numer, denom];
    return null;
}
function subs(expr, s) {
    const h = head(expr);
    if (h !== null)
        return [subs(h, s), ...(ops(expr) ?? []).map((x) => subs(x, s))];
    const dict = dictionary(expr);
    if (dict !== null) {
        const keys = Object.keys(dict);
        const result = {};
        for (const key of keys)
            result[key] = subs(dict[key], s);
        return { dict: result };
    }
    const sym = symbol(expr);
    if (sym && s[sym])
        return s[sym];
    return expr;
}
/**
 * Apply a function to the arguments of a function and return an array of T
 */
function mapArgs(expr, fn) {
    let args = null;
    if (Array.isArray(expr))
        args = expr;
    if (isFunctionObject(expr))
        args = expr.fn;
    if (args === null)
        return [];
    let i = 1;
    const result = [];
    while (i < args.length) {
        result.push(fn(args[i]));
        i += 1;
    }
    return result;
}
/**
 * Apply the operator `op` to the left-hand-side and right-hand-side
 * expression. Applies the associativity rule specified by the definition,
 * i.e. 'op(a, op(b, c))` -> `op(a, b, c)`, etc...
 *
 */
function applyAssociativeOperator(op, lhs, rhs, associativity = 'both') {
    if (associativity === 'non')
        return [op, lhs, rhs];
    const lhsName = head(lhs);
    const rhsName = head(rhs);
    if (associativity === 'left') {
        if (lhsName === op)
            return [op, ...(ops(lhs) ?? []), rhs];
        return [op, lhs, rhs];
    }
    if (associativity === 'right') {
        if (rhsName === op)
            return [op, lhs, ...(ops(rhs) ?? [])];
        return [op, lhs, rhs];
    }
    // Associativity: 'both'
    if (lhsName === op && rhsName === op) {
        return [op, ...(ops(lhs) ?? []), ...(ops(rhs) ?? [])];
    }
    if (lhsName === op)
        return [op, ...(ops(lhs) ?? []), rhs];
    if (rhsName === op)
        return [op, lhs, ...(ops(rhs) ?? [])];
    return [op, lhs, rhs];
}
function getSequence(expr) {
    let h = head(expr);
    if (expr === null)
        return null;
    if (h === 'Delimiter') {
        expr = op(expr, 1);
        if (expr === null)
            return [];
        if (head(expr) !== 'Sequence')
            return [expr];
    }
    h = head(expr);
    if (h === 'Sequence')
        return ops(expr) ?? [];
    return null;
}
function isEmptySequence(expr) {
    if (expr === null)
        return false;
    if (head(expr) !== 'Sequence')
        return false;
    if (nops(expr) !== 0)
        return false;
    return true;
}
function missingIfEmpty(expr) {
    if (expr === null || isEmptySequence(expr))
        return ['Error', "'missing'"];
    return expr;
}
function countFunctionLeaves(xs) {
    if (xs[0] === 'Square') {
        // Square is synonym with Power(..., 2)
        return countFunctionLeaves(xs.slice(1)) + 2;
    }
    return xs.reduce((acc, x) => acc + countLeaves(x), 0);
}
/** The number of leaves (atomic expressions) in the expression */
function countLeaves(expr) {
    if (expr === null)
        return 0;
    if (typeof expr === 'number' || typeof expr === 'string')
        return 1;
    if (isNumberExpression(expr) || isSymbolObject(expr) || isStringObject(expr))
        return 1;
    if (Array.isArray(expr))
        return countFunctionLeaves(expr);
    if ('fn' in expr)
        return countFunctionLeaves(expr.fn);
    const dict = dictionary(expr);
    if (dict) {
        const keys = Object.keys(dict);
        return (1 +
            keys.length +
            keys.reduce((acc, x) => acc + countLeaves(dict[x]), 0));
    }
    return 0;
}

function getApplyFunctionStyle(_expr, _level) {
    return 'paren';
}
function getGroupStyle(_expr, _level) {
    return 'paren';
}
function getRootStyle(_expr, level) {
    return level > 2 ? 'solidus' : 'radical';
}
function getFractionStyle(expr, level) {
    if (level > 3)
        return 'inline-solidus';
    if (head(expr) === 'Divide') {
        const [n, d] = [countLeaves(op1(expr)), countLeaves(op2(expr))];
        if (d <= 2 && n > 3)
            return 'factor';
        if (n <= 2 && d > 3)
            return 'reciprocal';
    }
    return 'quotient';
}
// https://en.wikipedia.org/wiki/Logical_connective
function getLogicStyle(_expr, _level) {
    // punctuation = & | !
    // word = and or not
    // uppercase-word = AND OR NOT
    // boolean = ∧ ∨ ¬
    return 'boolean';
}
function getPowerStyle(_expr, _level) {
    return 'solidus';
}
//  * - "N"           Q28920044 Natural numbers (positive integers): 1, 2, 3, 4, ...
//  * - "Z^*"          Non-Zero integers: -2, -1, 1, 2, 3, ...
//  * - "R_-":         Q200227 Negative real number <0
//  * - "R_+"          Q3176558 Positive real numbers (JS float) >0
//  * - "R^0_-":        Q47341108 Non-positive real number <= 0
//  * - "R^0_+"         Q13896108 Non-negative real numbers (JS float) >=0
//  * - "R"           Real numbers (JS float)
// Re: "set builder notation"
// The notation itself in its modern form can be traced back to Lefschetz's
// Algebraic Topology (1942), and variants appear already in Principia (1910)
// and von Neumann's Zur Einführung der transfiniten Zahlen (1923). See Who
// first discovered the concept corresponding to the symbol of class
// comprehension? for many more details. However, mathematicians did not use the
// name "set-builder". Bernays (1958) calls it "class operator" and Suppes
// (1960) "definition by abstraction". The name does not appear before 1957, but
// in 1958 we find it in the lively discussions of the high school curriculum in
// The Mathematics Teacher. E.g. Rourke's Some implications of twentieth century
// mathematics for high schools explains:
// A 1948 University of Chicago Press publication Fundamental Mathematics Volume
// 1 Prepared for the General Course 1 in the College ("by the College
// mathematics staff" with a list of 13 names) uses the term "SET-BUILDER" on
// p.25.
// https://hsm.stackexchange.com/questions/3445/first-use-of-curly-braces-to-denote-a-set
// Compact:     \R^*
// Regular       R \setminus { 0 }
// Interval     ]-\infty, 0( \union )0, \infty ]
// Set builder  { x \in \R | x \ne 0 }
// Compact      \N^0
// Regular      \N \union { 0 }
// Interval     [0, 1..]
// Set Builder  { x \in \Z | x > 0 }
function getNumericSetStyle(_expr, _level) {
    return 'compact';
}

/**
 * If expression is a product, collect all the terms with a
 * negative exponents in the denominator, and all the terms
 * with a positive exponent (or no exponent) in the numerator.
 */
function numeratorDenominator(expr) {
    if (head(expr) !== 'Multiply')
        return [[], []];
    const numerator = [];
    const denominator = [];
    const args = ops(expr) ?? [];
    for (const arg of args) {
        if (head(arg) === 'Power') {
            const op1 = op(arg, 1);
            const op2 = op(arg, 2);
            if (head(op2) === 'Negate') {
                const b = op(op2, 1);
                if (op1 && b)
                    denominator.push(['Power', op1, b]);
            }
            else {
                const exponentVal = machineValue(op2) ?? NaN;
                if (exponentVal === -1) {
                    if (op1)
                        denominator.push(op1);
                }
                else if (exponentVal < 0) {
                    if (op1)
                        denominator.push(['Power', op1, -exponentVal]);
                }
                else {
                    numerator.push(arg);
                }
            }
        }
        else if (head(arg) === 'Rational' && nops(arg) === 2) {
            const op1 = op(arg, 1);
            const op2 = op(arg, 2);
            if (machineValue(op1) !== 1)
                numerator.push(op1);
            if (machineValue(op2) !== 1)
                denominator.push(op2);
        }
        else {
            const r = rationalValue(arg);
            if (r !== null) {
                if (r[0] !== 1)
                    numerator.push(r[0]);
                denominator.push(r[1]);
            }
            else
                numerator.push(arg);
        }
    }
    return [numerator, denominator];
}
function parseRoot(parser) {
    const degree = parser.matchOptionalLatexArgument();
    const base = parser.matchRequiredLatexArgument();
    if (base === null || isEmptySequence(base)) {
        if (degree !== null)
            return ['Root', ['Error', "'missing'"], missingIfEmpty(degree)];
        return ['Sqrt', ['Error', "'missing'"]];
    }
    if (degree !== null)
        return ['Root', base, degree];
    return ['Sqrt', base];
}
function serializeRoot(serializer, style, base, degree) {
    if (base === null)
        return '\\sqrt{}';
    degree = degree ?? 2;
    if (style === 'solidus') {
        return (serializer.wrapShort(base) + '^{1\\/' + serializer.serialize(degree) + '}');
    }
    else if (style === 'quotient') {
        return (serializer.wrapShort(base) +
            '^{\\frac{1}{' +
            serializer.serialize(degree) +
            '}}');
    }
    const degreeValue = machineValue(degree);
    if (degreeValue === 2)
        return '\\sqrt{' + serializer.serialize(base) + '}';
    // It's the n-th root
    return ('\\sqrt[' +
        serializer.serialize(degree) +
        ']{' +
        serializer.serialize(base) +
        '}');
}
function serializeAdd(serializer, expr) {
    // "add" doesn't increase the "level" for styling purposes
    // so, preventively decrease it now.
    serializer.level -= 1;
    const name = head(expr);
    let result = '';
    let arg = op(expr, 1);
    if (name === 'Negate') {
        result = '-' + serializer.wrap(arg, 276);
    }
    else if (name === 'Add') {
        if (nops(expr) === 2) {
            let op1;
            let op2;
            if (machineValue(op(expr, 1)) && rationalValue(op(expr, 2))) {
                op1 = op(expr, 1);
                op2 = op(expr, 2);
            }
            else if (machineValue(op(expr, 2)) && rationalValue(op(expr, 1))) {
                op1 = op(expr, 2);
                op2 = op(expr, 1);
            }
            if (op1 && op2) {
                const lhs = machineValue(op1) ?? NaN;
                const rhs = rationalValue(op2) ?? [NaN, NaN];
                if (isFinite(lhs) &&
                    Number.isInteger(lhs) &&
                    lhs >= 0 &&
                    lhs <= 1000 &&
                    isFinite(rhs[0]) &&
                    isFinite(rhs[1]) &&
                    rhs[0] > 0 &&
                    rhs[0] <= 100 &&
                    rhs[1] <= 100) {
                    // Don't include the '+' sign, it's a rational, use 'invisible plus'
                    result = joinLatex([
                        serializer.serialize(op1),
                        serializer.options.invisiblePlus,
                        serializer.serialize(op2),
                    ]);
                    serializer.level += 1;
                    return result;
                }
            }
        }
        let val = machineValue(arg) ?? NaN;
        result = serializer.serialize(arg);
        const last = nops(expr) + 1;
        for (let i = 2; i < last; i++) {
            arg = op(expr, i);
            val = machineValue(arg) ?? NaN;
            if (val < 0) {
                // Don't include the minus sign, it will be serialized for the arg
                result += serializer.serialize(arg);
            }
            else if (head(arg) === 'Negate') {
                result += serializer.wrap(arg, 275);
            }
            else {
                const term = serializer.wrap(arg, 275);
                if (term[0] === '-' || term[0] === '+')
                    result += term;
                else
                    result += '+' + term;
            }
        }
    }
    else if (name === 'Subtract') {
        result = serializer.wrap(arg, 275);
        const arg2 = op(expr, 2);
        if (arg2 !== null) {
            const term = serializer.wrap(arg2, 275);
            if (term[0] === '-')
                result += '+' + term.slice(1);
            else if (term[0] === '+')
                result += '-' + term.slice(1);
            else
                result = result + '-' + term;
        }
    }
    // Restore the level
    serializer.level += 1;
    return result;
}
function serializeMultiply(serializer, expr) {
    if (expr === null)
        return '';
    // "Multiply" doesn't increase the "level" for styling purposes
    // so, preventively decrease it now.
    serializer.level -= 1;
    let result = '';
    //
    // Is it a fraction?
    // (i.e. does it have a denominator, i.e. some factors with a negative power)
    //
    const [numer, denom] = numeratorDenominator(expr);
    if (denom.length > 0) {
        if (denom.length === 1 && denom[0] === 1) {
            if (numer.length === 0)
                result = '1';
            else if (numer.length === 1)
                result = serializer.serialize(numer[0]);
            else
                result = serializeMultiply(serializer, ['Multiply', ...numer]);
        }
        else {
            result = serializer.serialize([
                'Divide',
                numer.length === 1 ? numer[0] : ['Multiply', ...numer],
                denom.length === 1 ? denom[0] : ['Multiply', ...denom],
            ]);
        }
    }
    if (result) {
        // Restore the level
        serializer.level += 1;
        return result;
    }
    let isNegative = false;
    let arg = null;
    const count = nops(expr) + 1;
    let prevWasNumber = false;
    for (let i = 1; i < count; i++) {
        arg = op(expr, i);
        if (arg === null)
            continue;
        let term;
        //
        // 1. Should the terms be separated by an explicit 'Multiply'?
        //
        if (isNumberExpression(arg)) {
            term = serializer.serialize(arg);
            if (term === '-1' && !result) {
                result = '';
                isNegative = !isNegative;
            }
            else {
                if (term[0] === '-') {
                    term = term.slice(1);
                    isNegative = !isNegative;
                }
                result = !result
                    ? term
                    : joinLatex([result, serializer.options.multiply, term]);
            }
            prevWasNumber = true;
            continue;
        }
        if (head(arg) === 'Power') {
            // It's a power with a fractional exponent,
            // it's a nth-root
            const r = rationalValue(op(arg, 2));
            if (r) {
                const [n, d] = r;
                if (n === 1 && d !== null) {
                    result += serializeRoot(serializer, getRootStyle(arg, serializer.level), op(arg, 1), d);
                    prevWasNumber = false;
                    continue;
                }
            }
        }
        if (head(arg) === 'Power' && !isNaN(machineValue(op(arg, 1)) ?? NaN)) {
            // It's a power and the base is a number...
            // add a multiply...
            term = serializer.serialize(arg);
            result = !result
                ? term
                : joinLatex([result, serializer.options.multiply, term]);
            prevWasNumber = true;
            continue;
        }
        if (head(arg) === 'Negate') {
            arg = op(arg, 1);
            isNegative = !isNegative;
        }
        // 2.1 Wrap the term if necessary
        // (if it's an operator of precedence less than 390)
        term = serializer.wrap(arg, 390);
        // 2.2. The terms can be separated by an invisible multiply.
        if (!result) {
            // First term
            result = term;
        }
        else {
            const h = head(arg);
            if (prevWasNumber && (h === 'Divide' || h === 'Rational')) {
                // Can't use an invisible multiply if a number
                // multiplied by a fraction
                result = joinLatex([result, serializer.options.multiply, term]);
            }
            // Not first term, use invisible multiply
            else if (!serializer.options.invisibleMultiply) {
                // Replace, joining the terms correctly
                // i.e. inserting a space between '\pi' and 'x'
                result = joinLatex([result, term]);
            }
            else {
                result = joinLatex([
                    result,
                    serializer.options.invisibleMultiply,
                    term,
                ]);
            }
        }
        prevWasNumber = false;
    }
    // Restore the level
    serializer.level += 1;
    return isNegative ? '-' + result : result;
}
function parseFraction(parser) {
    const numer = missingIfEmpty(parser.matchRequiredLatexArgument());
    const denom = missingIfEmpty(parser.matchRequiredLatexArgument());
    if (head(numer) === 'PartialDerivative' &&
        (head(denom) === 'PartialDerivative' ||
            (head(denom) === 'Multiply' &&
                head(op(denom, 1)) === 'PartialDerivative'))) {
        // It's a Leibniz notation partial derivative
        // `∂f(x)/∂x` or `∂^2f(x)/∂x∂y` or `∂/∂x f(x)`
        const degree = op(numer, 3) ?? null;
        // Expect: getArg(numer, 2) === 'Nothing' -- no args
        let fn = op(numer, 1);
        if (fn === null)
            fn = missingIfEmpty(parser.matchExpression());
        let vars = [];
        if (head(denom) === 'Multiply') {
            // ?/∂x∂y
            for (const arg of ops(denom) ?? []) {
                if (head(arg) === 'PartialDerivative') {
                    const v = op(arg, 2);
                    if (v)
                        vars.push(v);
                }
            }
        }
        else {
            // ?/∂x
            const v = op(denom, 2);
            if (v)
                vars.push(v);
        }
        if (vars.length > 1) {
            vars = ['List', ...vars];
        }
        return ['PartialDerivative', fn, ...vars, degree === null ? 1 : degree];
    }
    return ['Divide', numer, denom];
}
function serializeFraction(serializer, expr) {
    // console.assert(getFunctionName(expr) === 'Divide');
    if (expr === null)
        return '';
    const numer = missingIfEmpty(op(expr, 1));
    const denom = missingIfEmpty(op(expr, 2));
    const style = getFractionStyle(expr, serializer.level);
    if (style === 'inline-solidus' || style === 'nice-solidus') {
        const numerStr = serializer.wrapShort(numer);
        const denomStr = serializer.wrapShort(denom);
        if (style === 'inline-solidus')
            return `${numerStr}\\/${denomStr}`;
        return `^{${numerStr}}\\!\\!/\\!_{${denomStr}}`;
    }
    else if (style === 'reciprocal') {
        if (machineValue(numer) === 1)
            return serializer.wrap(denom) + '^{-1}';
        return serializer.wrap(numer) + serializer.wrap(denom) + '^{-1}';
    }
    else if (style === 'factor') {
        if (machineValue(denom) === 1)
            return serializer.wrap(numer);
        return ('\\frac{1}{' + serializer.serialize(denom) + '}' + serializer.wrap(numer));
    }
    // Quotient (default)
    const numerLatex = serializer.serialize(numer);
    const denomLatex = serializer.serialize(denom);
    return `\\frac{${numerLatex}}{${denomLatex}}`;
}
function serializePower(serializer, expr) {
    const name = head(expr);
    const base = missingIfEmpty(op(expr, 1));
    if (name === 'Sqrt') {
        return serializeRoot(serializer, getRootStyle(expr, serializer.level - 1), base, 2);
    }
    const exp = missingIfEmpty(op(expr, 2));
    if (name === 'Root')
        return serializeRoot(serializer, getRootStyle(expr, serializer.level - 1), base, exp);
    const val2 = machineValue(exp) ?? 1;
    if (val2 === -1) {
        return serializer.serialize(['Divide', '1', base]);
    }
    else if (val2 < 0) {
        return serializer.serialize(['Divide', '1', ['Power', base, -val2]]);
    }
    else if (head(exp) === 'Divide' || head(exp) === 'Rational') {
        if (machineValue(op(exp, 1)) === 1) {
            // It's x^{1/n} -> it's a root
            const style = getRootStyle(expr, serializer.level);
            return serializeRoot(serializer, style, base, op(exp, 2));
        }
        if (machineValue(op(exp, 2)) === 2) {
            // It's x^(n/2) -> it's √x^n
            return `${serializer.serialize(['Sqrt', base])}^{${serializer.serialize(op(exp, 1))}}`;
        }
    }
    else if (head(exp) === 'Power') {
        if (machineValue(op(exp, 2)) === -1) {
            // It's x^{n^-1} -> it's a root
            const style = getRootStyle(expr, serializer.level);
            return serializeRoot(serializer, style, base, op(exp, 1));
        }
    }
    return serializer.wrapShort(base) + '^{' + serializer.serialize(exp) + '}';
}
const DEFINITIONS_ARITHMETIC = [
    // Constants
    { name: 'CatalanConstant', serialize: 'G' },
    { name: 'GoldenRatio', serialize: '\\varphi' },
    { name: 'EulerGamma', serialize: '\\gamma' },
    {
        name: 'Degrees',
        trigger: ['\\degree'],
        kind: 'postfix',
        precedence: 880,
        parse: (_parser, lhs) => ['Degrees', lhs],
        serialize: (serializer, expr) => {
            return joinLatex([serializer.serialize(op(expr, 1)), '\\degree']);
        },
    },
    {
        trigger: ['\\degree'],
        kind: 'postfix',
        precedence: 880,
        parse: (_parser, lhs) => ['Degrees', lhs],
    },
    {
        trigger: ['^', '<{>', '\\circ', '<}>'],
        kind: 'postfix',
        parse: (_parser, lhs) => ['Degrees', lhs],
    },
    {
        trigger: ['^', '\\circ'],
        kind: 'postfix',
        parse: (_parser, lhs) => ['Degrees', lhs],
    },
    {
        trigger: ['°'],
        kind: 'postfix',
        precedence: 880,
        parse: (_parser, lhs) => ['Degrees', lhs],
    },
    {
        trigger: ['\\ang'],
        parse: (parser) => {
            const arg = parser.matchRequiredLatexArgument();
            return (arg === null ? ['Degrees'] : ['Degrees', arg]);
        },
    },
    {
        trigger: ['\\infty'],
        parse: { num: '+Infinity' },
    },
    {
        name: 'ComplexInfinity',
        trigger: ['\\tilde', '\\infty'],
        serialize: '\\tilde\\infty',
    },
    {
        trigger: ['\\tilde', '<{>', '\\infty', '<}>'],
        parse: 'ComplexInfinity',
    },
    { name: 'Pi', trigger: ['\\pi'] },
    { trigger: ['π'], parse: 'Pi' },
    {
        name: 'ExponentialE',
        trigger: ['\\exponentialE'],
        parse: 'ExponentialE',
        serialize: '\\exponentialE',
    },
    {
        name: 'ImaginaryUnit',
        trigger: ['\\imaginaryI'],
    },
    // Operations
    {
        /** Could be the determinant if the argument is a matrix */
        /** @todo: domain check */
        /** If a literal matrix, the `serialize` should be custom, the parens are
         * replaced with bars */
        name: 'Abs',
        kind: 'matchfix',
        openDelimiter: '|',
        closeDelimiter: '|',
        parse: (_parser, expr) => (isEmptySequence(expr) ? null : ['Abs', expr]),
    },
    {
        trigger: 'abs',
        kind: 'function',
        parse: (parser) => {
            const arg = parser.matchArguments('enclosure');
            return arg === null ? 'Abs' : ['Abs', ...arg];
        },
    },
    {
        name: 'Add',
        trigger: ['+'],
        kind: 'infix',
        associativity: 'both',
        precedence: 275,
        parse: (parser, until, lhs) => {
            if (275 < until.minPrec)
                return null;
            const rhs = parser.matchExpression({ ...until, minPrec: 275 });
            if (rhs === null)
                return null;
            return applyAssociativeOperator('Add', lhs, rhs);
        },
        serialize: serializeAdd,
    },
    {
        kind: 'prefix',
        trigger: ['+'],
        precedence: 275,
        parse: (parser, until) => {
            if (275 < until.minPrec)
                return null;
            return parser.matchExpression({ ...until, minPrec: 400 });
        },
    },
    {
        name: 'Ceil',
        kind: 'matchfix',
        openDelimiter: '\\lceil',
        closeDelimiter: '\\rceil',
    },
    {
        trigger: 'ceil',
        kind: 'function',
        parse: (parser) => {
            const arg = parser.matchArguments('enclosure');
            return arg === null ? 'Ceil' : ['Ceil', ...arg];
        },
    },
    {
        name: 'Complex',
        precedence: 274,
        serialize: (serializer, expr) => {
            const re = machineValue(op(expr, 1));
            const im = machineValue(op(expr, 2));
            if (im === 0)
                return serializer.serialize(op(expr, 1));
            const imPart = im === 1
                ? '\\imaginaryI'
                : im === -1
                    ? '-\\imaginaryI'
                    : joinLatex([serializer.serialize(op(expr, 2)), '\\imaginaryI']);
            if (re === 0)
                return imPart;
            if (im !== null && im < 0)
                return joinLatex([serializer.serialize(op(expr, 1)), imPart]);
            return joinLatex([serializer.serialize(op(expr, 1)), '+', imPart]);
        },
    },
    {
        name: 'Divide',
        trigger: '\\frac',
        precedence: 660,
        // For \frac specifically, not for \div, etc..
        // handles Leibnitz notation for partial derivatives
        parse: parseFraction,
        serialize: serializeFraction,
    },
    {
        kind: 'infix',
        trigger: '\\over',
        precedence: 660,
        parse: 'Divide',
    },
    {
        trigger: ['\\/'],
        kind: 'infix',
        associativity: 'non',
        precedence: 660,
        // It has to be at least higher than multiply
        // e.g. `1/2+3*x` -> `1/2 + 3*x` , not `1/(2+3*x)`
        parse: 'Divide',
    },
    {
        trigger: ['/'],
        kind: 'infix',
        associativity: 'non',
        precedence: 660,
        parse: 'Divide',
    },
    {
        trigger: ['\\div'],
        kind: 'infix',
        associativity: 'non',
        precedence: 660,
        parse: 'Divide',
    },
    {
        name: 'Exp',
        serialize: (serializer, expr) => joinLatex([
            '\\exponentialE^{',
            serializer.serialize(missingIfEmpty(op(expr, 1))),
            '}',
        ]),
    },
    {
        name: 'Factorial',
        trigger: ['!'],
        kind: 'postfix',
        precedence: 810,
    },
    {
        name: 'Factorial2',
        trigger: ['!', '!'],
        kind: 'postfix',
        precedence: 810,
    },
    {
        name: 'Floor',
        kind: 'matchfix',
        openDelimiter: '\\lfloor',
        closeDelimiter: '\\rfloor',
    },
    {
        trigger: 'floor',
        kind: 'function',
        parse: (parser) => {
            const arg = parser.matchArguments('enclosure');
            return arg === null ? 'Floor' : ['Floor', ...arg];
        },
    },
    {
        name: 'Gcd',
        trigger: 'gcd',
        kind: 'function',
    },
    {
        name: 'Half',
        serialize: '\\frac12',
    },
    {
        name: 'Lg',
        trigger: ['\\lg'],
        serialize: (serializer, expr) => '\\log_{10}' + serializer.wrapArguments(expr),
        parse: (parser) => {
            const arg = parser.matchArguments('implicit');
            if (arg === null)
                return ['Lg'];
            return ['Log', ...arg, 10];
        },
    },
    {
        name: 'Lb',
        trigger: '\\lb',
        parse: (parser) => {
            const arg = parser.matchArguments('implicit');
            if (arg === null)
                return ['Log'];
            return ['Log', ...arg, 2];
        },
    },
    {
        name: 'Ln',
        trigger: ['\\ln'],
        serialize: (serializer, expr) => '\\ln' + serializer.wrapArguments(expr),
        parse: (parser) => parseLog('Ln', parser),
    },
    {
        name: 'Log',
        trigger: ['\\log'],
        parse: (parser) => parseLog('Log', parser),
        serialize: (serializer, expr) => {
            const base = op2(expr);
            if (base)
                return joinLatex([
                    '\\log_{',
                    base.toString(),
                    '}',
                    serializer.wrap(op1(expr)),
                ]);
            return '\\log' + serializer.wrapArguments(expr);
        },
    },
    {
        name: 'Lcm',
        trigger: 'lcm',
        kind: 'function',
    },
    {
        name: 'MinusPlus',
        trigger: ['\\mp'],
        kind: 'infix',
        associativity: 'both',
        precedence: 270,
    },
    {
        name: 'Multiply',
        trigger: ['\\times'],
        kind: 'infix',
        associativity: 'both',
        precedence: 390,
        serialize: serializeMultiply,
    },
    {
        trigger: ['\\cdot'],
        kind: 'infix',
        associativity: 'both',
        precedence: 390,
        parse: (parser, terminator, lhs) => {
            if (391 < terminator.minPrec)
                return null;
            const rhs = parser.matchExpression({ ...terminator, minPrec: 392 });
            if (rhs === null)
                return ['Multiply', lhs, ['Error', "'missing'"]];
            return applyAssociativeOperator('Multiply', lhs, rhs);
        },
    },
    {
        trigger: ['*'],
        kind: 'infix',
        associativity: 'both',
        precedence: 390,
        parse: (parser, terminator, lhs) => {
            if (391 < terminator.minPrec)
                return null;
            const rhs = parser.matchExpression({ ...terminator, minPrec: 392 });
            if (rhs === null)
                return ['Multiply', lhs, ['Error', "'missing'"]];
            return applyAssociativeOperator('Multiply', lhs, rhs);
        },
    },
    {
        name: 'Negate',
        trigger: ['-'],
        kind: 'prefix',
        parse: (parser, terminator) => {
            if (276 < terminator.minPrec)
                return null;
            const rhs = parser.matchExpression({ ...terminator, minPrec: 400 });
            return ['Negate', missingIfEmpty(rhs)];
        },
        precedence: 275,
    },
    // {
    //   /** If the argument is a vector */
    //   /** @todo: domain check */
    //   name: 'Norm',
    //   kind: 'matchfix',
    //   openDelimiter: '|',
    //   closeDelimiter: '|',
    // },
    // {
    //   /** If the argument is a set */
    //   /** @todo: domain check */
    //   name: 'Cardinality',
    //   kind: 'matchfix',
    //   openDelimiter: '|',
    //   closeDelimiter: '|',
    // },
    {
        //   /** If the argument is a vector */
        /** @todo: domain check */
        kind: 'matchfix',
        openDelimiter: '||',
        closeDelimiter: '||',
        parse: (_parser, expr) => (isEmptySequence(expr) ? null : ['Norm', expr]),
    },
    {
        //   /** If the argument is a vector */
        /** @todo: domain check */
        name: 'Norm',
        kind: 'matchfix',
        openDelimiter: ['\\left', '\\Vert'],
        closeDelimiter: ['\\right', '\\Vert'],
    },
    {
        name: 'PlusMinus',
        trigger: ['\\pm'],
        kind: 'infix',
        associativity: 'both',
        precedence: 270,
    },
    {
        name: 'Power',
        trigger: ['^'],
        kind: 'infix',
        serialize: serializePower,
    },
    {
        trigger: '\\prod',
        precedence: 390,
        name: 'Product',
        parse: parseBigOp('Product', 390),
        serialize: serializeBigOp('\\prod'),
    },
    // {
    //   trigger: ['*', '*'],
    //   kind: 'infix',
    //   associativity: 'non',
    //   precedence: 720,
    // },
    {
        name: 'Rational',
        precedence: 660,
        serialize: (serializer, expr) => {
            if (expr && nops(expr) === 1)
                return '\\mathrm{Rational}' + serializer.wrapArguments(expr);
            return serializeFraction(serializer, expr);
        },
    },
    {
        name: 'Root',
        serialize: serializePower,
    },
    {
        name: 'Round',
        trigger: 'round',
        kind: 'function',
    },
    {
        name: 'Square',
        precedence: 720,
        serialize: (serializer, expr) => serializer.wrapShort(op(expr, 1)) + '^2',
    },
    {
        trigger: '\\sum',
        precedence: 275,
        name: 'Sum',
        parse: parseBigOp('Sum', 275),
        serialize: serializeBigOp('\\sum'),
    },
    {
        name: 'Sign',
        // As per ISO 80000-2, "signum" is 'sgn'
        trigger: 'sgn',
        kind: 'function',
    },
    {
        name: 'Sqrt',
        trigger: ['\\sqrt'],
        parse: parseRoot,
        serialize: serializePower,
    },
    {
        name: 'Subtract',
        trigger: ['-'],
        kind: 'infix',
        associativity: 'both',
        precedence: 275,
        parse: (parser, terminator, lhs) => {
            if (276 < terminator.minPrec)
                return null;
            const rhs = parser.matchExpression({ ...terminator, minPrec: 277 });
            return ['Subtract', lhs, missingIfEmpty(rhs)];
        },
    },
];
function parseBigOp(name, prec) {
    return (parser) => {
        // Look for sub and sup
        parser.skipSpace();
        let sup = null;
        let sub = null;
        while (!(sub && sup) && (parser.peek === '_' || parser.peek === '^')) {
            if (parser.match('_'))
                sub = parser.matchRequiredLatexArgument();
            else if (parser.match('^'))
                sup = parser.matchRequiredLatexArgument();
            parser.skipSpace();
        }
        if (sub === 'Nothing' || isEmptySequence(sub))
            sub = null;
        if (sup === 'Nothing' || isEmptySequence(sup))
            sup = null;
        let index = null;
        let lower = null;
        if (head(sub) === 'Equal') {
            index = op(sub, 1);
            lower = op(sub, 2);
        }
        else {
            index = sub;
        }
        const sym = symbol(index);
        // Create a temporary scope to make sure the index symbol is
        // not mis-interpreted. Classic example: if the index is `i`, the
        // letter `i` should not be interpreted as a ImaginaryUnit
        if (sym)
            parser.computeEngine?.pushScope({ [sym]: { domain: 'Integer' } });
        const fn = parser.matchExpression({ minPrec: prec + 1 });
        if (sym)
            parser.computeEngine?.popScope();
        if (!fn)
            return [name];
        if (sup)
            return [
                name,
                fn,
                ['Tuple', index ? ['Hold', index] : 'Nothing', lower ?? 1, sup],
            ];
        if (lower)
            return [name, fn, ['Tuple', index ? ['Hold', index] : 'Nothing', lower]];
        if (index)
            return [name, fn, ['Tuple', ['Hold', index]]];
        return [name, fn];
    };
}
function serializeBigOp(command) {
    return (serializer, expr) => {
        if (!op(expr, 1))
            return command;
        let arg = op(expr, 2);
        const h = head(arg);
        if (h !== 'Tuple' && h !== 'Triple' && h !== 'Pair' && h !== 'Single')
            arg = null;
        let index = op(arg, 1);
        if (index && head(index) === 'Hold')
            index = op(index, 1);
        const fn = op(expr, 1);
        if (!arg) {
            if (!op(expr, 2))
                return joinLatex([command, '_n', serializer.serialize(fn)]);
            return joinLatex([
                command,
                '_{',
                serializer.serialize(op(expr, 2)),
                '}',
                serializer.serialize(fn),
            ]);
        }
        const lower = op(arg, 2);
        let sub = [];
        if (index && symbol(index) !== 'Nothing' && lower)
            sub = [serializer.serialize(index), '=', serializer.serialize(lower)];
        else if (index && symbol(index) !== 'Nothing')
            sub = [serializer.serialize(index)];
        else if (lower)
            sub = [serializer.serialize(lower)];
        if (sub.length > 0)
            sub = ['_{', ...sub, '}'];
        let sup = [];
        if (op(arg, 3))
            sup = ['^{', serializer.serialize(op(arg, 3)), '}'];
        return joinLatex([command, ...sup, ...sub, serializer.serialize(fn)]);
    };
}
function parseLog(command, parser) {
    let sub = null;
    let base = null;
    if (parser.match('_')) {
        sub = parser.matchStringArgument() ?? parser.next();
        base = Number.parseFloat(sub ?? '10');
    }
    const arg = parser.matchArguments('implicit');
    if (arg === null)
        return [command];
    if (base === 10)
        return ['Log', arg[0]];
    if (base === 2)
        return ['Lb', ...arg];
    if (sub === null)
        return [command, ...arg];
    return ['Log', ...arg, sub];
}

// function isSpacingToken(token: string): boolean {
//   return (
//     token === '<space>' ||
//     token === '\\qquad' ||
//     token === '\\quad' ||
//     token === '\\enskip' ||
//     token === '\\;' ||
//     token === '\\,' ||
//     token === '\\ ' ||
//     token === '~'
//   );
// }
/**
 * Parse a sequence of expressions separated with ','
 */
function parseSequence(parser, terminator, lhs, prec, sep) {
    console.assert(lhs !== null);
    if (terminator.minPrec >= prec)
        return null;
    const result = [lhs];
    let done = false;
    while (!done) {
        done = true;
        parser.skipSpace();
        while (parser.match(sep)) {
            result.push('Nothing');
            parser.skipSpace();
        }
        if (parser.atTerminator(terminator)) {
            result.push('Nothing');
        }
        else {
            const rhs = parser.matchExpression({ ...terminator, minPrec: prec });
            result.push(rhs ?? 'Nothing');
            done = rhs === null;
        }
        if (!done) {
            parser.skipSpace();
            done = !parser.match(sep);
        }
    }
    return result;
}
function serializeSequence(sep = '') {
    return (serializer, expr) => (ops(expr) ?? []).map((x) => serializer.serialize(x)).join(sep);
}
const DEFINITIONS_CORE = [
    //
    // Constants
    //
    {
        trigger: ['\\placeholder'],
        parse: (parser) => {
            // Parse, but ignore, the optional and required LaTeX args
            parser.skipSpaceTokens();
            if (parser.match('['))
                while (!parser.match(']') && !parser.atBoundary)
                    parser.next();
            parser.skipSpaceTokens();
            if (parser.match('<{>'))
                while (!parser.match('<}>') && !parser.atBoundary)
                    parser.next();
            return 'Nothing';
        },
    },
    //
    // Functions
    //
    {
        name: 'BaseForm',
        kind: 'function',
        serialize: (serializer, expr) => {
            const radix = machineValue(op(expr, 2)) ?? NaN;
            if (isFinite(radix) && radix >= 2 && radix <= 36) {
                // CAUTION: machineValue() may return a truncated value
                // if the number is outside of the machine range.
                const num = machineValue(op(expr, 1)) ?? NaN;
                if (isFinite(num) && Number.isInteger(num)) {
                    let digits = Number(num).toString(radix);
                    let groupLength = 0;
                    if (radix === 2) {
                        groupLength = 4;
                    }
                    else if (radix === 10) {
                        groupLength = 4;
                    }
                    else if (radix === 16) {
                        groupLength = 2;
                    }
                    else if (radix > 16) {
                        groupLength = 4;
                    }
                    if (groupLength > 0) {
                        const oldDigits = digits;
                        digits = '';
                        for (let i = 0; i < oldDigits.length; i++) {
                            if (i > 0 && i % groupLength === 0)
                                digits = '\\, ' + digits;
                            digits = oldDigits[oldDigits.length - i - 1] + digits;
                        }
                    }
                    return `(\\text{${digits}}_{${radix}}`;
                }
            }
            return ('\\operatorname{BaseForm}(' +
                serializer.serialize(op(expr, 1)) +
                ', ' +
                serializer.serialize(op(expr, 2)) +
                ')');
        },
    },
    {
        name: 'Delimiter',
        serialize: (serializer, expr) => {
            // @todo: could use `serializer.groupStyle`
            const argCount = nops(expr);
            if (argCount === 0)
                return '';
            const style = serializer.options.groupStyle(expr, serializer.level + 1);
            const arg1 = op(expr, 1);
            if (argCount === 1)
                return serializer.wrapString(serializer.serialize(arg1), style);
            let sep = '';
            let open = '';
            let close = '';
            if (argCount > 1) {
                const op2 = stringValue(op(expr, 2)) ?? '';
                open = op2[0] ?? '';
                close = op2[1] ?? '';
                sep = op2[2] ?? '';
            }
            const body = head(arg1) === 'List'
                ? serializeSequence(sep)(serializer, arg1)
                : serializer.serialize(arg1);
            serializer.wrapString(body, style, stringValue(op(expr, 2)) ?? undefined);
            if (!open || !close)
                return serializer.wrapString(body, style);
            return `${open} ${body} ${close}`;
        },
    },
    {
        name: 'Domain',
        serialize: (serializer, expr) => {
            if (head(expr) === 'Error')
                return serializer.serialize(expr);
            return `\\mathbf{${serializer.serialize(op(expr, 1))}}`;
        },
    },
    {
        trigger: ['\\mathtip'],
        parse: (parser) => {
            const op1 = parser.matchRequiredLatexArgument();
            parser.matchRequiredLatexArgument();
            return op1;
        },
    },
    {
        trigger: ['\\texttip'],
        parse: (parser) => {
            const op1 = parser.matchRequiredLatexArgument();
            parser.matchRequiredLatexArgument();
            return op1;
        },
    },
    {
        trigger: ['\\error'],
        parse: (parser) => parser.matchRequiredLatexArgument(),
    },
    {
        name: 'Error',
        serialize: (serializer, expr) => {
            if (stringValue(op(expr, 1)) === 'missing')
                return `\\error{${serializer.options.missingSymbol ?? '\\placeholder{}'}}`;
            const where = errorContextAsLatex(serializer, expr) || '\\blacksquare';
            const op1 = op(expr, 1);
            const code = head(op1) === 'ErrorCode' ? stringValue(op(op1, 1)) : stringValue(op1);
            if (code === 'incompatible-domain') {
                return `\\mathtip{\\error{${where}}}{\\in ${serializer.serialize(op(op1, 3))}\\notin ${serializer.serialize(op(op1, 2))}}`;
            }
            if (code === 'missing') {
                return `\\mathtip{\\error{${where}}}{${serializer.serialize(op(op1, 2))}\\text{ missing}}`;
            }
            if (typeof code === 'string')
                return `\\error{${where}}`;
            return `\\error{${where}}`;
        },
    },
    {
        name: 'ErrorCode',
        serialize: (serializer, expr) => {
            const code = stringValue(op(expr, 1));
            if (code === 'missing')
                return serializer.options.missingSymbol ?? '\\placeholder{}';
            if (code === 'unexpected-command' ||
                code === 'unexpected-operator' ||
                code === 'unexpected-token' ||
                code === 'invalid-symbol-name' ||
                code === 'unknown-environment' ||
                code === 'unexpected-base' ||
                code === 'incompatible-domain' ||
                code === 'invalid-domain-expression') {
                return '';
            }
            return `\\texttip{\\error{\\blacksquare}}{\\mathtt{${code}}}`;
        },
    },
    {
        name: 'FromLatex',
        serialize: (_serializer, expr) => {
            return `\\texttt{${sanitizeLatex(stringValue(op(expr, 1)))}}`;
        },
    },
    {
        name: 'Latex',
        serialize: (serializer, expr) => {
            if (expr === null)
                return '';
            return joinLatex(mapArgs(expr, (x) => stringValue(x) ?? serializer.serialize(x)));
        },
    },
    {
        name: 'LatexString',
        serialize: (serializer, expr) => {
            if (expr === null)
                return '';
            return joinLatex(mapArgs(expr, (x) => serializer.serialize(x)));
        },
    },
    { name: 'LatexTokens', serialize: serializeLatexTokens },
    {
        name: 'List',
        kind: 'matchfix',
        openDelimiter: '[',
        closeDelimiter: ']',
        parse: (_parser, lhs) => {
            if (lhs === null)
                return ['List'];
            if (head(lhs) !== 'Sequence' && head(lhs) !== 'List')
                return ['List', lhs];
            return ['List', ...(ops(lhs) ?? [])];
        },
        serialize: (serializer, expr) => {
            return joinLatex([
                '\\lbrack',
                serializeSequence(', ')(serializer, expr),
                '\\rbrack',
            ]);
        },
    },
    {
        kind: 'matchfix',
        openDelimiter: '(',
        closeDelimiter: ')',
        parse: (_parser, body) => {
            // @todo: does this really need to be done here? Sequence(Sequence(...))
            if (body === null)
                return null;
            if (head(body) === 'Sequence' || head(body) === 'List') {
                if (nops(body) === 0)
                    return ['Delimiter'];
                return ['Delimiter', ['Sequence', ...(ops(body) ?? [])]];
            }
            return ['Delimiter', body];
        },
    },
    {
        trigger: [','],
        kind: 'infix',
        precedence: 20,
        // Unlike the matchfix version of List,
        // when the comma operator is used, the lhs and rhs are flattened,
        // i.e. `1,2,3` -> `["Delimiter", ["List", 1, 2, 3],  ","]`,
        // and `1, (2, 3)` -> `["Delimiter",
        // ["Sequence", 1, ["Delimiter", ["List", 2, 3],  "(", ",", ")"]],  ","],
        parse: (parser, terminator, lhs) => {
            const seq = parseSequence(parser, terminator, lhs, 20, ',');
            if (seq === null)
                return null;
            return ['Sequence', ...seq];
        },
    },
    {
        name: 'Sequence',
        serialize: serializeSequence(''),
    },
    {
        trigger: [';'],
        kind: 'infix',
        precedence: 19,
        parse: (parser, terminator, lhs) => {
            const seq = parseSequence(parser, terminator, lhs, 19, ';');
            if (seq === null)
                return null;
            return [
                'Sequence',
                ...seq.map((x) => head(x) === 'Sequence' ? ['List', ...(ops(x) ?? [])] : x),
            ];
        },
    },
    {
        name: 'String',
        trigger: ['\\text'],
        parse: (scanner) => parseTextRun(scanner),
        serialize: (serializer, expr) => {
            const args = ops(expr);
            if (args === null || args.length === 0)
                return '\\text{}';
            return joinLatex([
                '\\text{',
                args.map((x) => serializer.serialize(x)).join(''),
                '}',
            ]);
        },
    },
    {
        name: 'Subscript',
        trigger: ['_'],
        kind: 'infix',
        serialize: (serializer, expr) => {
            if (nops(expr) === 2) {
                return (serializer.serialize(op(expr, 1)) +
                    '_{' +
                    serializer.serialize(op(expr, 2)) +
                    '}');
            }
            return '_{' + serializer.serialize(op(expr, 1)) + '}';
        },
    },
    { name: 'Superplus', trigger: ['^', '+'], kind: 'postfix' },
    { name: 'Subplus', trigger: ['_', '+'], kind: 'postfix' },
    { name: 'Superminus', trigger: ['^', '-'], kind: 'postfix' },
    { name: 'Subminus', trigger: ['_', '-'], kind: 'postfix' },
    {
        trigger: ['^', '*'],
        kind: 'postfix',
        parse: (_parser, lhs) => ['Superstar', lhs],
    },
    // @todo: when lhs is a complex number, 'Conjugate'
    // { name: 'Conjugate', trigger: ['\\star'], kind: 'infix' },
    { name: 'Superstar', trigger: ['^', '\\star'], kind: 'postfix' },
    {
        trigger: ['_', '*'],
        kind: 'postfix',
        parse: (_parser, lhs) => ['Substar', lhs],
    },
    { name: 'Substar', trigger: ['_', '\\star'], kind: 'postfix' },
    { name: 'Superdagger', trigger: ['^', '\\dagger'], kind: 'postfix' },
    {
        trigger: ['^', '\\dag'],
        kind: 'postfix',
        parse: (_parser, lhs) => ['Superdagger', lhs],
    },
    {
        name: 'Prime',
        trigger: ['^', '\\prime'],
        kind: 'postfix',
    },
    {
        trigger: ['^', '\\doubleprime'],
        kind: 'postfix',
        parse: (_parser, lhs) => ['Prime', missingIfEmpty(lhs), 2],
    },
    {
        name: 'InverseFunction',
        // trigger: '^{-1}',
        // kind: 'postfix',
        serialize: (serializer, expr) => serializer.serialize(op(expr, 1)) + '^{-1}',
    },
    {
        name: 'Derivative',
        serialize: (serializer, expr) => {
            const degree = machineValue(op(expr, 1)) ?? NaN;
            if (!isFinite(degree))
                return '';
            const base = serializer.serialize(op(expr, 2));
            if (degree === 1) {
                return base + '^{\\prime}';
            }
            else if (degree === 2) {
                return base + '^{\\doubleprime}';
            }
            return base + '^{(' + Number(degree).toString() + ')}';
        },
    },
    {
        name: 'Which',
        trigger: 'cases',
        kind: 'environment',
        parse: (parser) => {
            const tabular = parser.matchTabular('cases');
            if (!tabular)
                return ['Which'];
            // Note: return `True` for the condition, because it must be present
            // as the second element of the Tuple. Return an empty sequence for the
            // value, because it is optional
            const result = ['Which'];
            for (const row of tabular) {
                if (row.length === 1) {
                    result.push('True');
                    result.push(row[0]);
                }
                else if (row.length === 2) {
                    const s = stringValue(row[1]);
                    // If a string, probably 'else' or 'otherwise'
                    result.push(s ? 'True' : stripText(row[1]) ?? 'True');
                    result.push(row[0]);
                }
            }
            return result;
        },
        serialize: (serialize, expr) => {
            if (head(op(expr, 1)) !== 'List')
                return '';
            const rows = ops(op(expr, 1)) ?? [];
            const body = [];
            let rowSep = '';
            for (const row of rows) {
                if (head(row) === 'Tuple' || head(row) === 'Pair') {
                    body.push(rowSep);
                    if (op(row, 2)) {
                        body.push(serialize.serialize(op(row, 2)));
                        const condition = op(row, 1);
                        if (condition !== null)
                            body.push('&', serialize.serialize(condition));
                    }
                }
                rowSep = '\\\\';
            }
            return joinLatex(['\\begin{cases}', ...body, '\\end{cases}']);
        },
    },
];
// ["Style", expr, dic] where dic: {"color": "#fff", "font-size": "2em" }
// ["HtmlData", expr, dic]
/**
 * Parse content in text mode.
 *
 * Text mode can only include a small subset of LaTeX commands:
 * - <{> (groups inside text)
 * - \unicode
 * - \char
 * - ^^
 * - ^^^^
 * - \textbf
 * - \textmd
 * - \textup
 * - \textsl
 * - \textit
 * - \texttt
 * - \textsf
 * - \textcolor{}{}
 * - {\color{}}
//
// greek?
// spacing? \hspace, \! \: \enskip...
// \boxed ?
// \fcolorbox ?
 */
/**
 * Start scanning a text run. The scanner is pointing at a `<{>
 */
function parseTextRun(parser, style) {
    if (!parser.match('<{>'))
        return "''";
    const runs = [];
    let text = '';
    let runinStyle = null;
    while (!parser.atEnd && !parser.match('<}>')) {
        if (parser.peek === '<{>') {
            runs.push(parseTextRun(parser));
        }
        else if (parser.match('\\textbf') && parser.match('<{>')) {
            runs.push(parseTextRun(parser, { 'font-weight': 'bold' }));
            // @todo! other text styles...
        }
        else if (parser.match('\\color') && parser.match('<{>')) {
            // Run-in style
            const color = parser.matchColor();
            if (color && parser.match('<}>')) {
                // Stash the current text/runinstyle
                if (runinStyle !== null && text) {
                    runs.push(['Style', text, { dict: runinStyle }]);
                }
                else if (text) {
                    runs.push(['String', text]);
                }
                text = '';
                runinStyle = { color };
            }
        }
        else if (parser.match('<space>')) {
            text += ' ';
        }
        else if (parser.match('<$>')) {
            const index = parser.index;
            const expr = parser.matchExpression() ?? ['Sequence'];
            parser.skipSpace();
            if (parser.match('<$>')) {
                runs.push(expr);
            }
            else {
                text += '$';
                parser.index = index;
            }
        }
        else if (parser.match('<$$>')) {
            const index = parser.index;
            const expr = parser.matchExpression() ?? ['Sequence'];
            parser.skipSpace();
            if (parser.match('<$$>')) {
                runs.push(expr);
            }
            else {
                text += '$$';
                parser.index = index;
            }
        }
        else
            text += parser.matchChar() ?? '';
    }
    // Apply leftovers
    if (runinStyle !== null && text) {
        runs.push(['Style', `'${text}'`, { dict: runinStyle }]);
    }
    else if (text) {
        runs.push(`'${text}'`);
    }
    let body;
    if (runs.length === 1)
        body = runs[0];
    else {
        if (runs.every((x) => stringValue(x) !== null))
            body = "'" + runs.map((x) => stringValue(x)).join() + "'";
        else
            body = ['String', ...runs];
    }
    return style ? ['Style', body, { dict: style }] : body;
}
function serializeLatexTokens(serializer, expr) {
    if (expr === null)
        return '';
    return joinLatex(mapArgs(expr, (x) => {
        const s = stringValue(x);
        if (s === null)
            return serializer.serialize(x);
        // If not a string, serialize the expression to LaTeX
        if (s === '<{>')
            return '{';
        if (s === '<}>')
            return '}';
        if (s === '<$>')
            return '$';
        if (s === '<$$>')
            return '$$';
        if (s === '<space>')
            return ' ';
        return s;
    }));
}
/**
 * Given a string of presumed (but possibly invalid) LaTeX, return a
 * LaTeX string with all the special characters escaped.
 */
function sanitizeLatex(s) {
    if (s === null)
        return '';
    // Replace special Latex characters
    return s.replace(/[{}\[\]\\:\-\$%]/g, (c) => ({
        '{': '\\lbrace ',
        '}': '\\rbrace ',
        '[': '\\lbrack ',
        ']': '\\rbrack ',
        ':': '\\colon ',
        '\\': '\\backslash ',
    }[c] ?? '\\' + c));
}
function errorContextAsLatex(serializer, error) {
    const arg = op(error, 2);
    if (!arg)
        return '';
    if (head(arg) === 'Latex')
        return `\\texttt{${sanitizeLatex(stringValue(op(arg, 1)) ?? '')}}`;
    if (head(arg) === 'Hold')
        return serializer.serialize(op(arg, 1));
    return serializer.serialize(arg);
}

const DEFINITIONS_INEQUALITIES = [
    {
        trigger: ['!', '<'],
        kind: 'infix',
        associativity: 'right',
        precedence: 246,
        parse: 'NotLess',
    },
    {
        name: 'NotLess',
        trigger: ['\\nless'],
        kind: 'infix',
        associativity: 'right',
        precedence: 246,
    },
    {
        trigger: ['<'],
        kind: 'infix',
        associativity: 'right',
        precedence: 245,
        parse: 'Less',
    },
    {
        name: 'Less',
        trigger: ['\\lt'],
        kind: 'infix',
        associativity: 'right',
        precedence: 245,
    },
    {
        trigger: ['<', '='],
        kind: 'infix',
        associativity: 'right',
        precedence: 241,
        parse: 'LessEqual',
    },
    {
        name: 'LessEqual',
        trigger: ['\\le'],
        kind: 'infix',
        associativity: 'right',
        precedence: 241,
    },
    {
        trigger: ['\\leq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 241,
        parse: 'Equal',
    },
    {
        trigger: ['\\leqslant'],
        kind: 'infix',
        associativity: 'right',
        precedence: 265,
        parse: 'LessEqual',
    },
    {
        name: 'LessNotEqual',
        trigger: ['\\lneqq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'NotLessNotEqual',
        trigger: ['\\nleqq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'LessOverEqual',
        trigger: ['\\leqq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'GreaterOverEqual',
        trigger: ['\\geqq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 265,
        parse: 'GreaterEqual',
    },
    {
        name: 'Equal',
        trigger: ['='],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        trigger: ['*', '='],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
        parse: 'StarEqual',
    },
    {
        name: 'StarEqual',
        trigger: ['\\star', '='],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'PlusEqual',
        trigger: ['+', '='],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'MinusEqual',
        trigger: ['-', '='],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'SlashEqual',
        trigger: ['/', '='],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'EqualEqual',
        trigger: ['=', '='],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'EqualEqualEqual',
        trigger: ['=', '=', '='],
        kind: 'infix',
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'TildeFullEqual',
        trigger: ['\\cong'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'NotTildeFullEqual',
        trigger: ['\\ncong'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        trigger: [':', '='],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
        parse: 'Assign',
    },
    {
        name: 'Assign',
        trigger: ['\\coloneq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'Approx',
        trigger: ['\\approx'],
        kind: 'infix',
        associativity: 'right',
        precedence: 247,
    },
    {
        name: 'NotApprox',
        trigger: ['\\approx'],
        kind: 'infix',
        associativity: 'right',
        precedence: 247,
    },
    {
        name: 'ApproxEqual',
        trigger: ['\\approxeq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'NotApproxEqual',
        trigger: ['!', '\\approxeq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 250,
    },
    {
        name: 'NotEqual',
        trigger: ['\\ne'],
        kind: 'infix',
        associativity: 'right',
        precedence: 255,
    },
    {
        name: 'Unequal',
        trigger: ['!', '='],
        kind: 'infix',
        associativity: 'right',
        precedence: 260, // Note different precendence than \\ne per MathML
    },
    {
        name: 'GreaterEqual',
        trigger: ['\\ge'],
        kind: 'infix',
        associativity: 'right',
        precedence: 242, // Note: different precendence than `>=` as per MathML
    },
    {
        trigger: ['\\geq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 242,
        parse: 'GreaterEqual',
    },
    {
        trigger: ['>', '='],
        kind: 'infix',
        associativity: 'right',
        precedence: 243,
        parse: 'GreaterEqual',
    },
    {
        trigger: ['\\geqslant'],
        kind: 'infix',
        associativity: 'right',
        precedence: 265,
        parse: 'GreaterEqual',
    },
    {
        name: 'GreaterNotEqual',
        trigger: ['\\gneqq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'NotGreaterNotEqual',
        trigger: ['\\ngeqq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        trigger: ['>'],
        kind: 'infix',
        associativity: 'right',
        precedence: 245,
        parse: 'Greater',
    },
    {
        name: 'Greater',
        trigger: ['\\gt'],
        kind: 'infix',
        associativity: 'right',
        precedence: 245,
    },
    {
        name: 'NotGreater',
        trigger: ['\\ngtr'],
        kind: 'infix',
        associativity: 'right',
        precedence: 244,
    },
    {
        trigger: ['!', '>'],
        kind: 'infix',
        associativity: 'right',
        precedence: 244,
        parse: 'NotGreater',
    },
    {
        name: 'RingEqual',
        trigger: ['\\circeq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'TriangleEqual',
        trigger: ['\\triangleq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'DotEqual',
        trigger: ['\\doteq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'DotEqualDot',
        trigger: ['\\doteqdot'],
        kind: 'infix',
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'FallingDotEqual',
        trigger: ['\\fallingdotseq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'RisingDotEqual',
        trigger: ['\\fallingdotseq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'QuestionEqual',
        trigger: ['\\questeq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'Equivalent',
        trigger: ['\\equiv'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        trigger: ['\\iff'],
        kind: 'infix',
        parse: 'Equivalent',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'MuchLess',
        trigger: ['\\ll'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'MuchGreater',
        trigger: ['\\gg'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'Precedes',
        trigger: ['\\prec'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'Succeeds',
        trigger: ['\\succ'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'PrecedesEqual',
        trigger: ['\\preccurlyeq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'SucceedsEqual',
        trigger: ['\\curlyeqprec'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'NotPrecedes',
        trigger: ['\\nprec'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'NotSucceeds',
        trigger: ['\\nsucc'],
        kind: 'infix',
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'Between',
        trigger: ['\\between'],
        kind: 'infix',
        associativity: 'right',
        precedence: 265,
    },
];

const DEFINITIONS_LOGIC = [
    // Constants
    {
        name: 'True',
        trigger: ['\\mathrm', '<{>', 'T', 'r', 'u', 'e', '<}>'],
        serialize: '\\mathrm{True}',
    },
    {
        name: 'False',
        trigger: ['\\mathrm', '<{>', 'F', 'a', 'l', 's', 'e', '<}>'],
        serialize: '\\mathrm{False}',
    },
    {
        name: 'Maybe',
        trigger: ['\\mathrm', '<{>', 'M', 'a', 'y', 'b', 'e', '<}>'],
        serialize: '\\mathrm{Maybe}',
    },
];

function parseSingleArg(cmd) {
    return (parser) => {
        const arg = parser.matchRequiredLatexArgument();
        if (arg === null)
            return [cmd];
        return [cmd, arg];
    };
}
const DEFINITIONS_OTHERS = [
    {
        name: 'Overscript',
        trigger: ['\\overset'],
        kind: 'infix',
        precedence: 700, // @todo: not in MathML
    },
    {
        name: 'Underscript',
        trigger: ['\\underset'],
        kind: 'infix',
        precedence: 700, // @todo: not in MathML
    },
    {
        name: 'Increment',
        trigger: ['+', '+'],
        kind: 'postfix',
        precedence: 880,
    },
    {
        name: 'Decrement',
        trigger: ['-', '-'],
        kind: 'postfix',
        precedence: 880,
    },
    {
        name: 'PreIncrement',
        trigger: ['+', '+'],
        kind: 'prefix',
        precedence: 880,
    },
    {
        name: 'PreDecrement',
        trigger: ['-', '-'],
        kind: 'prefix',
        precedence: 880,
    },
    {
        name: 'Ring',
        trigger: ['\\circ'],
        kind: 'infix',
        precedence: 265,
        // @todo: check lhs and rhs are functions
    },
    {
        name: 'Transpose',
        trigger: ['^', 'T'],
        kind: 'infix',
        // @todo: if lhs is a list/tensor
    },
    {
        // @todo: if lhs is a list/tensor
        name: 'ConjugateTranspose',
        trigger: ['^', 'H'],
        kind: 'infix',
    },
    {
        name: 'StringJoin',
        trigger: ['\\lt', '\\gt'],
        kind: 'infix',
        precedence: 780,
    },
    {
        name: 'Starstar',
        trigger: ['\\star', '\\star'],
        kind: 'infix',
        precedence: 780,
    },
    {
        // Partial derivative using a variation of the Euler notation: `∂_xf(x)`
        // (the Euler notation uses `D_1f(x)` where "1" is for the first variable
        // For the Leibniz notation see 'Divide' that handles `∂f/∂x`
        name: 'PartialDerivative',
        trigger: ['\\partial'],
        kind: 'prefix',
        parse: (parser) => {
            let done = false;
            let sup = 'Nothing';
            let sub = 'Nothing';
            while (!done) {
                parser.skipSpace();
                if (parser.match('_')) {
                    sub = parser.matchRequiredLatexArgument();
                }
                else if (parser.match('^')) {
                    sup = parser.matchRequiredLatexArgument();
                }
                else {
                    done = true;
                }
            }
            const seq = getSequence(sub);
            if (seq)
                sub = ['List', ...seq];
            if (sub === null || sup === null)
                return null;
            let rhs = parser.matchRequiredLatexArgument() ?? 'Nothing';
            if (rhs !== 'Nothing' && !isEmptySequence(rhs)) {
                const arg = parser.matchArguments('enclosure') ?? ['Nothing'];
                rhs = [rhs, ...arg];
            }
            return ['PartialDerivative', rhs, sub, sup];
        },
        serialize: (serializer, expr) => {
            let result = '\\partial';
            const fn = op(expr, 1);
            const vars = op(expr, 2);
            const degree = op(expr, 3);
            if (vars !== null && vars !== 'Nothing') {
                if (head(vars) === 'List') {
                    result +=
                        '_{' +
                            serializer.serialize(['Sequence', ...(ops(vars) ?? [])]) +
                            '}';
                }
                else {
                    result += '_{' + serializer.serialize(vars) + '}';
                }
            }
            if (degree !== null && degree !== 'Nothing')
                result += '^{' + serializer.serialize(degree) + '}';
            if (fn !== null && fn !== 'Nothing')
                result += serializer.serialize(fn);
            return result;
        },
        precedence: 740,
    },
    {
        name: 'OverBar',
        trigger: ['\\overline'],
        parse: parseSingleArg('OverBar'),
    },
    {
        name: 'UnderBar',
        trigger: ['\\underline'],
        parse: parseSingleArg('UnderBar'),
    },
    {
        name: 'OverVector',
        trigger: ['\\vec'],
        parse: parseSingleArg('OverVector'),
    },
    {
        name: 'OverTilde',
        trigger: ['\\tilde'],
        parse: parseSingleArg('OverTilde'),
    },
    {
        name: 'OverHat',
        trigger: ['\\hat'],
        parse: parseSingleArg('OverHat'),
    },
    {
        name: 'OverRightArrow',
        trigger: ['\\overrightarrow'],
        parse: parseSingleArg('OverRightArrow'),
    },
    {
        name: 'OverLeftArrow',
        trigger: ['\\overleftarrow'],
        parse: parseSingleArg('OverLeftArrow'),
    },
    {
        name: 'OverRightDoubleArrow',
        trigger: ['\\Overrightarrow'],
        parse: parseSingleArg('OverRightDoubleArrow'),
    },
    {
        name: 'OverLeftHarpoon',
        trigger: ['\\overleftharpoon'],
        parse: parseSingleArg('OverLeftHarpoon'),
    },
    {
        name: 'OverRightHarpoon',
        trigger: ['\\overrightharpoon'],
        parse: parseSingleArg('OverRightHarpoon'),
    },
    {
        name: 'OverLeftRightArrow',
        trigger: ['\\overleftrightarrow'],
        parse: parseSingleArg('OverLeftRightArrow'),
    },
    {
        name: 'OverBrace',
        trigger: ['\\overbrace'],
        parse: parseSingleArg('OverBrace'),
    },
    {
        name: 'OverLineSegment',
        trigger: ['\\overlinesegment'],
        parse: parseSingleArg('OverLineSegment'),
    },
    {
        name: 'OverGroup',
        trigger: ['\\overgroup'],
        parse: parseSingleArg('OverGroup'),
    },
    {
        trigger: ['\\displaystyle'],
        parse: () => ['Sequence'],
    },
    {
        trigger: ['\\textstyle'],
        parse: () => ['Sequence'],
    },
    {
        trigger: ['\\scriptstyle'],
        parse: () => ['Sequence'],
    },
    {
        trigger: ['\\scriptscriptstyle'],
        parse: () => ['Sequence'],
    },
    {
        trigger: ['\\tiny'],
        parse: () => ['Sequence'],
    },
    {
        trigger: ['\\scriptsize'],
        parse: () => ['Sequence'],
    },
    {
        trigger: ['\\footnotesize'],
        parse: () => ['Sequence'],
    },
    {
        trigger: ['\\small'],
        parse: () => ['Sequence'],
    },
    {
        trigger: ['\\normalsize'],
        parse: () => ['Sequence'],
    },
    {
        trigger: ['\\large'],
        parse: () => ['Sequence'],
    },
    {
        trigger: ['\\Large'],
        parse: () => ['Sequence'],
    },
    {
        trigger: ['\\LARGE'],
        parse: () => ['Sequence'],
    },
    {
        trigger: ['\\huge'],
        parse: () => ['Sequence'],
    },
    {
        trigger: ['\\Huge'],
        parse: () => ['Sequence'],
    },
    {
        name: 'Style',
        serialize: (serializer, expr) => {
            let result = serializer.serialize(op(expr, 1));
            const dict = dictionary(op(expr, 2));
            if (dict === null)
                return result;
            if (stringValue(dict.display) === 'block')
                result = joinLatex(['{\\displaystyle', result, '}']);
            else if (stringValue(dict.display) === 'inline')
                result = joinLatex(['{\\textstyle', result, '}']);
            else if (stringValue(dict.display) === 'script')
                result = joinLatex(['{\\scriptstyle', result, '}']);
            else if (stringValue(dict.display) === 'scriptscript')
                result = joinLatex(['{\\scriptscriptstyle', result, '}']);
            const v = machineValue(dict.size);
            if (v !== null && v >= 1 && v <= 10) {
                result = joinLatex([
                    '{',
                    {
                        1: '\\tiny',
                        2: '\\scriptsize',
                        3: '\\footnotesize',
                        4: '\\small',
                        5: '\\normalsize',
                        6: '\\large',
                        7: '\\Large',
                        8: '\\LARGE',
                        9: '\\huge',
                        10: '\\Huge',
                    }[v],
                    result,
                    '}',
                ]);
            }
            return result;
        },
    },
    {
        trigger: ['\\!'],
        parse: () => ['HorizontalSpacing', -3],
    },
    {
        trigger: ['\\ '],
        parse: () => ['HorizontalSpacing', 6],
    },
    {
        trigger: ['\\:'],
        parse: () => ['HorizontalSpacing', 4],
    },
    {
        trigger: ['\\enskip'],
        parse: () => ['HorizontalSpacing', 9],
    },
    {
        trigger: ['\\quad'],
        parse: () => ['HorizontalSpacing', 18],
    },
    {
        trigger: ['\\qquad'],
        parse: () => ['HorizontalSpacing', 36],
    },
    {
        trigger: ['\\,'],
        parse: () => ['HorizontalSpacing', 3],
    },
    {
        trigger: ['\\;'],
        parse: () => ['HorizontalSpacing', 5],
    },
    {
        trigger: ['\\enspace'],
        parse: () => ['HorizontalSpacing', 9],
    },
    {
        name: 'HorizontalSpacing',
        // The `HorizontalSpacing` function has two forms
        // `["HorizontalSpacing", number]` -> indicate a space of mu units
        // `["HorizontalSpacing", expr, 'op'|'bin'|rel]` -> indicate a spacing around and expression, i.e. `\mathbin{x}`, etc...
        serialize: (serializer, expr) => {
            if (op(expr, 2)) {
                // @todo: handle op(expr,2) == 'op', 'bin', etc...
                return serializer.serialize(op(expr, 1));
            }
            const v = machineValue(op(expr, 1));
            if (v === null)
                return '';
            return ({
                '-3': '\\!',
                6: '\\ ',
                3: '\\,',
                4: '\\:',
                5: '\\;',
                9: '\\enspace',
                18: '\\quad',
                36: '\\qquad',
            }[v] ?? '');
        },
    },
    // if (
    //   [
    //     '\\!',
    //     '\\:',
    //     '\\enskip',
    //     '\\quad',
    //     '\\,',
    //     '\\;',
    //     '\\enspace',
    //     '\\qquad',
    //     '\\selectfont',
    //   ].includes(token)
    // ) {
    //   return 'skip';
    // }
    // {
    //     name: '',
    //     trigger: '\\mathring',
    // },
    // {
    //     name: '',
    //     trigger: '\\check',
    // },
];
// https://reference.wolfram.com/language/tutorial/TextualInputAndOutput.html

/**
 * Trigonometric functions have some special conventions that require a
 * custom parser: they can be followed by a "-1" superscript indicating
 * that the inversion function should be used, i.e. "\sin^{-1}" for "arcsin".
 *
 */
function parseTrig(op) {
    return (parser) => {
        let isInverse = false;
        let primeLevel = 0;
        let sup = null;
        parser.skipSpace();
        if (parser.match('^')) {
            parser.skipSpace();
            const start = parser.index;
            // Is this ^{-1}? or some primes?
            if (parser.match('<{>')) {
                parser.skipSpace();
                if (parser.match('-') && parser.match('1')) {
                    parser.skipSpace();
                    if (parser.match('<}>'))
                        isInverse = true;
                }
                if (!isInverse) {
                    // Is it one or more Prime?
                    let done = false;
                    while (!done) {
                        parser.skipSpace();
                        if (parser.match('\\doubleprime'))
                            primeLevel += 2;
                        else if (parser.match('\\prime'))
                            primeLevel += 1;
                        else if (parser.match("'"))
                            primeLevel += 1;
                        else
                            done = true;
                    }
                    if (!parser.match('<}>'))
                        primeLevel = 0;
                }
                if (primeLevel === 0 && !isInverse) {
                    // We didn't find primes or inverse, this could be a regular exponent
                    parser.index = start;
                    sup = parser.matchRequiredLatexArgument();
                }
                if (primeLevel === 0) {
                    // Do we have some primes (not in an exponent)
                    let done = false;
                    while (!done) {
                        parser.skipSpace();
                        if (parser.match('\\doubleprime'))
                            primeLevel += 2;
                        else if (parser.match('\\prime'))
                            primeLevel += 1;
                        else if (parser.match("'"))
                            primeLevel += 1;
                        else
                            done = true;
                    }
                }
            }
        }
        // Note: names as per NIST-DLMF
        let head = {
            '\\arcsin': 'Arcsin',
            '\\arccos': 'Arccos',
            '\\arctan': 'Arctan',
            '\\arctg': 'Arctan',
            '\\arcctg': 'Arctan',
            '\\arcsec': 'Arcsec',
            '\\arccsc': ' Arccsc',
            '\\arsinh': 'Arsinh',
            '\\arcosh': 'Arcosh',
            '\\artanh': 'Artanh',
            '\\arcsech': 'Arcsech',
            '\\arccsch': 'Arcsch',
            // '\\arg',
            '\\ch': 'Cosh',
            '\\cos': 'Cos',
            '\\cosec': 'Csc',
            '\\cosh': 'Csch',
            '\\cot': 'Cot',
            '\\cotg': 'Cot',
            '\\coth': 'Coth',
            '\\csc': 'Csc',
            '\\ctg': 'Cot',
            '\\cth': 'Coth',
            '\\sec': 'Sec',
            '\\sin': 'Sin',
            '\\sinh': 'Sinh',
            '\\sh': 'Sinh',
            '\\tan': 'Tan',
            '\\tanh': 'Tanh',
            '\\tg': 'Tan',
            '\\th': 'Tanh',
        }[op ?? ''] ??
            op ??
            '';
        if (isInverse)
            head = ['InverseFunction', head];
        if (primeLevel >= 1)
            head = ['Derivative', primeLevel, head];
        const args = parser.matchArguments('implicit');
        if (args === null)
            return sup ? [['Power', [head, '_'], sup]] : head;
        return sup ? ['Power', [head, ...args], sup] : [head, ...args];
    };
}
const DEFINITIONS_TRIGONOMETRY = [
    {
        name: 'Arcsin',
        trigger: ['\\arcsin'],
        parse: parseTrig('Arcsin'),
    },
    {
        name: 'Arccos',
        trigger: ['\\arccos'],
        parse: parseTrig('Arccos'),
    },
    {
        name: 'Arctan',
        trigger: ['\\arctan'],
        parse: parseTrig('Arctan'),
    },
    {
        trigger: ['\\arctg'],
        parse: parseTrig('Arctan'),
    },
    {
        name: 'Arccot',
        trigger: ['\\arcctg'],
        parse: parseTrig('Arccot'),
    },
    {
        name: 'Arcsec',
        trigger: 'arcsec',
        parse: parseTrig('Arcsec'),
    },
    {
        name: 'Arccsc',
        trigger: ['\\arccsc'],
        parse: parseTrig('Arccsc'),
    },
    {
        name: 'Arsinh',
        trigger: ['\\arsinh'],
        parse: parseTrig('Arsinh'),
    },
    {
        name: 'Arcosh',
        trigger: ['\\arcosh'],
        parse: parseTrig('Arcosh'),
    },
    {
        name: 'Artanh',
        trigger: ['\\artanh'],
        parse: parseTrig('Artanh'),
    },
    {
        name: 'Arsech',
        trigger: ['\\arsech'],
        parse: parseTrig('Arsech'),
    },
    {
        name: 'Arcsch',
        trigger: ['\\arcsch'],
        parse: parseTrig('Arcsch'),
    },
    {
        // Rusian hyperbolic cosine
        trigger: ['\\ch'],
        parse: parseTrig('Cosh'),
    },
    {
        name: 'Cosec',
        trigger: ['\\cosec'],
        parse: parseTrig('Cosec'),
    },
    {
        name: 'Cosh',
        trigger: ['\\cosh'],
        parse: parseTrig('Cosh'),
    },
    {
        name: 'Cot',
        trigger: ['\\cot'],
        parse: parseTrig('Cot'),
    },
    {
        trigger: ['\\cotg'],
        parse: parseTrig('Cot'),
    },
    {
        name: 'Coth',
        trigger: ['\\coth'],
        parse: parseTrig('Coth'),
    },
    {
        name: 'Csc',
        trigger: ['\\csc'],
        parse: parseTrig('Csc'),
    },
    {
        // Rusian cotangent
        trigger: ['\\ctg'],
        parse: parseTrig('Cot'),
    },
    {
        trigger: ['\\cth'],
        parse: parseTrig('Cotanh'),
    },
    {
        name: 'Sec',
        trigger: ['\\sec'],
        parse: parseTrig('Sec'),
    },
    {
        name: 'Sinh',
        trigger: ['\\sinh'],
        parse: parseTrig('Sinh'),
    },
    {
        trigger: ['\\sh'],
        parse: parseTrig('Sinh'),
    },
    {
        name: 'Tan',
        trigger: ['\\tan'],
        parse: parseTrig('Tan'),
    },
    {
        trigger: ['\\tg'],
        parse: parseTrig('Tan'),
    },
    {
        name: 'Tanh',
        trigger: ['\\tanh'],
        parse: parseTrig('Tanh'),
    },
    {
        trigger: ['\\th'],
        parse: parseTrig('Tanh'),
    },
    {
        name: 'Cos',
        trigger: ['\\cos'],
        parse: parseTrig('Cos'),
    },
    {
        name: 'Sin',
        trigger: ['\\sin'],
        parse: parseTrig('Sin'),
    },
];

const DEFINITIONS_SETS = [
    // Constants
    { name: 'AlgebraicNumber', trigger: '\\bar\\Q' },
    { name: 'ComplexNumber', trigger: ['\\C'] },
    { trigger: '\\mathbb{C}', parse: 'ComplexNumber' },
    { name: 'ImaginaryNumber', trigger: ['\\imaginaryI\\R'] },
    { name: 'ExtendedComplexNumber', trigger: ['\\bar\\C'] },
    { name: 'EmptySet', trigger: ['\\emptyset'] },
    { trigger: ['\\varnothing'], parse: 'EmptySet' },
    { name: 'Integer', trigger: ['\\Z'] },
    { trigger: '\\mathbb{Z}', parse: 'Integer' },
    { name: 'RationalNumber', trigger: ['\\Q'] },
    { name: 'RealNumber', trigger: ['\\R'] },
    { trigger: '\\mathbb{R}', parse: 'RealNumber' },
    { name: 'ExtendedRealNumber', trigger: ['\\bar\\R'] },
    { name: 'TranscendentalNumber', trigger: '\\R-\\bar\\Q' },
    { trigger: '\\R\\backslash\\bar\\Q', parse: 'TranscendentalNumber' },
    // Real numbers < 0
    { name: 'NegativeNumber', trigger: '\\R^-' },
    { trigger: '\\R^{-}', parse: 'NegativeNumber' },
    { trigger: '\\R_-', parse: 'NegativeNumber' },
    { trigger: '\\R_{-}', parse: 'NegativeNumber' },
    { trigger: '\\R^{\\lt}', parse: 'NegativeNumber' },
    // Real numbers > 0
    { name: 'PositiveNumber', trigger: '\\R^+' },
    { trigger: '\\R^{+}', parse: 'PositiveNumber' },
    { trigger: '\\R_+', parse: 'PositiveNumber' },
    { trigger: '\\R_{+}', parse: 'PositiveNumber' },
    { trigger: '\\R^{\\gt}', parse: 'PositiveNumber' },
    // Real numbers <= 0
    { name: 'NonPositiveNumber', trigger: '\\R^{0-}' },
    { trigger: '\\R^{-0}', parse: 'NonPositiveNumber' },
    { trigger: '\\R^{\\leq}', parse: 'NonPositiveNumber' },
    // Integers < 0
    { name: 'NegativeInteger', trigger: '\\Z^-' },
    { trigger: '\\Z^-', parse: 'NegativeInteger' },
    { trigger: '\\Z^{-}', parse: 'NegativeInteger' },
    { trigger: '\\Z_-', parse: 'NegativeInteger' },
    { trigger: '\\Z_{-}', parse: 'NegativeInteger' },
    { trigger: '\\Z^{\\lt}', parse: 'NegativeInteger' },
    // Integers >  0
    { name: 'PositiveInteger', trigger: '\\Z^+' },
    { trigger: '\\Z^{+}', parse: 'PositiveInteger' },
    { trigger: '\\Z_+', parse: 'PositiveInteger' },
    { trigger: '\\Z_{+}', parse: 'PositiveInteger' },
    { trigger: '\\Z^{\\gt}', parse: 'PositiveInteger' },
    { trigger: '\\Z^{\\gt0}', parse: 'PositiveInteger' },
    { trigger: '\\N^+', parse: 'PositiveInteger' },
    { trigger: '\\N^{+}', parse: 'PositiveInteger' },
    { trigger: '\\N^*', parse: 'PositiveInteger' },
    { trigger: '\\N^{*}', parse: 'PositiveInteger' },
    { trigger: '\\N^\\star', parse: 'PositiveInteger' },
    { trigger: '\\N^{\\star}', parse: 'PositiveInteger' },
    { trigger: '\\N_1', parse: 'PositiveInteger' },
    { trigger: '\\N_{1}', parse: 'PositiveInteger' },
    // Integers >=  0
    { name: 'NonNegativeInteger', trigger: ['\\N'] },
    { trigger: '\\Z^{+0}', parse: 'NonNegativeInteger' },
    { trigger: '\\Z^{\\geq}', parse: 'NonNegativeInteger' },
    { trigger: '\\Z^{\\geq0}', parse: 'NonNegativeInteger' },
    { trigger: '\\Z^{0+}', parse: 'NonNegativeInteger' },
    { trigger: '\\mathbb{N}', parse: 'NonNegativeInteger' },
    { trigger: '\\N_0', parse: 'NonNegativeInteger' },
    { trigger: '\\N_{0}', parse: 'NonNegativeInteger' },
    //
    // Set Expressions
    //
    // @todo: could also have a `CartesianPower` function with a number `rhs`
    {
        name: 'CartesianProduct',
        trigger: ['\\times'],
        kind: 'infix',
        associativity: 'right',
        precedence: 390,
        parse: (parser, until, lhs) => {
            if (390 < until.minPrec)
                return null;
            // Since this is triggered on `\times` we have to be careful we only
            // accept arguments that are `Set`
            const ce = parser.computeEngine;
            if (!ce || !ce.box(lhs).domain.isCompatible('Set'))
                return null;
            const index = parser.index;
            const rhs = parser.matchExpression({ ...until, minPrec: 390 });
            // If the rhs argument is not a set, bail
            if (rhs === null || ce.box(lhs).domain.isCompatible('Set') !== true) {
                parser.index = index;
                return null;
            }
            return ['CartesianProduct', lhs, rhs];
        },
    },
    {
        name: 'Complement',
        trigger: ['^', '\\complement'],
        kind: 'infix',
        // precedence: 240,
        // @todo: serialize for the multiple argument case
    },
    {
        name: 'Intersection',
        trigger: ['\\cap'],
        kind: 'infix',
        precedence: 350,
    },
    {
        name: 'Interval',
        // @todo: parse opening '[' or ']' or '('
        serialize: serializeSet,
    },
    {
        name: 'Multiple',
        // @todo: parse
        serialize: serializeSet,
    },
    {
        name: 'Union',
        trigger: ['\\cup'],
        kind: 'infix',
        precedence: 350,
    },
    {
        name: 'Range',
        // @todo: parse opening '[' or ']' or '('
        serialize: serializeSet,
    },
    // {
    //   name: 'Set',
    //   kind: 'matchfix',
    //   openDelimiter: '{',
    //   closeDelimiter: '}',
    //   precedence: 20,
    //   // @todo: the set syntax can also include conditions...
    // },
    {
        name: 'SetMinus',
        trigger: ['\\setminus'],
        kind: 'infix',
        precedence: 650,
    },
    {
        name: 'SymmetricDifference',
        trigger: ['\\triangle'],
        kind: 'infix',
        // @todo: parser could check that lhs and rhs are sets
        precedence: 260,
    },
    // Predicates/Relations
    {
        trigger: ['\\ni'],
        kind: 'infix',
        associativity: 'right',
        precedence: 160,
        parse: (parser, terminator, lhs) => {
            const rhs = parser.matchExpression(terminator);
            return rhs === null ? null : ['Element', rhs, lhs];
        },
    },
    {
        name: 'Element',
        trigger: ['\\in'],
        kind: 'infix',
        precedence: 240,
    },
    {
        name: 'NotElement',
        trigger: ['\\notin'],
        kind: 'infix',
        precedence: 240,
    },
    {
        name: 'NotSubset',
        trigger: ['\\nsubset'],
        kind: 'infix',
        associativity: 'right',
        precedence: 240,
    },
    {
        name: 'NotSuperset',
        trigger: ['\\nsupset'],
        kind: 'infix',
        associativity: 'right',
        precedence: 240,
    },
    {
        name: 'NotSubsetNotEqual',
        trigger: ['\\nsubseteq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 240,
    },
    {
        name: 'NotSupersetNotEqual',
        trigger: ['\\nsupseteq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 240,
    },
    {
        name: 'SquareSubset',
        trigger: ['\\sqsubset'],
        kind: 'infix',
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'SquareSubsetEqual',
        trigger: ['\\sqsubseteq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'SquareSuperset',
        trigger: ['\\sqsupset'],
        kind: 'infix',
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'SquareSupersetEqual',
        trigger: ['\\sqsupseteq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'Subset',
        trigger: ['\\subset'],
        kind: 'infix',
        associativity: 'right',
        precedence: 240,
    },
    {
        trigger: ['\\subsetneq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 240,
        parse: 'Subset',
    },
    {
        trigger: ['\\varsubsetneqq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 240,
        parse: 'Subset',
    },
    {
        name: 'SubsetEqual',
        trigger: ['\\subseteq'],
        kind: 'infix',
        precedence: 240,
    },
    {
        name: 'Superset',
        trigger: ['\\supset'],
        kind: 'infix',
        associativity: 'right',
        precedence: 240,
    },
    {
        trigger: ['\\supsetneq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 240,
        parse: 'Superset',
    },
    {
        trigger: ['\\varsupsetneq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 240,
        parse: 'Superset',
    },
    {
        name: 'SupersetEqual',
        trigger: ['\\supseteq'],
        kind: 'infix',
        associativity: 'right',
        precedence: 240,
    },
];
// Compact:     \R^*
// Regular       R \setminus { 0 }
// Interval     ]-\infty, 0( \union )0, \infty ]
// Set builder  { x \in \R | x \ne 0 }
// Serialize:
// - Set
// - Range
// - Interval
// - Multiple
// Note: does not serialize
// - Union
// - Intersection
// - SymmetricDifference
// - SetMinus
// - Complement
// - CartesianProduct
function serializeSet(serializer, expr) {
    if (expr === null)
        return '';
    const h = head(expr);
    if (h === null)
        return '';
    //
    // `Set`
    //
    if (h === 'Set') {
        if (nops(expr) === 0)
            return '\\emptyset';
        //
        // 1/ First variant: ["Set", <set | predicate>, ["Condition"]]
        //
        if (nops(expr) === 2 && head(op(expr, 2)) === 'Condition') {
            return joinLatex([
                '\\left\\lbrace',
                serializer.serialize(op(expr, 1)),
                '\\middle\\mid',
                serializer.serialize(op(expr, 2)),
                '\\right\\rbrace',
            ]);
        }
        //
        // 2/ 2nd variant: ["Set", ...<sequence>]
        //
        return joinLatex([
            '\\left\\lbrace',
            ...(ops(expr) ?? []).map((x) => serializer.serialize(x) + ' ,'),
            '\\right\\rbrace',
        ]);
    }
    //
    // `Range`
    //
    if (h === 'Range') {
        return joinLatex([
            '\\mathopen\\lbrack',
            serializer.serialize(op(expr, 1)),
            ', ',
            serializer.serialize(op(expr, 2)),
            '\\mathclose\\rbrack',
        ]);
    }
    //
    // `Range`
    //
    if (h === 'Interval') {
        let op1 = op(expr, 1);
        let op2 = op(expr, 2);
        let openLeft = false;
        let openRight = false;
        if (head(op1) === 'Open') {
            op1 = op(op1, 1);
            openLeft = true;
        }
        if (head(op2) === 'Open') {
            op2 = op(op2, 1);
            openRight = true;
        }
        return joinLatex([
            `\\mathopen${openLeft ? '\\rbrack' : '\\lbrack'}`,
            serializer.serialize(op1),
            ', ',
            serializer.serialize(op2),
            `\\mathclose${openRight ? '\\lbrack' : '\\rbrack'}`,
        ]);
    }
    // -----
    serializer.numericSetStyle(expr, serializer.level);
    return '';
}
// Return true if `["Set", 0]`
// function isZeroSet(expr: Expression): boolean {
//   return (
//     getFunctionName(expr) === 'Set' && getNumberValue(getArg(expr, 1)) === 0
//   );
// }
// | `NaturalNumber`
//| \\(= \mathbb{N}\\).
// Counting numbers, \\(0, 1, 2, 3\ldots\\)<br>Note that \\(0\\) is included, following the convention from [ISO/IEC 80000](https://en.wikipedia.org/wiki/ISO_80000-2)                                                                              |

// See https://de.wikipedia.org/wiki/Formelsatz
// for a discussion of typographical notation in Germany, Russia and France
// Also DIN 1304 (symbols in formulas) and DIN 1338 (typesetting of formulas)
// @todo: double integrals
function parseIntegral(command) {
    return (parser) => {
        parser.skipSpace();
        // Are there some superscript or subscripts?
        let sup = null;
        let sub = null;
        while (!(sub !== null && sup !== null) &&
            (parser.peek === '_' || parser.peek === '^')) {
            if (parser.match('_'))
                sub = parser.matchRequiredLatexArgument();
            else if (parser.match('^'))
                sup = parser.matchRequiredLatexArgument();
            parser.skipSpace();
        }
        if (sub === 'Nothing' || isEmptySequence(sub))
            sub = null;
        if (sup === 'Nothing' || isEmptySequence(sup))
            sup = null;
        // An integral expression is of the form `\int \sin(x)dx`: `\sin(x)` is
        // the `fn` and `x` is the index.
        // eslint-disable-next-line prefer-const
        let [fn, index] = parseIntegralBody(parser);
        if (fn && !index && (head(fn) === 'Add' || head(fn) === 'Subtract')) {
            // If the function is an addition, it could appear in any of the terms,
            // e.g. `\int \sin xdx + 1`
            const newOp = [];
            const rest = [];
            for (const op of ops(fn) ?? []) {
                if (index)
                    rest.push(op);
                else {
                    let op2;
                    [op2, index] = parseIntegralBodyExpression(op);
                    newOp.push(op2 ?? op);
                }
            }
            if (index !== null && rest.length > 0) {
                return [
                    'Add',
                    makeIntegral(parser, command, ['Add', ...newOp], index, sub, sup),
                    ...rest,
                ];
            }
        }
        return makeIntegral(parser, command, fn, index, sub, sup);
    };
}
function makeIntegral(parser, command, fn, index, sub, sup) {
    if (fn && sup === null && sub === null && !index)
        return [command, fn];
    fn ?? (fn = 'Nothing');
    if (parser.computeEngine) {
        const ce = parser.computeEngine;
        if (index)
            ce.pushScope({ [index]: { domain: 'ExtendedRealNumber' } });
        fn = ce.box(fn).json;
        if (index)
            ce.popScope();
    }
    const heldIndex = index ? ['Hold', index] : null;
    if (sup !== null)
        return [
            command,
            fn,
            ['Tuple', heldIndex ?? 'Nothing', sub ?? 'Nothing', sup],
        ];
    if (sub !== null)
        return [command, fn, ['Tuple', heldIndex ?? 'Nothing', sub]];
    if (heldIndex)
        return [command, fn, heldIndex];
    return [command, fn];
}
/**  Parse an expression (up to a relational operator, or the boundary) */
function parseIntegralBody(parser) {
    const start = parser.index;
    let found = false;
    let fn = parser.matchExpression({
        minPrec: 266,
        condition: () => {
            if (parser.matchAll(['\\mathrm', '<{>', 'd', '<}>']))
                found = true;
            return found;
        },
    });
    if (!found) {
        // Try again, but looking for a simple "d"
        parser.index = start;
        fn = parser.matchExpression({
            minPrec: 266,
            condition: () => {
                if (parser.match('d'))
                    found = true;
                return found;
            },
        });
    }
    // If we didn't get a `\mathrm{d}x` or `dx` at the same level as the
    // expression, perhaps it was in a subexpression, e.g. `\frac{dx}{x}`
    if (fn && !found)
        return parseIntegralBodyExpression(fn);
    return [fn, found ? symbol(parser.matchSymbol()) : null];
}
function parseIntegralBodyExpression(expr) {
    const h = head(expr);
    const op1 = op(expr, 1);
    if (!op1)
        return [expr, null];
    if (h === 'Multiply') {
        // Handle the case `3xdx` where the `dx` is the last term of a
        // multiplication (in a subexpression, i.e. `\sin 3xdx`)
        const args = ops(expr);
        if (args && args.length > 1) {
            if (symbol(args[args.length - 2]) === 'd') {
                if (args.length === 2)
                    return [null, symbol(args[1])];
                if (args.length === 3)
                    return [args[0], symbol(args[2])];
                return [
                    ['Multiply', ...args.slice(0, -2)],
                    symbol(args[args.length - 1]),
                ];
            }
            const [fn2, index] = parseIntegralBodyExpression(args[args.length - 1]);
            if (fn2)
                return [['Multiply', ...args.slice(0, -1), fn2], index];
        }
    }
    else if (h === 'Delimiter') {
        const [fn2, index] = parseIntegralBodyExpression(op1);
        if (index) {
            if (!fn2)
                return [null, index];
            return [['Delimiter', fn2, ...ops(expr).slice(1)], index];
        }
    }
    else if (h === 'Add') {
        const args = ops(expr);
        if (args && args.length > 0) {
            const [fn2, index] = parseIntegralBodyExpression(args[args.length - 1]);
            if (index) {
                if (fn2)
                    return [['Add', ...args.slice(0, -1), fn2], index];
                if (args.length > 2)
                    return [['Add', ...args.slice(0, -1)], index];
                if (args.length > 2)
                    return [args[0], index];
            }
        }
    }
    else if (h === 'Negate') {
        const [fn2, index] = parseIntegralBodyExpression(op1);
        if (index)
            return [fn2 ? ['Negate', fn2] : null, index];
    }
    else if (h === 'Divide') {
        const [fn2, index] = parseIntegralBodyExpression(op1);
        if (index)
            return [['Divide', fn2 ?? 1, op(expr, 2)], index];
    }
    else {
        // Some other function, e.g. trig function, etc...
        const args = ops(expr);
        if (args?.length === 1) {
            //If it has a single argument, we'll check if it includes an index
            // e.g. \sin 2xdx
            const [arg2, index] = parseIntegralBodyExpression(args[0]);
            if (index)
                return [[head(expr), arg2], index];
        }
    }
    return [expr, null];
}
function serializeIntegral(command) {
    return (serializer, expr) => {
        if (!op(expr, 1))
            return command;
        let arg = op(expr, 2);
        const h = head(arg);
        let index = null;
        if (h !== 'Tuple' && h !== 'Triple' && h !== 'Pair' && h !== 'Single') {
            index = symbol(arg);
            arg = null;
        }
        else
            index = symbol(op(arg, 1)) ?? 'x';
        let fn = op(expr, 1);
        if (head(fn) === 'Lambda' && op(fn, 1))
            fn = subs(op(fn, 1), { _: index ?? 'x', _1: index ?? 'x' });
        if (!arg) {
            if (!index)
                return joinLatex([command, serializer.serialize(fn)]);
            return joinLatex([
                command,
                serializer.serialize(fn),
                '\\mathrm{d}',
                index,
            ]);
        }
        let sub = arg ? [serializer.serialize(op(arg, 2))] : [];
        if (sub.length > 0)
            sub = ['_{', ...sub, '}'];
        let sup = [];
        if (op(arg, 3))
            sup = ['^{', serializer.serialize(op(arg, 3)), '}'];
        return joinLatex([
            command,
            ...sup,
            ...sub,
            serializer.serialize(fn),
            ...(index && symbol(index) !== 'Nothing'
                ? ['\\,\\mathrm{d}', serializer.serialize(index)]
                : []),
        ]);
    };
}
const DEFINITIONS_CALCULUS = [
    {
        name: 'Integrate',
        trigger: ['\\int'],
        parse: parseIntegral('Integrate'),
        serialize: serializeIntegral('\\int'),
    },
    {
        trigger: ['\\iint'],
        parse: parseIntegral('Integrate'),
    },
    {
        name: 'CircularIntegrate',
        trigger: ['\\oint'],
        parse: parseIntegral('CircularIntegrate'),
        serialize: serializeIntegral('\\oint'),
    },
];

const SYMBOLS = [
    // Greek
    ['Alpha', '\\alpha', 0x03b1],
    ['Beta', '\\beta', 0x03b2],
    ['Gamma', '\\gamma', 0x03b3],
    ['Delta', '\\delta', 0x03b4],
    ['Epsilon', '\\epsilon', 0x03b5],
    ['EpsilonSymbol', '\\varepsilon', 0x03f5],
    ['Zeta', '\\zeta', 0x03b6],
    ['Eta', '\\eta', 0x03b7],
    ['Theta', '\\theta', 0x03b8],
    ['ThetaSymbol', '\\vartheta', 0x03d1],
    ['Iota', '\\iota', 0x03b9],
    ['Kappa', '\\kappa', 0x03ba],
    ['KappaSymbol', '\\varkappa', 0x03f0],
    ['Lambda', '\\lambda', 0x03bb],
    ['Mu', '\\mu', 0x03bc],
    ['Nu', '\\nu', 0x03bd],
    ['Xi', '\\xi', 0x03be],
    ['Omicron', '\\omicron', 0x03bf],
    // ['', '\\pi', 0x03c0],
    ['PiSymbol', '\\varpi', 0x03d6],
    ['Rho', '\\rho', 0x03c1],
    ['RhoSymbol', '\\varrho', 0x03f1],
    ['Sigma', '\\sigma', 0x03c3],
    ['FinalSigma', '\\varsigma', 0x03c2],
    ['Tau', '\\tau', 0x03c4],
    ['Phi', '\\phi', 0x03d5],
    ['PhiLetter', '\\varphi', 0x03c6],
    ['Upsilon', '\\upsilon', 0x03c5],
    ['Chi', '\\chi', 0x03c7],
    ['Psi', '\\psi', 0x03c8],
    ['Omega', '\\omega', 0x03c9],
    ['CapitalAlpha', '\\Alpha', 0x0391],
    ['CapitalBeta', '\\Beta', 0x0392],
    ['CapitalGamma', '\\Gamma', 0x0393],
    ['CapitalDelta', '\\Delta', 0x0394],
    ['CapitalEpsilon', '\\Epsilon', 0x0395],
    ['CapitalZeta', '\\Zeta', 0x0396],
    ['CapitalEta', '\\Eta', 0x0397],
    ['CapitalTheta', '\\Theta', 0x0398],
    ['CapitaIota', '\\Iota', 0x0399],
    ['CapitalKappa', '\\Kappa', 0x039a],
    ['CapitalLambda', '\\Lambda', 0x039b],
    ['CapitalMu', '\\Mu', 0x039c],
    ['CapitalNu', '\\Nu', 0x039d],
    ['CapitalXi', '\\Xi', 0x039e],
    ['CapitalOmicron', '\\Omicron', 0x039f],
    ['CapitalPi', '\\Pi', 0x03a0],
    ['CapitalRho', '\\Rho', 0x03a1],
    ['CapitalSigma', '\\Sigma', 0x03a3],
    ['CapitalTau', '\\Tau', 0x03a4],
    ['CapitalPhi', '\\Phi', 0x03a6],
    ['CapitalUpsilon', '\\Upsilon', 0x03a5],
    ['CapitalChi', '\\Chi', 0x03a7],
    ['CapitalPsi', '\\Psi', 0x03a8],
    ['CapitalOmega', '\\Omega', 0x03a9],
    ['Digamma', '\\digamma', 0x03dd],
    // Hebrew
    ['Alef', '\\aleph', 0x2135],
    ['Bet', '\\beth', 0x2136],
    ['Gimel', '\\gimel', 0x2137],
    ['Dalet', '\\daleth', 0x2138],
    // Letter-like
    ['TurnedCapitalF', '\\Finv', 0x2132],
    ['TurnedCapitalG', '\\Game', 0x2141],
    ['Weierstrass', '\\wp', 0x2118],
    ['Eth', '\\eth', 0x00f0],
    ['InvertedOhm', '\\mho', 0x2127],
    // Symbols
    ['BlackClubSuit', '\\clubsuit', 0x2663],
    ['WhiteHeartSuit', '\\heartsuit', 0x2661],
    ['BlackSpadeSuit', '\\spadesuit', 0x2660],
    ['WhiteDiamondSuit', '\\diamondsuit', 0x2662],
    ['Sharp', '\\sharp', 0x266f],
    ['Flat', '\\flat', 0x266d],
    ['Natural', '\\natural', 0x266e],
];
const DEFINITIONS_SYMBOLS = [
    ...SYMBOLS.map(([symbol, latex, _codepoint]) => {
        return {
            name: symbol,
            trigger: [latex],
            parse: symbol,
        };
    }),
    ...SYMBOLS.map(([symbol, _latex, codepoint]) => {
        return {
            trigger: [String.fromCodePoint(codepoint)],
            parse: symbol,
        };
    }),
];

const DEFAULT_DELIMITER = {
    '(': '(',
    ')': ')',
    '[': '\\lbrack',
    ']': '\\rbrack',
    '{': '\\lbrace',
    '}': '\\rbrace',
    '<': '\\langle',
    '>': '\\rangle',
    '|': '\\vert',
    '||': '\\Vert',
    '\\lceil': '\\lceil',
    '\\lfloor': '\\lfloor',
    '\\rceil': '\\rceil',
    '\\rfloor': '\\rfloor',
};
function triggerLength(trigger) {
    if (Array.isArray(trigger))
        return trigger.length;
    return 1;
}
function indexLatexDictionary(dic, onError) {
    const result = {
        lookahead: 1,
        name: new Map(),
        function: new Map(),
        symbol: [],
        infix: [],
        prefix: [],
        postfix: [],
        environment: new Map(),
        matchfix: [],
    };
    for (const entry of dic) {
        //
        // 1. Create a validated indexed entry
        //
        const [trigger, indexedEntry] = makeIndexedEntry(entry, onError);
        if (indexedEntry === null)
            continue;
        //
        // 2. Update the name index
        //
        if (indexedEntry.name !== undefined) {
            if (result.name.has(indexedEntry.name)) {
                onError({
                    severity: 'warning',
                    message: [
                        'invalid-dictionary-entry',
                        indexedEntry.name,
                        'Duplicate definition',
                    ],
                });
            }
            result.name.set(indexedEntry.name, indexedEntry);
        }
        if (indexedEntry.kind === 'matchfix') {
            //
            // 3.1/ Update the matchfix index
            result.matchfix.push(indexedEntry);
            //
        }
        else if (indexedEntry.kind === 'environment') {
            //
            // 3.1/ Update the environment index
            //
            const triggerString = tokensToString(entry.trigger ?? '');
            if (result.environment.has(triggerString)) {
                onError({
                    severity: 'warning',
                    message: [
                        'invalid-dictionary-entry',
                        triggerString,
                        'Duplicate environment definition',
                    ],
                });
            }
            result.environment.set(triggerString, indexedEntry);
        }
        else if (trigger) {
            //
            // 3.3/ Update the other symbol or operator index
            //
            console.assert(entry.trigger);
            const triggerString = tokensToString(entry.trigger ?? '');
            const n = triggerLength(trigger);
            result.lookahead = Math.max(result.lookahead, n);
            if (indexedEntry.kind === 'function') {
                // If no entries of this kind and length yet, create a map for it
                if (!result.function.has(triggerString))
                    result.function.set(triggerString, [indexedEntry]);
                else
                    result.function.set(triggerString, [
                        ...result.function.get(triggerString),
                        indexedEntry,
                    ]);
            }
            else if (indexedEntry.kind === 'symbol') {
                // If no entries of this kind and length yet, create a map for it
                if (result.symbol[n] === undefined)
                    result.symbol[n] = new Map();
                const list = result.symbol[n];
                if (list.has(triggerString))
                    list.get(triggerString).push(indexedEntry);
                else
                    list.set(triggerString, [indexedEntry]);
            }
            else if (indexedEntry.kind === 'prefix') {
                if (result.prefix[n] === undefined)
                    result.prefix[n] = new Map();
                const list = result.prefix[n];
                if (list.has(triggerString))
                    list.get(triggerString).push(indexedEntry);
                else
                    list.set(triggerString, [indexedEntry]);
            }
            else if (indexedEntry.kind === 'infix') {
                if (result.infix[n] === undefined)
                    result.infix[n] = new Map();
                const list = result.infix[n];
                if (list.has(triggerString))
                    list.get(triggerString).push(indexedEntry);
                else
                    list.set(triggerString, [indexedEntry]);
            }
            else if (indexedEntry.kind === 'postfix') {
                if (result.postfix[n] === undefined)
                    result.postfix[n] = new Map();
                const list = result.postfix[n];
                if (list.has(triggerString))
                    list.get(triggerString).push(indexedEntry);
                else
                    list.set(triggerString, [indexedEntry]);
            }
        }
    }
    return result;
}
function makeIndexedEntry(entry, onError) {
    if (!entryIsValid(entry, onError))
        return [null, null];
    const result = {
        name: entry.name,
        kind: 'kind' in entry ? entry.kind : 'symbol',
    };
    //
    // 1. Handle matchfix definition
    //
    if (result.kind === 'matchfix' && isMatchfixEntry(entry)) {
        result.openDelimiter = entry.openDelimiter;
        result.closeDelimiter = entry.closeDelimiter;
        // @todo: use groupStyle to decide on \left..\right, etc..
        if (typeof entry.serialize === 'function')
            result.serialize = entry.serialize;
        else {
            const openDelim = typeof result.openDelimiter === 'string'
                ? DEFAULT_DELIMITER[result.openDelimiter]
                : tokensToString(result.openDelimiter);
            const closeDelim = typeof result.closeDelimiter === 'string'
                ? DEFAULT_DELIMITER[result.closeDelimiter]
                : tokensToString(result.closeDelimiter);
            result.serialize = (serializer, expr) => joinLatex([openDelim, serializer.serialize(op(expr, 1)), closeDelim]);
        }
        if (typeof entry.parse === 'function')
            result.parse = entry.parse;
        else {
            console.assert(entry.parse || entry.name);
            const head = entry.parse ?? entry.name;
            result.parse = (_parser, expr) => [head, expr];
        }
        return [null, result];
    }
    //
    // 2. Environment definitions
    //
    if (result.kind === 'environment' && isEnvironmentEntry(entry)) {
        const envName = entry.trigger;
        result.serialize =
            entry.serialize ??
                ((serializer, expr) => `\\begin{${envName}}${serializer.serialize(op(expr, 1))}\\end{${envName}}`);
        result.parse = entry.parse ?? (() => null);
        return [envName, result];
    }
    // If the trigger is a string, it's a LaTeX string which
    // is a shortcut for an array of LaTeX tokens assigned to `symbol`
    // This is convenient to define common long symbols, such as `\operator{gcd}`...
    const trigger = typeof entry.trigger === 'string'
        ? tokenize(entry.trigger, [])
        : entry.trigger;
    const triggerString = trigger ? tokensToString(trigger) : '';
    //
    // 3. Function
    //
    if (result.kind === 'function' && isFunctionEntry(entry)) {
        // Default serializer for functions
        result.serialize = entry.serialize;
        if (triggerString && !entry.serialize)
            result.serialize = (serializer, expr) => `\\mathrm{${triggerString}}${serializer.wrapArguments(expr)}`;
        result.parse = entry.parse;
        if (!result.parse && entry.name)
            result.parse = ((parser) => {
                const arg = parser.matchArguments('enclosure');
                return arg === null ? entry.name : [entry.name, ...arg];
            });
        return [triggerString, result];
    }
    //
    // 4. Other definitions (not matchfix, not environment)
    //
    if (typeof entry.trigger === 'string') {
        console.assert(entry.parse || trigger.length > 1, `Trigger shortcut should produce more than one token. Otherwise, not worth using the shortcut. (${triggerString})`);
    }
    if (result.kind === 'symbol' && isSymbolEntry(entry)) {
        result.precedence = entry.precedence ?? 10000;
    }
    //
    // Special case for ^ and _
    //
    if ((result.kind === 'infix' ||
        result.kind === 'prefix' ||
        result.kind === 'postfix') &&
        (isInfixEntry(entry) || isPrefixEntry(entry) || isPostfixEntry(entry))) {
        if (trigger && (trigger[0] === '^' || trigger[0] === '_'))
            result.precedence = 720;
        else
            result.precedence = entry.precedence ?? 10000;
    }
    if (result.kind === 'infix' && isInfixEntry(entry)) {
        console.assert(!trigger ||
            (trigger[0] !== '^' && trigger[0] !== '_') ||
            !entry.associativity ||
            entry.associativity === 'non');
        result.associativity = entry.associativity ?? 'non';
        if (typeof entry.parse === 'function') {
            //
            // Use a custom parse handler
            //
            result.parse = entry.parse;
        }
        else if (trigger && (trigger[0] === '^' || trigger[0] === '_')) {
            //
            // No custom parse handler allowed for ^ and _
            //
            console.assert(!entry.parse);
            const name = entry.parse ?? entry.name;
            result.parse = (_scanner, _terminator, arg) => [
                name,
                missingIfEmpty(op(arg, 1)),
                missingIfEmpty(op(arg, 2)),
            ];
        }
        else {
            //
            // Default parse function for infix operator
            //
            const head = entry.parse ?? entry.name;
            const prec = result.precedence;
            const associativity = result.associativity;
            result.parse = (scanner, terminator, lhs) => {
                // If the precedence is too high, return
                if (prec < terminator.minPrec)
                    return null; // @todo should not be needed
                // Get the rhs
                // Note: for infix operators, we are lenient and tolerate
                // a missing rhs.
                // This is because it is unlikely to be an ambiguous parse
                // (i.e. `x+`) and more likely to be a syntax error we want to
                // capture as `['Add', 'x', ['Error', "'missing'"]`.
                const rhs = missingIfEmpty(scanner.matchExpression({
                    ...terminator,
                    minPrec: prec,
                }));
                return typeof head === 'string'
                    ? applyAssociativeOperator(head, lhs, rhs, associativity)
                    : [head, lhs, rhs];
            };
        }
    }
    else {
        if (typeof entry.parse === 'function') {
            //
            // Custom parse handler
            //
            result.parse = entry.parse;
        }
        else if (entry.parse !== undefined) {
            //
            // Parse handler as an expression
            //
            console.assert(result.kind === 'symbol');
            result.parse = () => entry.parse;
        }
        else if (entry.parse === undefined && entry.name !== undefined) {
            //
            // Default parse handler
            //
            // By default, when a LaTeX string triggers, the generated
            // output is the name of this record, i.e. 'Multiply'
            if (result.kind === 'postfix') {
                result.parse = (_parser, lhs) => (lhs ? [entry.name, lhs] : null);
            }
            else if (result.kind === 'prefix') {
                const prec = result.precedence;
                console.assert(entry.name);
                const head = entry.name;
                result.parse = (parser, terminator) => {
                    // If the precedence is too high, return
                    if (prec < terminator.minPrec)
                        return null;
                    // Get the rhs
                    const rhs = parser.matchExpression({ ...terminator, minPrec: prec });
                    return rhs === null ? null : [head, rhs];
                };
            }
        }
    }
    //
    // Serializer
    //
    if (typeof entry.serialize === 'function' ||
        typeof entry.serialize === 'string') {
        result.serialize = entry.serialize;
    }
    else if (trigger) {
        // By default, when LaTeX is serialized for this record,
        // it is the same as the trigger
        if (result.kind === 'postfix') {
            result.serialize = '#1' + triggerString;
        }
        else if (result.kind === 'prefix') {
            result.serialize = triggerString + '#1';
        }
        else if (result.kind === 'infix') {
            result.serialize = '#1' + triggerString + '#2';
        }
        else if (result.kind === 'symbol') {
            result.serialize = triggerString;
        }
        else {
            result.serialize = '';
        }
    }
    return [trigger ?? null, result];
}
function entryIsValid(entry, onError) {
    const subject = entry.name ?? entry.trigger ?? entry['openDelimiter'];
    if (entry.serialize !== undefined && !entry.name) {
        onError({
            severity: 'warning',
            message: [
                'invalid-dictionary-entry',
                subject,
                `Unexpected serialize property without a name property`,
            ],
        });
        return false;
    }
    //
    // Check specific to `matchfix`
    //
    if (isMatchfixEntry(entry)) {
        if (entry.trigger) {
            onError({
                severity: 'warning',
                message: [
                    'invalid-dictionary-entry',
                    subject,
                    `Unexpected 'trigger' "${entry.trigger}". 'matchfix' operators use a 'openDelimiter' and 'closeDelimiter' instead of a trigger. `,
                ],
            });
            return false;
        }
        if (!entry.openDelimiter || !entry.closeDelimiter) {
            onError({
                severity: 'warning',
                message: [
                    'invalid-dictionary-entry',
                    subject,
                    'Expected `openDelimiter` and a `closeDelimiter` for matchfix operator',
                ],
            });
            return false;
        }
        if (typeof entry.openDelimiter !== typeof entry.closeDelimiter) {
            onError({
                severity: 'warning',
                message: [
                    'invalid-dictionary-entry',
                    subject,
                    'Expected `openDelimiter` and `closeDelimiter` to both be strings or array of LatexToken',
                ],
            });
            return false;
        }
    }
    //
    // Check for infix, postfix and prefix
    //
    if (isInfixEntry(entry) || isPostfixEntry(entry) || isPrefixEntry(entry)) {
        if ((Array.isArray(entry.trigger) &&
            (entry.trigger[0] === '_' || entry.trigger[0] === '^')) ||
            (typeof entry.trigger === 'string' &&
                (entry.trigger.startsWith('^') || entry.trigger.startsWith('_')))) {
            if (entry.precedence !== undefined ||
                entry['associativity'] !== undefined) {
                onError({
                    severity: 'warning',
                    message: [
                        'invalid-dictionary-entry',
                        subject,
                        `Unexpected "precedence" or "associativity" for superscript/subscript operator`,
                    ],
                });
                return false;
            }
        }
        else if (entry.precedence === undefined) {
            onError({
                severity: 'warning',
                message: [
                    'invalid-dictionary-entry',
                    subject,
                    `Expected a "precedence" for ${entry.kind} operator`,
                ],
            });
            return false;
        }
    }
    else {
        //
        // Check for symbols
        //
        // Note symbols can have a precedence (used for wrapping, e.g. 'Complex')
        if (entry['associativity'] !== undefined) {
            onError({
                severity: 'warning',
                message: [
                    'invalid-dictionary-entry',
                    subject,
                    'Unexpected "associativity" operator',
                ],
            });
            return false;
        }
    }
    if (!isMatchfixEntry(entry)) {
        if (!entry.trigger && !entry.name) {
            // A trigger OR a name is required (except for matchfix)
            // The trigger maps LaTeX -> json
            // The name maps json -> LaTeX
            onError({
                severity: 'warning',
                message: [
                    'invalid-dictionary-entry',
                    subject,
                    `Expected at least a 'trigger' or a 'name'`,
                ],
            });
            return false;
        }
    }
    if (entry['parse'] === undefined && entry.name === undefined) {
        onError({
            severity: 'warning',
            message: [
                'invalid-dictionary-entry',
                subject,
                `Expected a 'parse' or 'name'`,
            ],
        });
        return false;
    }
    return true;
}
// left-operators, supfix/subfix:
// subscript
// sub-plus     super-plus
// sub-minus    super-minus
// sub-star     super-star
//              super-dagger
// over-bar     under-bar
// over-vector
// over-tilde
// over-hat
// over-dot
// overscript   underscript
// matchfix:
// angle-brack
// floor
// ceiling
// infix operators:
//->   rule
// :>   rule-delayed
// ==   eq
// !=   ne
// https://reference.wolfram.com/language/tutorial/OperatorInputForms.html
const DEFAULT_LATEX_DICTIONARY = {
    algebra: DEFINITIONS_ALGEBRA,
    arithmetic: DEFINITIONS_ARITHMETIC,
    calculus: DEFINITIONS_CALCULUS,
    core: DEFINITIONS_CORE,
    logic: DEFINITIONS_LOGIC,
    relop: DEFINITIONS_INEQUALITIES,
    other: DEFINITIONS_OTHERS,
    physics: [
        {
            name: 'mu-0',
            trigger: '\\mu_0',
        },
    ],
    sets: DEFINITIONS_SETS,
    symbols: DEFINITIONS_SYMBOLS,
    trigonometry: DEFINITIONS_TRIGONOMETRY,
};

/* eslint-disable no-empty */
/** These delimiters can be used as 'shorthand' delimiters in
 * `openDelimiter` and `closeDelimiter` for `matchfix` operators.
 */
const DELIMITER_SHORTHAND = {
    '(': ['\\lparen', '('],
    ')': ['\\rparen', ')'],
    '[': ['\\lbrack'],
    ']': ['\\rbrack'],
    '<': ['<', '\\langle'],
    '>': ['>', '\\rangle'],
    '{': ['\\{', '\\lbrace'],
    '}': ['\\}', '\\rbrace'],
    ':': [':', '\\colon'],
    '|': ['|', '\\|', '\\lvert', '\\rvert'],
    '||': ['||', '\\Vert', '\\lVert', '\\rVert'],
    '\\lfloor': ['\\lfloor'],
    '\\rfloor': ['\\rfloor'],
    '\\lceil': ['\\lceil'],
    '\\rceil': ['\\rceil'],
    '\\ulcorner': ['\\ulcorner'],
    '\\urcorner': ['\\urcorner'],
    '\\llcorner': ['\\llcorner'],
    '\\lrcorner': ['\\lrcorner'],
    '\\lgroup': ['\\lgroup'],
    '\\rgroup': ['\\rgroup'],
    '\\lmoustache': ['\\lmoustache'],
    '\\rmoustache': ['\\rmoustache'],
};
const MIDDLE_DELIMITER = {
    ':': [':', '\\colon'],
    '|': ['|', '\\|', '\\mid', '\\mvert'],
};
/** Commands that can be used with an open delimiter, and their corresponding
 * closing commands.
 */
const OPEN_DELIMITER_PREFIX = {
    '\\left': '\\right',
    '\\bigl': '\\bigr',
    '\\Bigl': '\\Bigr',
    '\\biggl': '\\biggr',
    '\\Biggl': '\\Biggr',
    '\\big': '\\big',
    '\\Big': '\\Big',
    '\\bigg': '\\bigg',
    '\\Bigg': '\\Bigg',
};
/** Commands that can be used with a middle delimiter */
const MIDDLE_DELIMITER_PREFIX = [
    '\\middle',
    '\\bigm',
    '\\Bigm',
    '\\biggm',
    '\\Biggm',
    '\\big',
    '\\Big',
    '\\bigg',
    '\\Bigg',
];
/**
 * Map open delimiters to a matching close delimiter
 */
const CLOSE_DELIMITER = {
    '(': ')',
    '[': ']',
    '\\{': '\\}',
    '\\lbrace': '\\rbrace',
    '\\lparen': '\\rparen',
    '\\langle': '\\rangle',
    '\\lfloor': '\\rfloor',
    '\\lceil': '\\rceil',
    '\\vert': '\\vert',
    '\\lvert': '\\rvert',
    '\\Vert': '\\Vert',
    '\\lVert': '\\rVert',
    '\\lbrack': '\\rbrack',
    '\\ulcorner': '\\urcorner',
    '\\llcorner': '\\lrcorner',
    '\\lgroup': '\\rgroup',
    '\\lmoustache': '\\rmoustache',
};
const DEFAULT_LATEX_NUMBER_OPTIONS = {
    precision: 6,
    positiveInfinity: '\\infty',
    negativeInfinity: '-\\infty',
    notANumber: '\\operatorname{NaN}',
    decimalMarker: '.',
    groupSeparator: '\\,',
    exponentProduct: '\\cdot',
    beginExponentMarker: '10^{',
    endExponentMarker: '}',
    notation: 'auto',
    truncationMarker: '\\ldots',
    beginRepeatingDigits: '\\overline{',
    endRepeatingDigits: '}',
    imaginaryUnit: '\\imaginaryI',
    avoidExponentsInRange: [-7, 20],
};
const DEFAULT_PARSE_LATEX_OPTIONS = {
    applyInvisibleOperator: 'auto',
    skipSpace: true,
    parseArgumentsOfUnknownLatexCommands: true,
    parseNumbers: true,
    parseUnknownIdentifier: (s, parser) => {
        if (parser.computeEngine?.lookupFunction(s) !== undefined)
            return 'function';
        if (/^[a-zA-Z]/.test(s))
            return 'symbol';
        return 'unknown';
    },
    preserveLatex: false,
};
class _Parser {
    constructor(tokens, options, dictionary, computeEngine) {
        this.index = 0;
        // A parsing boundary is a sequence of tokens that indicate that a
        // recursive parsing operation should stop.
        // In a traditional parser, keeping track of parsing boundaries would
        // not be necessary. However, because we attempt to deliver the best
        // interpretation of a partial expression, boundaries allow us to fail
        // parsing more locally.
        // For example, in `\begin{cases} | \end{cases}`, without boundary
        // detection, the parsing of `|` would attempt to goble up `\end{cases}`
        // which would be interpreted as an unexpected command, and the whole `\begin`
        // would be rejected as an unbalanced environment. With `\end{cases}` as a
        // boundary, the parsing of the `|` argument stops as soon as it encounters
        // the `\end{cases}` and can properly report an unexpected toke on the `|`
        // only while correctly interpreting the `\begin{cases}...\end{cases}`
        this._boundaries = [];
        // Those two properties are used to detect infinite loops while parsing
        this._lastPeek = '';
        this._peekCounter = 0;
        this._tokens = tokens;
        this.options = {
            ...DEFAULT_LATEX_NUMBER_OPTIONS,
            ...DEFAULT_PARSE_LATEX_OPTIONS,
            ...options,
        };
        this._dictionary = dictionary;
        this.computeEngine = computeEngine;
        this._positiveInfinityTokens = tokenize(this.options.positiveInfinity, []);
        this._negativeInfinityTokens = tokenize(this.options.negativeInfinity, []);
        this._notANumberTokens = tokenize(this.options.notANumber, []);
        this._decimalMarkerTokens = tokenize(this.options.decimalMarker, []);
        this._groupSeparatorTokens = tokenize(this.options.groupSeparator, []);
        this._exponentProductTokens = tokenize(this.options.exponentProduct, []);
        this._beginExponentMarkerTokens = tokenize(this.options.beginExponentMarker, []);
        this._endExponentMarkerTokens = tokenize(this.options.endExponentMarker, []);
        this._truncationMarkerTokens = tokenize(this.options.truncationMarker, []);
        this._beginRepeatingDigitsTokens = tokenize(this.options.beginRepeatingDigits, []);
        this._endRepeatingDigitsTokens = tokenize(this.options.endRepeatingDigits, []);
        this._imaginaryNumberTokens = tokenize(this.options.imaginaryUnit, []);
    }
    updateOptions(opt) {
        for (const [k, v] of Object.entries(opt))
            if (k in this.options) {
                this.options[k] = v;
                if (typeof v === 'string') {
                    if (k === 'positiveInfinity')
                        this._positiveInfinityTokens = tokenize(v, []);
                    if (k === 'negativeInfinity')
                        this._negativeInfinityTokens = tokenize(v, []);
                    if (k === 'notANumber')
                        this._notANumberTokens = tokenize(v, []);
                    if (k === 'decimalMarker')
                        this._decimalMarkerTokens = tokenize(v, []);
                    if (k === 'groupSeparator')
                        this._groupSeparatorTokens = tokenize(v, []);
                    if (k === 'exponentProduct')
                        this._exponentProductTokens = tokenize(v, []);
                    if (k === 'beginExponentMarker')
                        this._beginExponentMarkerTokens = tokenize(v, []);
                    if (k === 'endExponentMarker')
                        this._endExponentMarkerTokens = tokenize(v, []);
                    if (k === 'truncationMarker')
                        this._truncationMarkerTokens = tokenize(v, []);
                    if (k === 'beginRepeatingDigits')
                        this._beginRepeatingDigitsTokens = tokenize(v, []);
                    if (k === 'endRepeatingDigits')
                        this._endRepeatingDigitsTokens = tokenize(v, []);
                    if (k === 'imaginaryNumber')
                        this._imaginaryNumberTokens = tokenize(v, []);
                }
            }
            else
                throw Error(`Unexpected option "${k}"`);
    }
    get atEnd() {
        return this.index >= this._tokens.length;
    }
    get peek() {
        const peek = this._tokens[this.index];
        if (peek === this._lastPeek)
            this._peekCounter += 1;
        else
            this._peekCounter = 0;
        if (this._peekCounter >= 1024) {
            console.error(`Infinite loop detected while parsing "${this.latex(0)}" at "${this._lastPeek}" (index ${this.index})`);
            throw new Error(`Infinite loop detected while parsing "${this.latex(0)}" at ${this._lastPeek} (index ${this.index})`);
        }
        this._lastPeek = peek;
        return peek;
    }
    next() {
        return this._tokens[this.index++];
    }
    /**
     * Return true if
     * - at end of the token stream
     * - the upcoming tokens match `t.tokens`
     * - the `t.condition` function returns true
     * Note: the `minPrec` condition is not checked. It should be checked separately.
     */
    atTerminator(t) {
        if (this.atBoundary)
            return true;
        if (t?.condition && t.condition(this))
            return true;
        return false;
    }
    /** True if the current token matches any of the boundaries we are waiting for */
    get atBoundary() {
        if (this.atEnd)
            return true;
        const start = this.index;
        for (const boundary of this._boundaries) {
            if (this.matchAll(boundary.tokens)) {
                this.index = start;
                return true;
            }
        }
        return false;
    }
    addBoundary(boundary) {
        this._boundaries.push({ index: this.index, tokens: boundary });
    }
    removeBoundary() {
        this._boundaries.pop();
    }
    matchBoundary() {
        const currentBoundary = this._boundaries[this._boundaries.length - 1];
        const match = currentBoundary && this.matchAll(currentBoundary.tokens);
        if (match)
            this._boundaries.pop();
        return match;
    }
    boundaryError(msg) {
        const currentBoundary = this._boundaries[this._boundaries.length - 1];
        this._boundaries.pop();
        return this.error(msg, currentBoundary.index);
    }
    latex(start, end) {
        return tokensToString(this._tokens.slice(start, end));
    }
    latexAhead(n) {
        return this.latex(this.index, this.index + n);
    }
    latexBefore() {
        return this.latex(0, this.index);
    }
    latexAfter() {
        return this.latex(this.index);
    }
    /**
     * Return at most `this._dictionary.lookahead` strings made from the tokens
     * ahead.
     *
     * The index in the returned array correspond to the number of tokens.
     * Note that since a token can be longer than one char ('\\pi', but also
     * some astral plane unicode characters), the length of the string
     * does not match that index. However, knowing the index is important
     * to know by how many tokens to advance.
     *
     */
    lookAhead() {
        let n = Math.min(this._dictionary.lookahead, this._tokens.length - this.index);
        if (n < 0)
            return [];
        const result = Array(n + 1);
        while (n > 0)
            result[n] = this.latexAhead(n--);
        return result;
    }
    peekDefinitions(kind) {
        let defs;
        if (kind === 'function') {
            const start = this.index;
            if (this.match('\\operatorname') ||
                this.match('\\mathrm') ||
                this.match('\\mathit')) {
                const fn = this.matchStringArgument();
                const n = this.index - start;
                this.index = start;
                if (fn !== null && this._dictionary.function.has(fn))
                    return this._dictionary.function.get(fn).map((x) => [x, n]);
                return null;
            }
            return null;
        }
        else if (kind === 'operator') {
            defs = this.lookAhead().map((x, n) => this._dictionary.infix[n]?.get(x) ??
                this._dictionary.postfix[n]?.get(x) ??
                this._dictionary.prefix[n]?.get(x));
        }
        else {
            defs = this.lookAhead().map((x, n) => this._dictionary[kind][n]?.get(x));
        }
        const result = [];
        for (let i = defs.length; i > 0; i--) {
            if (defs[i] !== undefined) {
                console.assert(Array.isArray(defs[i]));
                for (const def of defs[i])
                    result.push([def, i]);
            }
        }
        return result.length === 0 ? null : result;
    }
    /** Skip strictly `<space>` tokens.
     * To also skip `{}` see `skipSpace()`.
     * To skip visual space (e.g. `\,`) see `skipVisualSpace()`.
     */
    skipSpaceTokens() {
        while (this.match('<space>')) { }
    }
    /** While parsing in math mode, skip applicable spaces, which includes `{}`.
     * Do not use to skip spaces while parsing a string. See  `skipSpaceTokens()`
     * instead.
     */
    skipSpace() {
        if (!this.options.skipSpace)
            return false;
        // Check if there is a `{}` token sequence.
        // Those are used in LaTeX to force an invisible separation between commands
        // and are considered skipable space.
        if (!this.atEnd && this.peek === '<{>') {
            const index = this.index;
            this.next();
            while (this.match('<space>')) { }
            if (this.next() === '<}>') {
                this.skipSpace();
                return true;
            }
            this.index = index;
        }
        let result = false;
        while (this.match('<space>'))
            result = true;
        if (result)
            this.skipSpace();
        return result;
    }
    skipVisualSpace() {
        if (!this.options.skipSpace)
            return;
        this.skipSpace();
        if ([
            '\\!',
            '\\,',
            '\\:',
            '\\;',
            '\\enskip',
            '\\enspace',
            '\\space',
            '\\quad',
            '\\qquad',
        ].includes(this.peek)) {
            this.next();
            this.skipVisualSpace();
        }
        // @todo maybe also `\hspace` and `\hspace*` and `\hskip` and `\kern` with a glue param
        this.skipSpace();
    }
    matchChar() {
        const index = this.index;
        let caretCount = 0;
        while (this.match('^'))
            caretCount += 1;
        if (caretCount >= 2) {
            let digits = '';
            let n = 0;
            while (n != caretCount) {
                const digit = this.matchAny([
                    '0',
                    '1',
                    '2',
                    '3',
                    '4',
                    '5',
                    '6',
                    '7',
                    '8',
                    '9',
                    'a',
                    'b',
                    'c',
                    'd',
                    'e',
                    'f',
                ]);
                if (!digit)
                    break;
                digits += digit;
                n += 1;
            }
            if (digits.length === caretCount) {
                return String.fromCodePoint(Number.parseInt(digits, 16));
            }
        }
        else if (this.match('\\char')) {
            let codepoint = Math.floor(this.matchLatexNumber() ?? Number.NaN);
            if (!Number.isFinite(codepoint) ||
                codepoint < 0 ||
                codepoint > 0x10ffff) {
                codepoint = 0x2753; // BLACK QUESTION MARK
            }
            return String.fromCodePoint(codepoint);
        }
        else if (this.match('\\unicode')) {
            this.skipSpaceTokens();
            if (this.peek === '<{>') {
                this.next();
                const codepoint = this.matchLatexNumber();
                if (this.match('<}>') &&
                    codepoint !== null &&
                    codepoint >= 0 &&
                    codepoint <= 0x10ffff) {
                    return String.fromCodePoint(codepoint);
                }
            }
            else {
                const codepoint = this.matchLatexNumber();
                if (codepoint !== null && codepoint >= 0 && codepoint <= 0x10ffff) {
                    return String.fromCodePoint(codepoint);
                }
            }
        }
        this.index = index;
        const nextToken = this.next();
        return nextToken;
    }
    matchColor(_background = false) {
        let s = '';
        while (!this.atEnd && this.peek !== '}')
            s += this.next();
        // @todo: interpret the string according to `xcolor` (see
        return s;
    }
    matchLatexDimension() {
        // @todo
        return null;
    }
    match(token) {
        if (this._tokens[this.index] === token) {
            this.index++;
            return true;
        }
        return false;
    }
    matchAll(tokens) {
        if (typeof tokens === 'string')
            tokens = [tokens];
        if (tokens.length === 0)
            return false;
        let matched = true;
        let i = 0;
        do {
            matched = this._tokens[this.index + i] === tokens[i++];
        } while (matched && i < tokens.length);
        if (matched)
            this.index += i;
        return matched;
    }
    matchAny(tokens) {
        if (tokens.includes(this._tokens[this.index]))
            return this._tokens[this.index++];
        return '';
    }
    matchSequence(tokens) {
        const result = [];
        while (tokens.includes(this._tokens[this.index]))
            result.push(this._tokens[this.index++]);
        return result;
    }
    matchOptionalSign() {
        let isNegative = !!this.matchAny(['-', '\u2212']);
        while (this.matchAny(['+', '\ufe62']) || this.skipSpace())
            if (this.matchAny(['-', '\u2212']))
                isNegative = !isNegative;
        return isNegative ? '-' : '+';
    }
    matchDecimalDigits(options) {
        options ?? (options = {});
        options.withGrouping ?? (options.withGrouping = false);
        const result = [];
        let done = false;
        while (!done) {
            while (/^[0-9]$/.test(this.peek)) {
                result.push(this.next());
                this.skipVisualSpace();
            }
            done = true;
            if (options.withGrouping && this.options.groupSeparator) {
                const savedIndex = this.index;
                this.skipVisualSpace();
                if (this.matchAll(this._groupSeparatorTokens)) {
                    this.skipVisualSpace();
                    // Are there more digits after a group separator
                    if (/^[0-9]$/.test(this.peek))
                        done = false;
                    else
                        this.index = savedIndex;
                }
            }
        }
        return result.join('');
    }
    matchSignedInteger(options) {
        options ?? (options = {});
        options.withGrouping ?? (options.withGrouping = false);
        const start = this.index;
        const sign = this.matchOptionalSign();
        const result = this.matchDecimalDigits(options);
        if (result)
            return sign === '-' ? '-' + result : result;
        this.index = start;
        return '';
    }
    matchExponent() {
        const start = this.index;
        if (this.matchAny(['e', 'E'])) {
            // The exponent does not contain grouping markers. See
            // https://physics.nist.gov/cuu/Units/checklist.html  #16
            const exponent = this.matchSignedInteger({ withGrouping: false });
            if (exponent)
                return 'e' + exponent;
        }
        this.index = start;
        if (this.match('\\times')) {
            this.skipSpaceTokens();
            if (this.match('1') && this.match('0') && this.match('^')) {
                // Is it a single digit exponent, i.e. `\times 10^5`
                if (/^[0-9]$/.test(this.peek))
                    return 'e' + this.next();
                if (this.match('<{>')) {
                    // Multi digit exponent,i.e. `\times 10^{10}` or `\times 10^{-5}`
                    this.skipSpaceTokens();
                    // Note: usually don't have group markers, but since we're inside
                    // a `{}` there can't be ambiguity, so we're lenient
                    const exponent = this.matchSignedInteger();
                    this.skipSpaceTokens();
                    if (this.match('<}>') && exponent)
                        return 'e' + exponent;
                }
            }
        }
        this.index = start;
        // `%` is a synonym for `e-2`. See // https://physics.nist.gov/cuu/Units/checklist.html  #10
        this.skipSpaceTokens();
        if (this.match('\\%'))
            return `e-2`;
        this.index = start;
        if (this.matchAll(this._exponentProductTokens)) {
            this.skipSpaceTokens();
            if (this.matchAll(this._beginExponentMarkerTokens)) {
                this.skipSpaceTokens();
                const exponent = this.matchSignedInteger();
                this.skipSpaceTokens();
                if (this.matchAll(this._endExponentMarkerTokens) && exponent)
                    return 'e' + exponent;
            }
        }
        this.index = start;
        return '';
    }
    matchRepeatingDecimal() {
        const start = this.index;
        let repeatingDecimals = '';
        if (this.match('(')) {
            repeatingDecimals = this.matchDecimalDigits();
            if (repeatingDecimals && this.match(')'))
                return '(' + repeatingDecimals + ')';
            this.index = start;
            return '';
        }
        this.index = start;
        if (this.matchAll([`\\left`, '('])) {
            repeatingDecimals = this.matchDecimalDigits();
            if (repeatingDecimals && this.matchAll([`\\right`, ')']))
                return '(' + repeatingDecimals + ')';
            this.index = start;
            return '';
        }
        this.index = start;
        if (this.matchAll([`\\overline`, '<{>'])) {
            repeatingDecimals = this.matchDecimalDigits();
            if (repeatingDecimals && this.match('<}>'))
                return '(' + repeatingDecimals + ')';
            this.index = start;
            return '';
        }
        this.index = start;
        if (this.matchAll(this._beginRepeatingDigitsTokens)) {
            repeatingDecimals = this.matchDecimalDigits();
            if (repeatingDecimals && this.matchAll(this._endRepeatingDigitsTokens))
                return '(' + repeatingDecimals + ')';
            this.index = start;
            return '';
        }
        this.index = start;
        return '';
    }
    matchNumber() {
        // If we don't parse numbers, we'll return them as individual tokens
        if (!this.options.parseNumbers)
            return '';
        const start = this.index;
        this.skipVisualSpace();
        // Skip an optional '+' sign.
        // Important: the `-` sign is not handled as part of a number:
        // this is so we can correctly parse `-1^2` as `['Negate', ['Square', 1]]`
        this.match('+');
        let result = '';
        // Does the number start with the decimal marker? i.e. `.5`
        let dotPrefix = false;
        if (this.match('.') || this.matchAll(this._decimalMarkerTokens)) {
            const peek = this.peek;
            // Include `(` for repeating decimals
            if (peek !== '\\overline' &&
                peek !== this._beginRepeatingDigitsTokens[0] &&
                !/[0-9\(]/.test(peek)) {
                // A decimal marker followed by not a digit (and not a repeating decimal marker) -> not a number
                this.index = start;
                return '';
            }
            dotPrefix = true;
        }
        else {
            result = this.matchDecimalDigits({ withGrouping: true });
            if (!result) {
                this.index = start;
                return '';
            }
        }
        let hasDecimal = true;
        if (!dotPrefix &&
            (this.match('.') || this.matchAll(this._decimalMarkerTokens)))
            result += '.' + this.matchDecimalDigits({ withGrouping: true });
        else if (dotPrefix)
            result = '0.' + this.matchDecimalDigits({ withGrouping: true });
        else
            hasDecimal = false;
        if (hasDecimal) {
            const repeat = this.matchRepeatingDecimal();
            if (repeat)
                result += repeat;
            else if (this.match('\\ldots') ||
                this.matchAll(this._truncationMarkerTokens)) ;
        }
        this.skipVisualSpace();
        return result + this.matchExponent();
    }
    /**
     * A Latex number can be a decimal, hex or octal number.
     * It is used in some Latex commands, such as `\char`
     *
     * From TeX:8695 (scan_int):
     * > An integer number can be preceded by any number of spaces and `+' or
     * > `-' signs. Then comes either a decimal constant (i.e., radix 10), an
     * > octal constant (i.e., radix 8, preceded by '), a hexadecimal constant
     * > (radix 16, preceded by "), an alphabetic constant (preceded by `), or
     * > an internal variable.
     */
    matchLatexNumber(isInteger = true) {
        let negative = false;
        let token = this.peek;
        while (token === '<space>' || token === '+' || token === '-') {
            if (token === '-')
                negative = !negative;
            this.next();
            token = this.peek;
        }
        let radix = 10;
        let digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        if (this.match("'")) {
            // Apostrophe indicates an octal value
            radix = 8;
            digits = ['0', '1', '2', '3', '4', '5', '6', '7'];
            isInteger = true;
        }
        else if (this.match('"') || this.match('x')) {
            // Double-quote indicates a hex value
            // The 'x' prefix notation for the hexadecimal numbers is a MathJax extension.
            // For example: 'x3A'
            radix = 16;
            // Hex digits have to be upper-case
            digits = [
                '0',
                '1',
                '2',
                '3',
                '4',
                '5',
                '6',
                '7',
                '8',
                '9',
                'A',
                'B',
                'C',
                'D',
                'E',
                'F',
            ];
            isInteger = true;
        }
        else if (this.match('`')) {
            // A backtick indicates an alphabetic constant: a letter, or a single-letter command
            token = this.next();
            if (token) {
                if (token.startsWith('\\') && token.length === 2) {
                    return (negative ? -1 : 1) * (token.codePointAt(1) ?? 0);
                }
                return (negative ? -1 : 1) * (token.codePointAt(0) ?? 0);
            }
            return null;
        }
        let value = '';
        while (digits.includes(this.peek)) {
            value += this.next();
        }
        // Parse the fractional part, if applicable
        if (!isInteger && this.match('.')) {
            value += '.';
            while (digits.includes(this.peek)) {
                value += this.next();
            }
        }
        const result = isInteger
            ? Number.parseInt(value, radix)
            : Number.parseFloat(value);
        if (Number.isNaN(result))
            return null;
        return negative ? -result : result;
    }
    matchPrefixOperator(until) {
        if (!until)
            until = { minPrec: 0 };
        if (!until.minPrec)
            until = { ...until, minPrec: 0 };
        const defs = this.peekDefinitions('prefix');
        if (defs === null)
            return null;
        const start = this.index;
        for (const [def, n] of defs) {
            this.index = start + n;
            const rhs = def.parse(this, until);
            if (rhs)
                return rhs;
        }
        this.index = start;
        return null;
    }
    matchInfixOperator(lhs, until) {
        if (!until)
            until = { minPrec: 0 };
        if (!until.minPrec)
            until = { ...until, minPrec: 0 };
        const defs = this.peekDefinitions('infix');
        if (defs === null)
            return null;
        const start = this.index;
        for (const [def, n] of defs) {
            if (def.precedence >= until.minPrec) {
                this.index = start + n;
                const rhs = def.parse(this, until, lhs);
                if (rhs)
                    return rhs;
            }
        }
        this.index = start;
        return null;
    }
    /**
     * - 'enclosure' : will look for an argument inside an enclosure (open/close fence)
     * - 'implicit': either an expression inside a pair of `()`, or just a product
     *  (i.e. we interpret `\cos 2x + 1` as `\cos(2x) + 1`)
     */
    matchArguments(kind) {
        if (!kind)
            return null;
        const savedIndex = this.index;
        const group = this.matchEnclosure();
        if (kind === 'enclosure' && head(group) === 'Delimiter') {
            // We got an enclosure i.e. `f(a, b, c)`
            if (op(group, 1) === 'Sequence')
                return ops(op(group, 1)) ?? [];
            return [op(group, 1) ?? ['Sequence']];
        }
        if (kind === 'implicit') {
            // We are looking for an expression inside an optional pair of `()`
            // (i.e. trig functions, as in `\cos x`.)
            if (head(group) === 'Delimiter') {
                if (head(op(group, 1)) === 'Sequence')
                    return getSequence(group) ?? [];
                return [op(group, 1) ?? ['Sequence']];
            }
            // Was there a matchfix? the "group" is the argument, i.e.
            // `\sin [a, b, c]`
            if (group !== null)
                return [group];
            // No group, but arguments without parentheses are allowed
            // Read a primary
            const primary = this.matchExpression({ minPrec: 390 });
            if (primary !== null)
                return [primary];
            return null;
        }
        // The element following the function does not match
        // a possible argument list
        // That's OK, but need to undo the parsing of the matchfix
        // This is the case: `f[a]` or `f|a|`
        this.index = savedIndex;
        return null;
    }
    /**
     * A function can be followed by the following suffixes:
     * - a `\prime`, `\doubleprime`, `'`, `(n)` to indicate a derivative
     * - a subscript to indicate an argument
     * - an argument, optionally inside an enclosure
     */
    matchFunctionSuffix() {
        return null;
    }
    /** If matches the normalized open delimiter, return the
     * expected closing delimiter.
     *
     * For example, if `delimiter` is `(`, it would match `\left\lparen` and
     * return `['\right', '\rparen']`, which can be matched with `matchAll()`
     *
     * If you need to match several tokens, use `matchAll()`
     */
    matchOpenDelimiter(openDelim, closeDelim) {
        const index = this.index;
        const closePrefix = OPEN_DELIMITER_PREFIX[this.peek];
        if (closePrefix)
            this.next();
        const alternatives = DELIMITER_SHORTHAND[openDelim] ?? [openDelim];
        const result = closePrefix ? [closePrefix] : [];
        // Special case '||' delimiter
        if (alternatives.includes('||') && this.matchAll(['|', '|'])) {
            result.push('|');
            result.push('|');
            return result;
        }
        if (!alternatives.includes(this.peek)) {
            // Not the delimiter we were expecting: backtrack
            this.index = index;
            return null;
        }
        if (CLOSE_DELIMITER[openDelim] === closeDelim) {
            // If this is the standard pair (i.e. '(' and ')')
            // use the matching closing (i.e. '\lparen' -> '\rparen')
            result.push(CLOSE_DELIMITER[this.peek]);
        }
        else {
            result.push(closeDelim);
        }
        this.next();
        return result;
    }
    matchMiddleDelimiter(delimiter) {
        const delimiters = MIDDLE_DELIMITER[delimiter] ?? [delimiter];
        if (MIDDLE_DELIMITER_PREFIX.includes(this.peek)) {
            const index = this.index;
            this.next();
            if (delimiters.includes(this.peek)) {
                this.next();
                return true;
            }
            this.index = index;
            return false;
        }
        else if (delimiters.include(this.peek)) {
            this.next();
            return true;
        }
        return false;
    }
    /** For error handling, when there is potentially a mismatched delimiter.
     * Return a LaTeX fragment of the expected closing delimiter
     */
    matchEnclosureOpen() {
        const defs = this._dictionary.matchfix;
        if (defs.length === 0)
            return null;
        const start = this.index;
        for (const def of defs) {
            this.index = start;
            if (Array.isArray(def.openDelimiter)) {
                if (this.matchAll(def.openDelimiter))
                    return tokensToString(def.closeDelimiter);
                continue;
            }
            const closeDelimiter = this.matchOpenDelimiter(def.openDelimiter, def.closeDelimiter);
            if (closeDelimiter !== null)
                return tokensToString(closeDelimiter);
        }
        this.index = start;
        return null;
    }
    matchEnclosureClose() {
        const defs = this._dictionary.matchfix;
        if (defs.length === 0)
            return null;
        const start = this.index;
        for (const def of defs) {
            this.index = start;
            if (Array.isArray(def.closeDelimiter)) {
                if (this.matchAll(def.closeDelimiter))
                    return tokensToString(def.openDelimiter);
                continue;
            }
            this.index = start;
            let peek = this.peek;
            const prefix = Object.keys(OPEN_DELIMITER_PREFIX).find((x) => OPEN_DELIMITER_PREFIX[x] === peek);
            if (prefix)
                this.next();
            let openDelimiter = [];
            peek = this.peek;
            const matchingDelim = Object.keys(CLOSE_DELIMITER).find((x) => CLOSE_DELIMITER[x] === peek);
            if (matchingDelim)
                openDelimiter = [matchingDelim];
            if (prefix)
                openDelimiter = [prefix, ...openDelimiter];
            if (openDelimiter.length > 0) {
                this.next();
                return tokensToString(openDelimiter);
            }
        }
        this.index = start;
        return null;
    }
    /**
     * An enclosure is an opening matchfix operator, an optional expression,
     * optionally followed multiple times by a separator and another expression,
     * and finally a closing matching operator.
     */
    matchEnclosure() {
        const defs = this._dictionary.matchfix;
        if (defs.length === 0)
            return null;
        const start = this.index;
        //
        // Try each def
        //
        for (const def of defs) {
            this.index = start;
            // The `openDelimiter` can be either an array of LatexToken
            // (for cases like `\langle\vert` as a delimiter)
            // or a Delimiter (limited set of special strings that get interpreted
            // as synonyms, e.g. '(' = '\lparen' = '\left(' =...)
            if (Array.isArray(def.openDelimiter)) {
                //
                // If we have an array of tokens, match them all
                //
                // 1. Match the opening delimiter
                if (!this.matchAll(def.openDelimiter))
                    continue;
                this.addBoundary(def.closeDelimiter);
                // 2. Collect the sequence in between the delimiters
                const body = this.matchExpression();
                this.skipSpace();
                // 3. Match the closing delimiter
                if (!this.matchBoundary()) {
                    this.removeBoundary();
                    continue;
                }
                const rhs = def.parse(this, body ?? ['Sequence']);
                if (rhs === null)
                    continue; // This def didn't work. Try another.
                return rhs;
            }
            //
            // We have a 'normalized' delimiter (i.e. '(' will match '(' or
            // '\lparen)
            //
            // 1. Match the opening delimiter
            const closeDelimiter = this.matchOpenDelimiter(def.openDelimiter, def.closeDelimiter);
            if (closeDelimiter === null)
                continue;
            if (this.matchAll(closeDelimiter)) {
                const result = def.parse(this, ['Sequence']);
                if (result === null)
                    continue; // This def didn't work. Try another.
                return result;
            }
            // 2. Collect the expression in between the delimiters
            this.addBoundary(closeDelimiter);
            const bodyStart = this.index;
            let body = this.matchExpression();
            this.skipSpace();
            if (!this.matchBoundary()) {
                // We couldn't parse the body up to the closing delimiter.
                // This could be a case where the boundary of the enclosure is
                // ambiguous, i.e. `|(a+|b|+c)|`. Attempt to parse without the boundary
                this.removeBoundary();
                this.index = bodyStart;
                body = this.matchExpression();
                // If still could not match, try another
                if (!this.matchAll(closeDelimiter)) {
                    if (!this.atEnd)
                        continue;
                    // If we're at the end, we may need to backtrack and try again
                    // That's the case for `|1+|2|+3|`
                    this.index = start;
                    return null;
                }
            }
            const result = def.parse(this, body ?? ['Sequence']);
            if (result !== null)
                return result;
        }
        this.index = start;
        return null;
    }
    /**
     * Match an identifier. It can be:
     * - a symbol
     * - a simple multi-letter identifier: `\mathrm{speed}`
     * - a complex multi-letter identifier: `\mathrm{\alpha_{12}}` or `\mathit{speed\unicode{"2012}of\unicode{"2012}sound}`
     * - a command: `\alpha`  @todo
     */
    matchIdentifier() {
        if (this.match('\\operatorname') ||
            this.match('\\mathit') ||
            this.match('\\mathrm')) {
            const start = this.index;
            const id = this.matchStringArgument();
            if (id === null)
                return this.error('expected-string-argument', start);
            if (id === null || !isValidIdentifier(id))
                return this.error('invalid-symbol-name', start);
            return id;
        }
        if (/^[a-zA-Z]$/.test(this.peek))
            return this.next();
        return null;
    }
    /**
     * A function is a function identifier followed by arguments
     * - a function with explicit arguments `f(x)`
     * - a function with explicit arguments `\mathrm{floor}(x)`
     * - a function name: `\mathrm{floor}`
     * - a function with implicit arguments: `\cos x` (via a  custom parser)
     *
     */
    matchFunction() {
        const start = this.index;
        //
        // Is there a definition for this as a function?
        // (a string wrapped in `\\mathrm`, etc...) with some optional arguments
        //
        const fnDefs = this.peekDefinitions('function');
        if (fnDefs) {
            for (const [def, tokenCount] of fnDefs) {
                this.index = start + tokenCount;
                if (typeof def.parse === 'function') {
                    const result = def.parse(this);
                    if (result)
                        return result;
                }
                else {
                    // Is it followed by an argument list inside parentheses?
                    const seq = this.matchArguments('enclosure');
                    return seq ? [def.name, ...seq] : def.name;
                }
            }
        }
        this.index = start;
        //
        // No known function definition matched
        // Capture a function name
        //
        const fn = this.matchIdentifier();
        if (fn === null) {
            this.index = start;
            return null;
        }
        // If not a string, this was a malformed name (invalid identifier)
        if (typeof fn !== 'string')
            return fn;
        //
        // Is it a generic multi-char function identifier?
        //
        if (this.options.parseUnknownIdentifier?.(fn, this) === 'function') {
            // Function application:
            // Is it followed by an argument list inside parentheses?
            const seq = this.matchArguments('enclosure');
            return seq ? [fn, ...seq] : fn;
        }
        this.index = start;
        return null;
    }
    /**
     * A symbol can be:
     * - a single-letter variable: `x`
     * - a single LaTeX command: `\pi`
     */
    matchSymbol() {
        const start = this.index;
        //
        // Is there a custom parser for this symbol?
        //
        const defs = this.peekDefinitions('symbol');
        if (defs) {
            for (const [def, tokenCount] of defs) {
                this.index = start + tokenCount;
                // @todo: should capture symbol, and check it is not in use as a symbol,  function, or inferred (calling parseUnknownIdentifier() or somethinglike it (parseUnknownIdentifier() may aggressively return 'symbol'...)). Maybe not during parsing, but canonicalization
                if (typeof def.parse === 'function') {
                    const result = def.parse(this);
                    if (result)
                        return result;
                }
                else
                    return def.name;
            }
        }
        // No custom parser worked. Backtrack.
        this.index = start;
        const id = this.matchIdentifier();
        // No match. Backtrack and exit.
        if (id === null) {
            this.index = start;
            return null;
        }
        // Was there an error? Return it.
        if (typeof id !== 'string')
            return id;
        // Are we OK with it as a symbol?
        if (id && this.options.parseUnknownIdentifier?.(id, this) === 'symbol')
            return id;
        // Backtrack
        this.index = start;
        return null;
    }
    matchOptionalLatexArgument() {
        const index = this.index;
        this.skipSpaceTokens();
        if (this.match('[')) {
            this.addBoundary([']']);
            const expr = this.matchExpression();
            this.skipSpace();
            if (this.matchBoundary())
                return expr;
            return this.boundaryError('expected-closing-delimiter');
        }
        this.index = index;
        return null;
    }
    matchRequiredLatexArgument(excluding) {
        if (!excluding)
            excluding = [...'!"#$%&(),/;:?@[]`|~'.split(''), '\\left', '\\bigl'];
        const start = this.index;
        this.skipSpaceTokens();
        if (this.match('<{>')) {
            this.addBoundary(['<}>']);
            const expr = this.matchExpression();
            this.skipSpace();
            if (this.matchBoundary())
                return expr ?? ['Sequence'];
            return this.boundaryError('expected-closing-delimiter');
        }
        if (excluding.includes(this.peek)) {
            this.index = start;
            return null;
        }
        // Is it a single digit?
        // Note: `x^23` is `x^{2}3`, not x^{23}
        if (/^[0-9]$/.test(this.peek))
            return parseInt(this.next());
        // Is it a single letter (but not a special letter)?
        if (/^[^\\#]$/.test(this.peek))
            return this.next();
        // Otherwise, this can only be a symbol.
        // `\frac{1}2+1` is not valid, neither is `\frac\frac123`
        const expr = this.matchSymbol();
        if (expr)
            return expr;
        this.index = start;
        return null;
    }
    matchSupsub(lhs) {
        console.assert(lhs !== null); // @todo validate
        if (lhs === null)
            return null;
        const index = this.index;
        this.skipSpace();
        //
        // 1/ Gather possible superscript/subscripts
        //
        const superscripts = [];
        const subscripts = [];
        let subIndex = index;
        while (this.peek === '_' || this.peek === '^') {
            if (this.match('_')) {
                subIndex = this.index;
                if (this.match('_') || this.match('^'))
                    subscripts.push(this.error('syntax-error', subIndex));
                else {
                    const sub = this.matchRequiredLatexArgument() ?? this.matchStringArgument();
                    if (sub === null)
                        return this.error('missing', index);
                    subscripts.push(sub);
                }
            }
            else if (this.match('^')) {
                subIndex = this.index;
                if (this.match('_') || this.match('^'))
                    superscripts.push(this.error('syntax-error', subIndex));
                else {
                    const sup = this.matchRequiredLatexArgument();
                    if (sup === null)
                        return this.error('missing', index);
                    superscripts.push(sup);
                }
            }
            subIndex = this.index;
            this.skipSpace();
        }
        if (superscripts.length === 0 && subscripts.length === 0) {
            this.index = index;
            return lhs;
        }
        let result = lhs;
        //
        // 2/ Apply subscripts (first)
        //
        if (subscripts.length > 0) {
            const defs = this._dictionary.infix[1]?.get('_');
            if (defs) {
                const arg = [
                    'Subscript',
                    result,
                    subscripts.length === 1 ? subscripts[0] : ['List', ...subscripts],
                ];
                for (const def of defs) {
                    if (typeof def.parse === 'function')
                        result = def.parse(this, { minPrec: 0 }, arg);
                    else
                        result = arg;
                    if (result)
                        break;
                }
            }
        }
        //
        // 3/ Apply superscripts (second)
        //
        if (superscripts.length > 0) {
            const defs = this._dictionary.infix[1]?.get('^');
            if (defs) {
                const arg = [
                    'Superscript',
                    result,
                    superscripts.length === 1
                        ? superscripts[0]
                        : ['List', ...superscripts],
                ];
                for (const def of defs) {
                    if (typeof def.parse === 'function')
                        result = def.parse(this, { minPrec: 0 }, arg);
                    else
                        result = arg;
                    if (result)
                        break;
                }
            }
        }
        // Restore the index if we did not find a match
        if (result === null)
            this.index = index;
        return result;
    }
    matchPostfix(lhs) {
        console.assert(lhs !== null); // @todo validate
        if (lhs === null)
            return null;
        const defs = this.peekDefinitions('postfix');
        if (defs === null)
            return null;
        const start = this.index;
        for (const [def, n] of defs) {
            this.index = start + n;
            const result = def.parse(this, lhs);
            if (result !== null)
                return result;
        }
        this.index = start;
        return null;
    }
    /** Match a string used as a LaTeX identifier, for example an environment
     * name.
     * Not suitable for general purpose text, e.g. argument of a `\text{}
     * command. See `matchChar()` instead.
     */
    matchString() {
        let result = '';
        while (!this.atBoundary) {
            const token = this.peek;
            if (token === '<$>' || token === '<$$>') {
                return '';
            }
            else if (token === '<space>') {
                this.next();
                result += ' ';
            }
            else if (token[0] === '\\') {
                // TeX will give a 'Missing \endcsname inserted' error
                // if it encounters any command when expecting a string.
                // We're a bit more lax.
                result += this.next();
            }
            else {
                result += this.next();
            }
        }
        return result;
    }
    /** Match a string as an argument (in a `{}` pair) */
    matchStringArgument() {
        const start = this.index;
        this.skipSpaceTokens();
        if (this.match('<{>')) {
            this.addBoundary(['<}>']);
            // Don't use this.skipSpace(), as only the space token
            // should be skipped here, and regardless of the `options.skipSpace` setting
            while (this.match('<space>')) { }
            const arg = this.matchString();
            if (this.matchBoundary())
                return arg.trimEnd();
            this.removeBoundary();
        }
        this.index = start;
        return null;
    }
    /**
     * Match an expression in a tabular format, where rows are separated by `\\`
     * and columns by `&`.
     *
     * Return rows of sparse columns: empty rows are indicated with `Nothing`,
     * and empty cells are also indicated with `Nothing`.
     */
    matchTabular() {
        const result = [];
        let row = [];
        let expr = null;
        while (!this.atBoundary) {
            this.skipSpace();
            if (this.match('&')) {
                // new column
                // Push even if expr is NULL (it represents a skipped column)
                row.push(expr ?? 'Nothing');
                expr = null;
            }
            else if (this.match('\\\\') || this.match('\\cr')) {
                // new row
                this.skipSpace();
                // Parse but drop optional argument (used to indicate spacing between lines)
                this.matchOptionalLatexArgument();
                if (expr !== null)
                    row.push(expr);
                result.push(row);
                row = [];
                expr = null;
            }
            else {
                const cell = [];
                let peek = this.peek;
                while (peek !== '&' &&
                    peek !== '\\\\' &&
                    peek !== '\\cr' &&
                    !this.atBoundary) {
                    expr = this.matchExpression({
                        condition: (p) => {
                            const peek = p.peek;
                            return peek === '&' || peek === '\\\\' || peek === '\\cr';
                        },
                    });
                    if (expr)
                        cell.push(expr);
                    else {
                        cell.push(['Error', ["'unexpected-token'", peek]]);
                        this.next();
                    }
                    this.skipSpace();
                    peek = this.peek;
                }
                if (cell.length > 1)
                    expr = ['Sequence', ...cell];
                else
                    expr = cell[0] ?? 'Nothing';
            }
        }
        // Capture any leftover columns or row
        if (expr !== null)
            row.push(expr);
        if (row.length > 0)
            result.push(row);
        return result;
    }
    matchEnvironment() {
        const index = this.index;
        if (!this.match('\\begin'))
            return null;
        const name = this.matchStringArgument();
        if (name === null)
            return this.error('expected-environment-name', index);
        // @todo:parse optional and required arguments.
        this.addBoundary(['\\end', '<{>', ...name.split(''), '<}>']);
        const def = this._dictionary.environment.get(name);
        if (!def) {
            // If unknown environment, attempt to parse as tabular, but discard content
            this.matchTabular();
            this.skipSpace();
            if (!this.matchBoundary())
                return this.boundaryError('unbalanced-environment');
            return this.error(['unknown-environment', { str: name }], index);
        }
        const expr = def.parse(this, [], []);
        this.skipSpace();
        if (!this.matchBoundary())
            return this.boundaryError('unbalanced-environment');
        if (expr !== null)
            return this.decorate(expr, index);
        this.index = index;
        return null;
    }
    /**
     * Apply an invisible operator between two expressions.
     *
     * If the `lhs` is an literal integer and the `rhs` is a literal rational
     * -> 'invisible plus'
     *
     * That is '2 3/4' -> ['Add', 2, ['Rational', 3, 4]]
     *
     * If `lhs` is a number and `rhs` is a number but not a literal -> 'invisible multiply'.
     * - 2x
     * - 2(x+1)
     * - x(x+1)
     * - f(x)g(y)
     * - 2 sin(x)
     * - 2 f(x)
     * - x f(x)
     * - (x-1)(x+1)
     * - (x+1)2 -> no
     * - x2 -> no
     * => lhs is a number, rhs is a number, but not a literal
     */
    applyInvisibleOperator(terminator, lhs) {
        if (lhs === null ||
            head(lhs) === 'Error' ||
            symbol(lhs) === 'Nothing' ||
            isEmptySequence(lhs) ||
            this.atTerminator(terminator) ||
            this.options.applyInvisibleOperator === null)
            return null;
        //
        // If the right hand side is an operator, no invisible operator to apply
        //
        if (this.peekDefinitions('operator') !== null)
            return null;
        //
        // Capture a right hand side expression, if there is one
        //
        const start = this.index;
        const rhs = this.matchExpression({ ...terminator, minPrec: 390 });
        if (rhs === null || symbol(rhs) === 'Nothing' || isEmptySequence(rhs)) {
            this.index = start;
            return null;
        }
        if (head(rhs) === 'Error') {
            // If we got an error, apply a 'Sequence'
            return applyAssociativeOperator('Sequence', lhs, rhs);
        }
        //
        // Invoke custom `applyInvisibleOperator` handler
        //
        if (typeof this.options.applyInvisibleOperator === 'function')
            return this.options.applyInvisibleOperator(this, lhs, rhs);
        //
        // Is it a function application?
        //
        const lhsSymbol = symbol(lhs);
        if (lhsSymbol) {
            const isFunction = this.options.parseUnknownIdentifier(lhsSymbol, this) === 'function';
            if (isFunction) {
                const seq = getSequence(rhs);
                return seq ? [lhs, ...seq] : lhsSymbol;
            }
        }
        //
        // Is it an invisible plus?
        //
        // Integer literal followed by a fraction -> Invisible Add
        // CAUTION: machineValue() only works for numbers in machine range. OK in this case.
        const lhsNumber = machineValue(lhs);
        if (lhsNumber !== null && Number.isInteger(lhsNumber)) {
            const rhsHead = head(rhs);
            if (rhsHead === 'Divide' || rhsHead === 'Rational') {
                const [n, d] = [machineValue(op(rhs, 1)), machineValue(op(rhs, 2))];
                if (n !== null &&
                    d !== null &&
                    n > 0 &&
                    n <= 1000 &&
                    d > 1 &&
                    d <= 1000 &&
                    Number.isInteger(n) &&
                    Number.isInteger(d))
                    return ['Add', lhs, rhs];
            }
        }
        // If the value of `lhs` is a number and the value of `rhs` is a number
        // (but they may not be literal)
        // -> Apply Invisible Multiply
        // if (symbol(rhs) === 'Nothing') return lhs;
        if (head(rhs) === 'Delimiter') {
            if (head(op(rhs, 1)) === 'Sequence')
                return [lhsSymbol ?? lhs, ...(ops(op(rhs, 1)) ?? [])];
            if (!op(rhs, 1) || symbol(op(rhs, 1)) === 'Nothing')
                return applyAssociativeOperator('Sequence', lhs, this.error('expected-expression', start));
        }
        if (head(rhs) === 'Sequence' ||
            head(lhs) === 'Sequence' ||
            stringValue(lhs) !== null ||
            stringValue(rhs) !== null ||
            dictionary(lhs) !== null ||
            dictionary(rhs) !== null)
            return applyAssociativeOperator('Sequence', lhs, rhs);
        return applyAssociativeOperator('Multiply', lhs, rhs);
    }
    matchUnexpectedLatexCommand() {
        const start = this.index;
        //
        // Is this an unexpected operator?
        // (this is an error handling code path)
        //
        let opDefs = this.peekDefinitions('operator');
        if (opDefs) {
            opDefs = this.peekDefinitions('postfix');
            if (opDefs) {
                const [def, n] = opDefs[0];
                this.index += n;
                if (typeof def.parse === 'function') {
                    const result = def.parse(this, this.error('missing', start));
                    if (result)
                        return result;
                }
                if (def.name)
                    return [def.name, this.error('missing', start)];
                return this.error('unexpected-operator', start);
            }
            // Check prefix before infix, to catch `-` as a single missing operand
            opDefs = this.peekDefinitions('prefix');
            if (opDefs) {
                const [def, n] = opDefs[0];
                this.index += n;
                if (typeof def.parse === 'function') {
                    const result = def.parse(this, { minPrec: 0 });
                    if (result)
                        return result;
                }
                if (def.name)
                    return [
                        def.name,
                        this.matchExpression() ?? this.error('missing', start),
                    ];
                return this.error('unexpected-operator', start);
            }
            opDefs = this.peekDefinitions('infix');
            if (opDefs) {
                const [def, n] = opDefs[0];
                this.index += n;
                if (typeof def.parse === 'function') {
                    const result = def.parse(this, { minPrec: 0 }, this.error('missing', start));
                    if (result)
                        return result;
                }
                if (def.name)
                    return [
                        def.name,
                        this.error('missing', start),
                        this.matchExpression() ?? this.error('missing', start),
                    ];
                return this.error('unexpected-operator', start);
            }
        }
        const command = this.peek;
        if (!command || command[0] !== '\\')
            return null;
        this.next();
        this.skipSpaceTokens();
        if (command === '\\end') {
            const name = this.matchStringArgument();
            if (name === null)
                return this.error('expected-environment-name', start);
            return this.error(['unbalanced-environment', { str: name }], start);
        }
        // Capture potential optional and required LaTeX arguments
        // This is a lazy capture, to handle the case `\foo[\blah[12]\blarg]`.
        // However, a `[` (or `{`) could be e.g. inside a string and this
        // would fail to parse.
        // Since we're already in an error situation, though, probably OK.
        while (this.match('[')) {
            let level = 0;
            while (!this.atEnd && level === 0 && this.peek !== ']') {
                if (this.peek === '[')
                    level += 1;
                if (this.peek === ']')
                    level -= 1;
                this.next();
            }
            this.match(']');
        }
        const index = this.index;
        this.index = start;
        const closeDelimiter = this.matchEnclosureOpen();
        if (closeDelimiter)
            return this.error(['expected-close-delimiter', closeDelimiter], index);
        const openDelimiter = this.matchEnclosureClose();
        if (openDelimiter)
            return this.error(['expected-open-delimiter', openDelimiter], start);
        // Capture any potential arguments to this unexpected command
        this.index = index;
        while (this.match('<{>')) {
            let level = 0;
            while (!this.atEnd && level === 0 && this.peek !== '<}>') {
                if (this.peek === '<{>')
                    level += 1;
                if (this.peek === '<}>')
                    level -= 1;
                this.next();
            }
            this.match('<}>');
        }
        return this.error(['unexpected-command', { str: command }], start);
    }
    /**
     * <primary> :=
     * (<number> | <symbol> | <environment> | <matchfix-expr>) <subsup>* <postfix-operator>*
     *
     * <symbol> ::= (<symbol-id> | (<latex-command><latex-arguments>)) <arguments>
     *
     * <matchfix-expr> :=
     *  <matchfix-op-open> <expression> [<matchfix-op-separator> <expression>] <matchfix-op-close>
     *
     */
    matchPrimary() {
        if (this.atBoundary)
            return null;
        let result = null;
        const start = this.index;
        //
        // 1. Is it a group? (i.e. `{...}`)
        //
        // Unabalanced `<}>`? Syntax error
        if (this.match('<}>'))
            return this.error('unexpected-closing-delimiter', start);
        if (this.match('<{>')) {
            this.addBoundary(['<}>']);
            result = this.matchExpression();
            if (result === null)
                return this.boundaryError('expected-expression');
            if (!this.matchBoundary()) {
                return this.decorate([
                    'Sequence',
                    result,
                    this.boundaryError('expected-closing-delimiter'),
                ], start);
            }
        }
        //
        // 2. Is it a number?
        //
        if (result === null) {
            const num = this.matchNumber();
            if (num)
                result = { num };
        }
        //
        // 3. Is it an enclosure, i.e. a matchfix expression?
        //    (group fence, absolute value, integral, etc...)
        // (check before other LaTeX commands)
        //
        if (result === null)
            result = this.matchEnclosure();
        //
        // 4. Is it an environment?
        //    `\begin{...}...\end{...}`
        // (check before other LaTeX commands)
        //
        if (result === null)
            result = this.matchEnvironment();
        //
        // 5. Is it a symbol, a LaTeX command or a function call?
        //    `x` or `\pi'
        //    `f(x)` or `\sin(\pi)
        //    `\frac{1}{2}`
        //
        if (result === null && this.matchAll(this._positiveInfinityTokens))
            result = { num: '+Infinity' };
        if (result === null && this.matchAll(this._negativeInfinityTokens))
            result = { num: '-Infinity' };
        if (result === null && this.matchAll(this._notANumberTokens))
            result = { num: 'NaN' };
        if (result === null)
            result = this.matchFunction() ?? this.matchSymbol();
        //
        // 6. Are there postfix operators ?
        //
        if (result !== null) {
            result = this.decorate(result, start);
            let postfix = null;
            let index = this.index;
            do {
                postfix = this.matchPostfix(result);
                result = postfix ?? result;
                if (this.index === index && postfix !== null) {
                    console.assert(this.index !== index, 'No token consumed');
                    break;
                }
                index = this.index;
            } while (postfix !== null);
        }
        //
        // 7. We've encountered an unexpected LaTeX command
        //
        if (result === null)
            result = this.matchUnexpectedLatexCommand();
        //
        // 8. Are there superscript or subfix operators?
        //
        if (result !== null)
            result = this.matchSupsub(result);
        return this.decorate(result, start);
    }
    /**
     *  Parse an expression:
     *
     * <expression> ::=
     *  | <primary>
     *  | <prefix-op> <primary>
     *  | <primary> <infix-op> <expression>
     *
     * Stop when an operator of precedence less than `until.minPrec` is encountered
     */
    matchExpression(until) {
        const start = this.index;
        this.skipSpace();
        if (this.atBoundary) {
            this.index = start;
            return null;
        }
        if (!until)
            until = { minPrec: 0 };
        if (until.minPrec === undefined)
            until.minPrec = 0;
        //
        // 1. Do we have a prefix operator?
        //
        let lhs = this.matchPrefixOperator({ ...until, minPrec: 0 });
        //
        // 2. Do we have a primary?
        // (if we had a prefix, it consumed the primary following it)
        //
        if (lhs === null) {
            lhs = this.matchPrimary();
            // If we got an empty sequence, ignore it.
            // This is returned by some purely presentational commands, for example `\displaystyle`
            if (head(lhs) === 'Sequence' && nops(lhs) === 0)
                lhs = null;
        }
        //
        // 3. Are there some infix operators?
        //
        if (lhs) {
            let done = false;
            while (!done && !this.atTerminator(until)) {
                this.skipSpace();
                let result = this.matchInfixOperator(lhs, until);
                if (result === null) {
                    // We've encountered something else than an infix operator
                    // OR an infix operator with a lower priority.
                    // Could be "y" after "x": time to apply the invisible operator
                    result = this.applyInvisibleOperator(until, lhs);
                }
                if (result !== null) {
                    lhs = result;
                }
                else {
                    // We could not apply the infix operator: the rhs may
                    // have been a postfix operator, or something else
                    done = true;
                }
            }
        }
        return this.decorate(lhs, start);
    }
    /**
     * Add LaTeX or other requested metadata to the expression
     */
    decorate(expr, start) {
        if (expr === null)
            return null;
        if (!this.options.preserveLatex)
            return expr;
        const latex = this.latex(start, this.index);
        if (Array.isArray(expr)) {
            expr = { latex, fn: expr };
        }
        else if (typeof expr === 'number') {
            expr = { latex, num: Number(expr).toString() };
        }
        else if (typeof expr === 'string') {
            expr = { latex, sym: expr };
        }
        else if (typeof expr === 'object' && expr !== null) {
            expr.latex = latex;
        }
        return expr;
    }
    error(code, fromToken) {
        if (typeof code === 'string')
            return [
                'Error',
                { str: code },
                [
                    'Latex',
                    {
                        str: this.latex(fromToken, this.index),
                    },
                ],
            ];
        return [
            'Error',
            ['ErrorCode', { str: code[0] }, ...code.slice(1)],
            [
                'Latex',
                {
                    str: this.latex(fromToken, this.index),
                },
            ],
        ];
    }
}

// Some vocabulary:
// 123.456e78
// - 123.456 = significand
// - 123 = wholePart
// - 456 = fractionalPart
// - 78 = exponent
//
// Avoid using mantissa which has several definitions and is ambiguous.
/**
 * Return a formatted fractional part by detecting repeating patterns.
 * 1234567 -> 123 456 7...
 * 1233333 -> 12(3)
 */
function formatFractionalPart(m, options) {
    const originalLength = m.length;
    const originalM = m;
    if (options.beginRepeatingDigits && options.endRepeatingDigits) {
        // The last digit may have been rounded off, if it exceeds the precision,
        // which could throw off the repeating pattern detection. Ignore it.
        m = m.slice(0, -1);
        for (let i = 0; i < m.length - 16; i++) {
            // Offset is the part of the fractional part that is not repeating
            const offset = m.substring(0, i);
            // Try to find a repeating pattern of length j
            for (let j = 0; j < 17; j++) {
                const cycle = m.substring(i, i + j + 1);
                const times = Math.floor((m.length - offset.length) / cycle.length);
                if (times <= 3)
                    break;
                if ((offset + cycle.repeat(times + 1)).startsWith(m)) {
                    // We've found a repeating pattern!
                    if (cycle === '0') {
                        // Psych! That pattern is '0'...
                        return offset.replace(/(\d{3})/g, '$1' + options.groupSeparator);
                    }
                    // There is what looks like a true repeating pattern...
                    return (offset.replace(/(\d{3})/g, '$1' + options.groupSeparator) +
                        options.beginRepeatingDigits +
                        cycle +
                        options.endRepeatingDigits);
                }
            }
        }
    }
    // There was no repeating pattern we could find...
    // Are we displaying fewer digits than were provided?
    // Display a truncation marker.
    const extraDigits = originalLength > options.precision - 1;
    m = originalM;
    if (extraDigits)
        m = m.substring(0, options.precision - 1);
    // Insert group separators if necessary
    if (options.groupSeparator) {
        m = m.replace(/(\d{3})/g, '$1' + options.groupSeparator);
        if (m.endsWith(options.groupSeparator)) {
            m = m.slice(0, -options.groupSeparator.length);
        }
    }
    if (extraDigits)
        return m + options.truncationMarker;
    return m;
}
function formatExponent(exp, options) {
    if (!exp)
        return '';
    if (options.beginExponentMarker) {
        return (options.beginExponentMarker + exp + (options.endExponentMarker ?? ''));
    }
    return '10^{' + exp + '}';
}
/*
 * @param expr - A number, can be represented as a string
 *  particularly useful for arbitrary precision numbers) or a number (-12.45)
 * @return A textual representation of the number, formatted according to the
 * `options`
 */
function serializeNumber(expr, options) {
    if (expr === null)
        return '';
    let num;
    if (typeof expr === 'number' || typeof expr === 'string') {
        num = expr;
    }
    else if (typeof expr === 'object' && 'num' in expr) {
        num = expr.num;
    }
    else
        return '';
    if (typeof num === 'number') {
        if (num === Infinity)
            return options.positiveInfinity;
        else if (num === -Infinity)
            return options.negativeInfinity;
        else if (Number.isNaN(num))
            return options.notANumber;
        let result = undefined;
        if (options.notation === 'engineering')
            result = serializeScientificNotationNumber(num.toExponential(), options, 3);
        else if (options.notation === 'scientific')
            result = serializeScientificNotationNumber(num.toExponential(), options);
        return result ?? serializeAutoNotationNumber(num.toString(), options);
    }
    num = num.toLowerCase().replace(/[\u0009-\u000d\u0020\u00a0]/g, '');
    if (num === 'infinity' || num === '+infinity')
        return options.positiveInfinity;
    else if (num === '-infinity')
        return options.negativeInfinity;
    else if (num === 'nan')
        return options.notANumber;
    if (!/^[-+\.]?[0-9]/.test(num))
        return '';
    num = num.replace(/[nd]$/, '');
    // Do we have repeating digits?
    // If so, "unrepeat" (expand) them
    if (/\([0-9]+\)/.test(num)) {
        const [_, body, repeat, trail] = num.match(/(.+)\(([0-9]+)\)(.*)$/) ?? [];
        num =
            body +
                repeat.repeat(Math.ceil(options.precision / repeat.length)) +
                trail;
    }
    let sign = '';
    if (num[0] === '-') {
        sign = '-';
        num = num.substring(1);
    }
    else if (num[0] === '+') {
        num = num.substring(1);
    }
    // Remove any leading zeros
    while (num[0] === '0')
        num = num.substring(1);
    if (num.length === 0)
        num = sign + '0';
    else if (num[0] === '.')
        num = sign + '0' + num;
    let result = undefined;
    if (options.notation === 'engineering')
        result = serializeScientificNotationNumber(num, options, 3);
    else if (options.notation === 'scientific')
        result = serializeScientificNotationNumber(num, options);
    return sign + (result ?? serializeAutoNotationNumber(num, options));
}
/**
 * Scientific notation has:
 * - a whole part [1..9]
 * - an optional fractional part (many digits)
 * - an optional exponent
 * @param valString
 * @param options
 * @returns
 */
function serializeScientificNotationNumber(valString, options, expMultiple = 1) {
    // For '7' returns '7e+0'
    let m = valString.match(/^(.*)[e|E]([-+]?[0-9]+)$/);
    if (!m) {
        // Valstring wasn't in exponential form, convert it.
        // Remove the sign
        let sign = '';
        if (valString[0] === '-') {
            sign = '-';
            valString = valString.substring(1);
        }
        else if (valString[0] === '+') {
            valString = valString.substring(1);
        }
        if (valString.indexOf('.') < 0) {
            if (valString.length === 1) {
                valString = sign + valString + 'e+0';
            }
            else {
                // A long integer, convert to exponential form
                valString =
                    sign +
                        valString[0] +
                        '.' +
                        valString.slice(1) +
                        'e+' +
                        (valString.length - 1).toString();
            }
        }
        else {
            // A decimal number, convert to exponential form
            // eslint-disable-next-line prefer-const
            let [_, whole, fraction] = valString.match(/^(.*)\.(.*)$/);
            if (!fraction)
                fraction = '';
            while (whole.startsWith('0'))
                whole = whole.substring(1);
            if (!whole) {
                // .123 -> 0.123e+0
                // .0123 -> 0.0123e+0
                valString = sign + '0.' + fraction + 'e+0';
            }
            else {
                // 1.234  -> 1.234e+0
                // 12.345 -> 1.2345e+1
                valString =
                    sign +
                        whole[0] +
                        '.' +
                        whole.slice(1) +
                        fraction +
                        'e+' +
                        (whole.length - 1).toString();
            }
        }
        m = valString.match(/^(.*)[e|E]([-+]?[0-9]+)$/);
    }
    console.assert(m);
    if (!m)
        return serializeAutoNotationNumber(valString, options);
    let exponent = parseInt(m[2]);
    let mantissa = m[1];
    if (Math.abs(exponent) % expMultiple !== 0) {
        // Need to adjust the exponent and values, e.g. for engineering notation
        const adjust = exponent > 0
            ? exponent % expMultiple
            : -((expMultiple + exponent) % expMultiple);
        exponent = exponent >= 0 ? exponent - adjust : exponent + adjust;
        // Don't use numeric operations, which may introduce artifacting
        // eslint-disable-next-line prefer-const
        let [_, whole, fraction] = mantissa.match(/^(.*)\.(.*)$/) ?? [
            '',
            mantissa,
            '',
        ];
        mantissa =
            whole +
                (fraction + '00000000000000000').slice(0, Math.abs(adjust)) +
                '.' +
                fraction.slice(Math.abs(adjust));
    }
    // Is the exponent in a range to be avoided?
    const avoid = options.avoidExponentsInRange;
    if (avoid && exponent >= avoid[0] && exponent <= avoid[1])
        return undefined;
    let fractionalPart = '';
    let wholePart = mantissa;
    m = wholePart.match(/^(.*)\.(.*)$/);
    if (m) {
        wholePart = m[1];
        fractionalPart = m[2];
    }
    const expString = exponent !== 0 ? formatExponent(Number(exponent).toString(), options) : '';
    if (options.groupSeparator) {
        wholePart = wholePart.replace(/\B(?=(\d{3})+(?!\d))/g, options.groupSeparator);
        fractionalPart = formatFractionalPart(fractionalPart, options);
    }
    if (fractionalPart)
        fractionalPart = options.decimalMarker + fractionalPart;
    // @todo: does not respect the options.precision option
    if (!expString)
        return wholePart + fractionalPart;
    if (wholePart === '1' && !fractionalPart)
        return expString;
    return wholePart + fractionalPart + options.exponentProduct + expString;
}
function serializeAutoNotationNumber(valString, options) {
    let m = valString.match(/^(.*)[e|E]([-+]?[0-9]+)$/i);
    let exponent = undefined;
    // if valString === '-1234567.89e-123'
    // m[1] = '-1234567.89'
    // m[2] = -123
    if (m?.[1] && m[2]) {
        // There is an exponent...
        exponent = formatExponent(m[2], options);
    }
    let wholePart = m?.[1] ?? valString;
    let fractionalPart = '';
    m = (exponent ? m[1] : valString).match(/^(.*)\.(.*)$/);
    if (m?.[1] && m[2]) {
        wholePart = m[1];
        fractionalPart = m[2];
    }
    if (options.groupSeparator) {
        wholePart = wholePart.replace(/\B(?=(\d{3})+(?!\d))/g, options.groupSeparator);
        fractionalPart = formatFractionalPart(fractionalPart, options);
    }
    if (fractionalPart)
        fractionalPart = options.decimalMarker + fractionalPart;
    if (!exponent)
        return wholePart + fractionalPart;
    if (wholePart === '1' && !fractionalPart)
        return exponent;
    return wholePart + fractionalPart + options.exponentProduct + exponent;
}

// function serializeMatchfix(
//   serializer: Serializer,
//   expr: Expression,
//   def: MatchfixEntry
// ): string {
//   return replaceLatex(def.serialize as string, [
//     serializer.serialize(op(expr, 1) ?? ['Sequence']),
//   ]);
// }
function serializeOperator(serializer, expr, def) {
    let result = '';
    const count = nops(expr);
    const name = headName(expr);
    if (def.kind === 'postfix') {
        if (count !== 1) {
            serializer.onError([
                {
                    severity: 'warning',
                    message: [
                        'postfix-operator-requires-one-operand',
                        serializer.serializeSymbol(name),
                    ],
                },
            ]);
        }
        return replaceLatex(def.serialize, [
            serializer.wrap(op(expr, 1), def.precedence),
        ]);
    }
    if (def.kind === 'prefix') {
        if (count !== 1) {
            serializer.onError([
                {
                    severity: 'warning',
                    message: [
                        'prefix-operator-requires-one-operand',
                        serializer.serializeSymbol(name),
                    ],
                },
            ]);
        }
        return replaceLatex(def.serialize, [
            serializer.wrap(op(expr, 1), def.precedence + 1),
        ]);
    }
    if (def.kind === 'infix') {
        result = serializer.wrap(op(expr, 1), def.precedence);
        for (let i = 2; i < count + 1; i++) {
            const arg = op(expr, i);
            if (arg !== null) {
                result = replaceLatex(def.serialize, [
                    result,
                    serializer.wrap(arg, def.precedence),
                ]);
            }
        }
    }
    return result;
}
class Serializer {
    constructor(options, dictionary, onError) {
        this.level = -1;
        this.options = options;
        if (options.invisibleMultiply) {
            if (!/#1/.test(options.invisibleMultiply) ||
                !/#2/.test(options.invisibleMultiply)) {
                onError([
                    {
                        severity: 'warning',
                        message: ['expected-argument', 'invisibleMultiply'],
                    },
                ]);
            }
        }
        this.onError = onError;
        this.dictionary = dictionary;
    }
    updateOptions(opt) {
        for (const k of Object.keys(this.options))
            if (k in opt)
                this.options[k] = opt[k];
    }
    /**
     * Serialize the expression, and if the expression is an operator
     * of precedence less than or equal to prec, wrap it in some paren.
     * @todo: don't wrap Abs, Floor, Ceil, Delimiter
     */
    wrap(expr, prec) {
        if (expr === null)
            return '';
        if (prec === undefined) {
            return this.wrapString(this.serialize(expr), this.options.groupStyle(expr, this.level + 1));
        }
        if (typeof expr === 'number' ||
            isNumberObject(expr) ||
            typeof expr === 'string' ||
            isSymbolObject(expr)) {
            return this.serialize(expr);
        }
        const name = head(expr);
        if (typeof name === 'string' &&
            name !== 'Delimiter' &&
            name !== 'Subscript') {
            const def = this.dictionary.name.get(name);
            if (def &&
                (def.kind === 'symbol' ||
                    def.kind === 'prefix' ||
                    def.kind === 'infix' ||
                    def.kind === 'postfix') &&
                def.precedence < prec)
                return this.wrapString(this.serialize(expr), this.options.applyFunctionStyle(expr, this.level));
        }
        return this.serialize(expr);
    }
    /** If this is a "short" expression (atomic), wrap it.
     *
     */
    wrapShort(expr) {
        if (expr === null)
            return '';
        const exprStr = this.serialize(expr);
        if (head(expr) === 'Delimiter' && nops(expr) === 1)
            return exprStr;
        if (!isNumberExpression(expr) && !/(^(.|\\[a-zA-Z*]+))$/.test(exprStr)) {
            // It's a long expression, wrap it
            return this.wrapString(exprStr, this.options.groupStyle(expr, this.level + 1));
        }
        return exprStr;
    }
    wrapString(s, style, fence) {
        if (style === 'none')
            return s;
        const openFence = fence?.[0] ?? '(';
        const closeFence = fence?.[1] ?? ')';
        if ((openFence === '.' || closeFence === '.') && style === 'paren')
            style = 'leftright';
        if (style === 'leftright')
            return `${openFence === '.' ? '' : `\\left(${openFence}`}${s}${closeFence === '.' ? '' : `\\right(${closeFence}`})`;
        if (style === 'big')
            return `${openFence === '.' ? '' : `\\Bigl(${openFence}`}${s}${closeFence === '.' ? '' : `\\Bigr(${closeFence}`})`;
        return openFence + s + closeFence;
    }
    wrapArguments(expr) {
        return this.wrapString((ops(expr) ?? []).map((x) => this.serialize(x)).join(', '), this.options.applyFunctionStyle(expr, this.level));
    }
    serializeSymbol(expr, def) {
        const h = head(expr);
        if (h)
            return this.serializeFunction(expr, def);
        console.assert(typeof expr === 'string' || isSymbolObject(expr));
        // It's a symbol
        if (typeof def?.serialize === 'string')
            return def.serialize;
        else if (typeof def?.serialize === 'function')
            return def.serialize(this, expr);
        return sanitizeName(symbol(expr), 'upright.') ?? '';
    }
    serializeFunction(expr, def) {
        const h = head(expr);
        if (!h)
            return this.serializeSymbol(expr, def);
        const args = ops(expr) ?? [];
        if (def) {
            //
            // 1. Is it a known function?
            //
            if (typeof def.serialize === 'function')
                return def.serialize(this, expr);
            return joinLatex([
                def.serialize ?? h,
                this.wrapArguments(expr),
            ]);
        }
        // We don't know anything about this function
        if (typeof h === 'string' && h.length > 0 && h[0] === '\\') {
            //
            // 2. Is it an unknown LaTeX command?
            //
            // This looks like a LaTeX command. Serialize the arguments as LaTeX arguments
            return joinLatex([h, ...args.map((x) => `{${this.serialize(x)}}`)]);
        }
        //
        // 2. Is it an unknown function call?
        //
        // It's a function we don't know.
        // Maybe it came from `promoteUnknownToken`
        // Serialize the arguments as function arguments
        if (typeof h === 'string')
            return sanitizeName(h, 'upright.') + this.wrapArguments(expr);
        const style = this.options.applyFunctionStyle(expr, this.level);
        return ('\\mathrm{Apply}' +
            this.wrapString(this.serialize(h) + ', ' + this.serialize(['List', ...args]), style));
    }
    serializeDictionary(dict) {
        return `\\left\\lbrack\\begin{array}{lll}${Object.keys(dict)
            .map((x) => {
            return `\\textbf{${x}} & \\rightarrow & ${this.serialize(dict[x])}`;
        })
            .join('\\\\')}\\end{array}\\right\\rbrack`;
    }
    serialize(expr) {
        if (expr === null || expr === undefined)
            return '';
        this.level += 1;
        try {
            const result = (() => {
                //
                // 1. Is it a number
                //
                const numericValue = serializeNumber(expr, this.options);
                if (numericValue)
                    return numericValue;
                //
                // 2. Is it a string?
                //
                const s = stringValue(expr);
                if (s !== null)
                    return `\\text{${s}}`;
                //
                // 3. Is it a symbol?
                //
                const symbolName = symbol(expr);
                if (symbolName !== null) {
                    const def = this.dictionary.name.get(symbolName);
                    if (def?.kind === 'symbol')
                        return this.serializeSymbol(expr, def);
                    if (def?.kind === 'function')
                        return this.serializeFunction(expr, def);
                }
                //
                // 4. Is it a dictionary?
                //
                const dict = dictionary(expr);
                if (dict !== null)
                    return this.serializeDictionary(dict);
                //
                // 5. Is it a named function?
                //
                const fnName = headName(expr);
                if (fnName) {
                    if (fnName[0] === '\\') {
                        // 5.1 An unknown LaTeX command, possibly with arguments.
                        // This can happen if we encountered an unrecognized LaTeX command
                        // during parsing, e.g. "\foo{x + 1}"
                        const args = ops(expr) ?? [];
                        if (args.length === 0)
                            return fnName;
                        return (fnName +
                            '{' +
                            args
                                .map((x) => this.serialize(x))
                                .filter((x) => Boolean(x))
                                .join('}{') +
                            '}');
                    }
                    //
                    // 5.2 A function, operator or matchfix operator
                    //
                    const def = this.dictionary.name.get(fnName);
                    if (def) {
                        // If there is a custom serializer function, use it.
                        // (note: 'matchfix' entries always have a default serializer)
                        if (typeof def.serialize === 'function')
                            return def.serialize(this, expr);
                        if (def.kind === 'infix' ||
                            def.kind === 'postfix' ||
                            def.kind === 'prefix')
                            return serializeOperator(this, expr, def);
                        if (def.kind === 'symbol')
                            return this.serializeSymbol(expr, def);
                        if (def.kind === 'function')
                            return this.serializeFunction(expr, def);
                        return '';
                    }
                }
                if (Array.isArray(expr) ||
                    isFunctionObject(expr) ||
                    symbol(expr) !== null) {
                    // It's a function or a symbol, but without definition.
                    // It could be a [['derive', "f"], x]
                    // serializeSymbol() will take care of it.
                    return this.serializeSymbol(expr);
                }
                // This doesn't look like a symbol, or a function,
                // or anything we were expecting.
                // This is an invalid expression, for example an
                // object literal with no known fields, or an invalid number:
                // `{num: 'not a number'}`
                // `{foo: 'not an expression}`
                this.onError([
                    {
                        severity: 'warning',
                        message: [
                            'syntax-error',
                            expr ? JSON.stringify(expr) : 'undefined',
                        ],
                    },
                ]);
            })();
            this.level -= 1;
            return result ?? '';
        }
        catch (e) { }
        this.level -= 1;
        return '';
    }
    applyFunctionStyle(expr, level) {
        return this.options.applyFunctionStyle(expr, level);
    }
    groupStyle(expr, level) {
        return this.options.groupStyle(expr, level);
    }
    rootStyle(expr, level) {
        return this.options.rootStyle(expr, level);
    }
    fractionStyle(expr, level) {
        return this.options.fractionStyle(expr, level);
    }
    logicStyle(expr, level) {
        return this.options.logicStyle(expr, level);
    }
    powerStyle(expr, level) {
        return this.options.powerStyle(expr, level);
    }
    numericSetStyle(expr, level) {
        return this.options.numericSetStyle(expr, level);
    }
}
/**
 * Replace '#1', '#2' in the LaTeX template stings with the corresponding
 * values from `replacement`, in a LaTeX syntax safe manner (i.e. inserting spaces when needed)
 */
function replaceLatex(template, replacement) {
    console.assert(typeof template === 'string');
    console.assert(template.length > 0);
    let result = template;
    for (let i = 0; i < replacement.length; i++) {
        let s = replacement[i] ?? '';
        if (/[a-zA-Z*]/.test(s[0])) {
            const m = result.match(new RegExp('(.*)#' + Number(i + 1).toString()));
            if (m && /\\[a-zA-Z*]+/.test(m[1])) {
                s = ' ' + s;
            }
        }
        result = result.replace('#' + Number(i + 1).toString(), s);
    }
    return result;
}
const COMMON_VARIABLE_NAME = [
    'alpha',
    'beta',
    'gamma',
    'Gamma',
    'delta',
    'Delta',
    'epsilon',
    'zeta',
    'eta',
    'theta',
    'Theta',
    'iota',
    'kappa',
    'lambda',
    'Lambda',
    'mu',
    'nu',
    'xi',
    'Xi',
    'pi',
    'Pi',
    'rho',
    'sigma',
    'Sigma',
    'tau',
    'upsilon',
    'phi',
    'Phi',
    'varphi',
    'chi',
    'psi',
    'Psi',
    'omega',
    'Omega',
    'aleph',
    'ast',
    'blacksquare',
    'bot',
    'bullet',
    'circ',
    'diamond',
    'times',
    'top',
    'square',
    'star',
];
// If the name contains an underscore, e.g.'mu_0', make sure
// to add braces.
//
// If s has a numeric prefix, put it in subscript.
//
// Escape special Latex characters
// `{`, `}`, `$`, `%`, `[`, `]`, `\`
//
// Other special symbols:
// 'x_012' --> `x_{012}`
// 'x012' --> `x_{012}`
// 'x_"max"' --> `x_\mathrm{max}`
// '_' --> `\mathrm{\_}`
// '_a' --> `\mathrm{\_a}`
// '___a' --> `\mathrm{\_\_\_a}`
// 'alpha0' --> `mathit{\alpha_{0}}`
// 'alpha_beta' --> `mathit{\alpha_{beta}}`
// 'speed-of-sound' --> `\mathit{speed\unicode{"2012}of\unicode{"2012}sound}`
// 'not[this]' --> `\mathit{\lbrace this\rbrace}`
/**
 * The `defaultMulticharStyle` indicate which style should be used to
 * wrap the symbol if it has more than one character and doesn't have a style
 * specified. This is used to display function names upright, and other
 * (single-char) symbols italic
 */
function sanitizeName(s, defaultMulticharStyle = 'italic.') {
    if (s === null)
        return null;
    // If the name starts with one or more underscore, it's a wildcard symbol
    const m = s.match(/^(_+)(.*)/);
    if (m) {
        return `\\text{${'\\_'.repeat(m[1].length) + sanitizeNameFragment(m[2])}}`;
    }
    let modifier;
    [modifier, s] = extractSymbolStyleModifier(s);
    const name = sanitizeNameFragment(s);
    if (name.length === 1 && !modifier)
        return name;
    if (!modifier)
        modifier = defaultMulticharStyle;
    const SYMBOL_MODIFIER_PATTERN = {
        'upright.': '\\mathrm{_}',
        'italic.': '\\mathit{_}',
        'bold-italic.': '\\mathbf{\\mathit{_}}',
        'script.': '\\mathscr{_}',
        'calligraphic.': '\\mathcal{_}',
        'bold-script.': '\\mathbf{\\mathscr{_}}',
        'bold-calligraphic.': '\\mathbf{\\mathcal{_}}',
        'fraktur.': '\\mathfrak{_}',
        'gothic.': '\\mathfrak{_}',
        'bold-gothic.': '\\mathbf{\\mathfrak{_}}',
        'bold-fraktur.': '\\mathbf{\\mathfrak{_}}',
        'sans-serif.': '\\mathsf{_}',
        'bold-sans-serif.': '\\mathbf{\\mathsf{_}}',
        'italic-sans-serif.': '\\mathit{\\mathsf{_}}',
        'monospace.': '\\mathtt{_}',
        'blackboard.': '\\mathbb{_}',
        'double-struck.': '\\mathbb{_}',
    };
    return (SYMBOL_MODIFIER_PATTERN[modifier] ?? '\\mathit{_}').replace('_', name);
}
function extractSymbolStyleModifier(s) {
    const m = s.match(/^([a-zA-Z-]+\.)(.*)/);
    if (m)
        return [m[1], m[2]];
    return ['', s];
}
function sanitizeNameFragment(s) {
    const index = s.indexOf('_');
    if (index > 0) {
        const prefix = s.substring(0, index);
        const suffix = s.substring(index + 1);
        if (!suffix)
            return `${sanitizeName(prefix)}\\_`;
        if (suffix.startsWith('"') && suffix.endsWith('"')) {
            return `${sanitizeNameFragment(prefix)}_\\mathrm{${sanitizeNameFragment(suffix.substring(1, -1))}}`;
        }
        return `${sanitizeNameFragment(prefix)}_{${sanitizeNameFragment(suffix)}}`;
    }
    // Ends with a numeric suffix?
    const m = s.match(/(.*?)(-?[0-9]+)$/);
    if (m) {
        if (m[1].length === 0)
            return s;
        return `${sanitizeNameFragment(m[1])}_{${m[2]}}`;
    }
    // Is it a special name, e.g. "alpha", etc...
    if (COMMON_VARIABLE_NAME.includes(s))
        return '\\' + s;
    // Replace special Latex characters
    s = s.replace(/[{}\[\]\\:\-\$%]/g, (c) => ({
        '{': '\\lbrace ',
        '}': '\\rbrace ',
        '[': '\\lbrack ',
        ']': '\\rbrack ',
        ':': '\\colon ',
        '\\': '\\backslash ',
        '-': '\\unicode{"2013}',
    }[c] ?? '\\' + c));
    return s;
}

const DEFAULT_SERIALIZE_LATEX_OPTIONS = {
    invisibleMultiply: '',
    invisiblePlus: '',
    // invisibleApply: '',
    multiply: '\\times',
    missingSymbol: '\\blacksquare',
    // openGroup: '(',
    // closeGroup: ')',
    // divide: '\\frac{#1}{#2}',
    // subtract: '#1-#2',
    // add: '#1+#2',
    // negate: '-#1',
    // squareRoot: '\\sqrt{#1}',
    // nthRoot: '\\sqrt[#2]{#1}',
    applyFunctionStyle: getApplyFunctionStyle,
    groupStyle: getGroupStyle,
    rootStyle: getRootStyle,
    fractionStyle: getFractionStyle,
    logicStyle: getLogicStyle,
    powerStyle: getPowerStyle,
    numericSetStyle: getNumericSetStyle,
};
class LatexSyntax {
    constructor(options) {
        const onError = (warnings) => {
            if (typeof window !== 'undefined') {
                for (const warning of warnings)
                    console.warn(warning.message);
            }
            return;
        };
        this.onError = options.onError ?? onError;
        this.computeEngine = options.computeEngine;
        const opts = { ...options };
        delete opts.dictionary;
        delete opts.onError;
        this.options = {
            ...DEFAULT_LATEX_NUMBER_OPTIONS,
            ...DEFAULT_PARSE_LATEX_OPTIONS,
            ...DEFAULT_SERIALIZE_LATEX_OPTIONS,
            ...opts,
        };
        this.dictionary = indexLatexDictionary(options.dictionary ?? LatexSyntax.getDictionary(), (sig) => this.onError([sig]));
    }
    updateOptions(opt) {
        for (const k of Object.keys(this.options))
            if (k in opt)
                this.options[k] = opt[k];
        this.serializer.updateOptions(opt);
    }
    static getDictionary(category = 'all') {
        if (category === 'all') {
            const result = [];
            for (const domain of Object.keys(DEFAULT_LATEX_DICTIONARY))
                if (DEFAULT_LATEX_DICTIONARY[domain])
                    result.push(...DEFAULT_LATEX_DICTIONARY[domain]);
            return result;
        }
        if (!DEFAULT_LATEX_DICTIONARY[category])
            return [];
        return [...DEFAULT_LATEX_DICTIONARY[category]];
    }
    parse(latex) {
        const parser = new _Parser(tokenize(latex, []), this.options, this.dictionary, this.computeEngine);
        let expr = parser.matchExpression();
        if (!parser.atEnd) {
            // Somethin went wrong, generate error expressin
            const opDefs = parser.peekDefinitions('infix');
            if (opDefs) {
                const start = parser.index;
                const [def, n] = opDefs[0];
                parser.index += n;
                const result = def.parse(parser, { minPrec: 0 }, expr ?? parser.error('missing', start));
                if (result)
                    return result;
                if (def.name) {
                    return [
                        def.name,
                        expr ?? parser.error('missing', start),
                        parser.error('missing', start),
                    ];
                }
                parser.index = start;
            }
            const index = parser.index;
            const closeDelimiter = parser.matchEnclosureOpen();
            if (closeDelimiter) {
                const enclosureError = parser.error(['expected-close-delimiter', closeDelimiter], index);
                return expr ? ['Sequence', expr, enclosureError] : enclosureError;
            }
            const openDelimiter = parser.matchEnclosureClose();
            if (openDelimiter) {
                const enclosureError = parser.error(['expected-open-delimiter', openDelimiter], index);
                return expr ? ['Sequence', expr, enclosureError] : enclosureError;
            }
            const rest = parser.index;
            const token = parser.next();
            while (!parser.atEnd)
                parser.next();
            // Something went wrong, generate error expression
            const error = parser.error([
                token.length > 1 && token.startsWith('\\')
                    ? 'unexpected-command'
                    : 'unexpected-token',
                { str: tokensToString([token]) },
            ], rest);
            expr = expr ? ['Sequence', expr, error] : error;
        }
        expr ?? (expr = ['Sequence']);
        if (this.options.preserveLatex) {
            if (Array.isArray(expr))
                expr = { latex, fn: expr };
            else if (typeof expr === 'number')
                expr = { latex, num: Number(expr).toString() };
            else if (typeof expr === 'string')
                expr = { latex, sym: expr };
            else if (typeof expr === 'object' && expr !== null)
                expr.latex = latex;
        }
        return expr ?? ['Sequence'];
    }
    serialize(expr) {
        return this.serializer.serialize(expr);
    }
    get serializer() {
        if (this._serializer)
            return this._serializer;
        this._serializer = new Serializer(this.options, this.dictionary, this.onError);
        return this._serializer;
    }
}

const MACHINE_PRECISION_BITS = 53;
const MACHINE_PRECISION = Math.log10(Math.pow(2, MACHINE_PRECISION_BITS)); // ≈ 15.95 = number of digits of precision
// Positive values smaller than NUMERIC_TOLERANCE are considered to be zero
const NUMERIC_TOLERANCE = Math.pow(10, -10);
// When applying simplifications, only considers integers whose absolute value
// is less than SMALL_INTEGER. This avoid loss of precision by preventing
// simplification for `1e199 + 1`.
// Note: SMALL_INTEGER ≈ 10^(MACHINE_PRECISION / 2)
// so that the product of two small integers does not lose precision
const SMALL_INTEGER = 1000000;
// When doing a calculation via iteration (e.g. to calculate a sum)
// do not iterate more than this value
const MAX_ITERATION = 1000000;
// When doing a symbolic calculations using multiple terms, do
// not expand beyond these many terms
const MAX_SYMBOLIC_TERMS = 200;
// prettier-ignore
const SMALL_PRIMES = new Set([
    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
    73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,
    157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
    239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317,
    331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,
    421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,
    509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,
    613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,
    709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,
    821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911,
    919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019,
    1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097,
    1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201,
    1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291,
    1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409,
    1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487,
    1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579,
    1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667,
    1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777,
    1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877,
    1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993,
    1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083,
    2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179,
    2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287,
    2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381,
    2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473,
    2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609,
    2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693,
    2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789,
    2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887,
    2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001,
    3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119,
    3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229,
    3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331,
    3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457,
    3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541,
    3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637,
    3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739,
    3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853,
    3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947,
    3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073,
    4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177,
    4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273,
    4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409,
    4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517,
    4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639,
    4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733,
    4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871,
    4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969,
    4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077,
    5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189,
    5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309,
    5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431,
    5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521,
    5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651,
    5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743,
    5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851,
    5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981,
    5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091,
    6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211,
    6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311,
    6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397,
    6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553,
    6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673,
    6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781,
    6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883,
    6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991,
    6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121,
    7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237,
    7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369,
    7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507,
    7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589,
    7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699,
    7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829,
    7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919,
]);
const LARGEST_SMALL_PRIME = 7919;
function primeFactors$1(n) {
    console.assert(Number.isInteger(n) && n >= 0 && n < Number.MAX_SAFE_INTEGER, n);
    //https:rosettacode.org/wiki/Prime_decomposition#JavaScript
    if (n <= 3)
        return { [n]: 1 };
    const result = {};
    // Wheel factorization
    let count = 0;
    while (n % 2 === 0) {
        count += 1;
        n /= 2;
    }
    if (count > 0)
        result[2] = count;
    count = 0;
    while (n % 3 === 0) {
        count += 1;
        n /= 3;
    }
    if (count > 0)
        result[3] = count;
    // @todo: could add more special cases: 5, 7, 11, 13
    let done = false;
    while (!done) {
        if (n === 1)
            return result;
        const sr = Math.sqrt(n);
        done = true;
        for (let i = 6; i <= sr + 6; i += 6) {
            if (n % (i - 1) === 0) {
                // is n divisible by i-1?
                result[i - 1] = (result[i - 1] ?? 0) + 1;
                n /= i - 1;
                done = false;
                break;
            }
            if (n % (i + 1) === 0) {
                // is n divisible by i+1?
                result[i + 1] = (result[i + 1] ?? 0) + 1;
                n /= i + 1;
                done = false;
                break;
            }
        }
    }
    if (result[n] !== undefined)
        result[n] += 1;
    else
        result[n] = 1;
    return result;
}
/* @todo Consider https://cp-algorithms.com/algebra/factorization.html */
/** Return `[factor, root]` such that
 * pow(n, 1/exponent) = factor * pow(root, 1/exponent)
 *
 * factorPower(75, 2) -> [5, 3] = 5^2 * 3
 *
 */
function factorPower$1(n, exponent) {
    if (n >= Number.MAX_SAFE_INTEGER)
        return [1, n];
    // @todo: handle negative n
    console.assert(Number.isInteger(n) && n > 0 && n < Number.MAX_SAFE_INTEGER);
    const factors = primeFactors$1(n);
    let f = 1;
    let r = 1;
    for (const k of Object.keys(factors)) {
        const v = parseInt(k);
        f = f * Math.pow(v, Math.floor(factors[k] / exponent));
        r = r * Math.pow(v, factors[k] % exponent);
    }
    return [f, r];
}
function gcd$1(a, b) {
    if (a === 0)
        return b;
    if (b === 0)
        return a;
    if (a === b)
        return a;
    //https://github.com/Yaffle/bigint-gcd/blob/main/gcd.js
    if (!Number.isInteger(a) || !Number.isInteger(b))
        return NaN;
    while (b !== 0)
        [a, b] = [b, a % b];
    return a < 0 ? -a : a;
}
function factorial$1(n) {
    if (!Number.isInteger(n) || n < 0)
        return NaN;
    let val = 1;
    for (let i = 2; i <= n; i++)
        val = val * i;
    return val;
}
const gammaG$1 = 7;
const lanczos_7_c = [
    0.99999999999980993, 676.5203681218851, -1259.1392167224028,
    771.32342877765313, -176.61502916214059, 12.507343278686905,
    -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7,
];
const gammaGLn = 607 / 128;
const gammaPLn = [
    0.999999999999997, 57.156235665862923, -59.59796035547549, 14.13609797474174,
    -0.4919138160976202, 0.3399464998481188e-4, 0.4652362892704857e-4,
    -0.9837447530487956e-4, 0.1580887032249125e-3, -0.21026444172410488e-3,
    0.2174396181152126e-3, -0.16431810653676389e-3, 0.8441822398385274e-4,
    -0.261908384015814e-4, 0.3689918265953162e-5,
];
// Spouge approximation (suitable for large arguments)
function lngamma$2(z) {
    if (z < 0)
        return NaN;
    let x = gammaPLn[0];
    for (let i = gammaPLn.length - 1; i > 0; --i)
        x += gammaPLn[i] / (z + i);
    const t = z + gammaGLn + 0.5;
    return (0.5 * Math.log(2 * Math.PI) +
        (z + 0.5) * Math.log(t) -
        t +
        Math.log(x) -
        Math.log(z));
}
// From https://github.com/substack/gamma.js/blob/master/index.js
function gamma$2(z) {
    if (z < 0.5)
        return Math.PI / (Math.sin(Math.PI * z) * gamma$2(1 - z));
    if (z > 100)
        return Math.exp(lngamma$2(z));
    z -= 1;
    let x = lanczos_7_c[0];
    for (let i = 1; i < gammaG$1 + 2; i++)
        x += lanczos_7_c[i] / (z + i);
    const t = z + gammaG$1 + 0.5;
    return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
}
function fromDigits(s, base = 10) {
    let value = 0;
    for (let i = 0; i < s.length; i++) {
        const k = {
            ' ': -1,
            '\u00a0': -1,
            '\u2000': -1,
            '\u2001': -1,
            '\u2002': -1,
            '\u2003': -1,
            '\u2004': -1,
            '\u2005': -1,
            '\u2006': -1,
            '\u2007': -1,
            '\u2008': -1,
            '\u2009': -1,
            '\u200a': -1,
            '\u200b': -1,
            '\u202f': -1,
            '\u205f': -1,
            '_': -1,
            ',': -1,
            '0': 0,
            '1': 1,
            '2': 2,
            '3': 3,
            '4': 4,
            '5': 5,
            '6': 6,
            '7': 7,
            '8': 8,
            '9': 9,
            'a': 10,
            'b': 11,
            'c': 12,
            'd': 13,
            'e': 14,
            'f': 15,
            'g': 16,
            'h': 17,
            'i': 18,
            'j': 19,
            'k': 20,
            'l': 21,
            'm': 22,
            'n': 23,
            'o': 24,
            'p': 25,
            'q': 26,
            'r': 27,
            's': 28,
            't': 29,
            'u': 30,
            'v': 31,
            'w': 32,
            'x': 33,
            'y': 34,
            'z': 35,
        }[s[i]];
        if (k !== -1) {
            if (k === undefined)
                return [value, s.substring(i)];
            if (k >= base)
                return [value, s.substring(i)];
            value = value * base + k;
        }
    }
    return [value, ''];
}
function asFloat(expr) {
    const num = expr.numericValue;
    if (num === null)
        return null;
    if (typeof num === 'number')
        return num;
    if (num instanceof Decimal)
        return num.toNumber();
    if (Array.isArray(num)) {
        const [n, d] = num;
        if (typeof n === 'number' && typeof d === 'number')
            return n / d;
        return Number(n) / Number(d);
    }
    console.assert(!(num instanceof Complex) || num.im !== 0);
    return null;
}
function asBignum(expr) {
    const num = expr.numericValue;
    if (num === null)
        return null;
    if (num instanceof Decimal)
        return num;
    if (typeof num === 'number')
        return expr.engine.bignum(num);
    if (Array.isArray(num)) {
        const [n, d] = num;
        if (typeof n === 'number' && typeof d === 'number')
            return expr.engine.bignum(n / d);
        return expr.engine.bignum(n).div(d.toString());
    }
    console.assert(!(num instanceof Complex) || num.im !== 0);
    return null;
}
function asSmallInteger(expr) {
    const num = expr.numericValue;
    if (num === null)
        return null;
    if (typeof num === 'number') {
        if (Number.isInteger(num) && num >= -SMALL_INTEGER && num <= SMALL_INTEGER)
            return num;
        return null;
    }
    if (num instanceof Decimal) {
        if (num.isInteger()) {
            const n = num.toNumber();
            if (n >= -SMALL_INTEGER && n <= SMALL_INTEGER)
                return n;
        }
        return null;
    }
    // If we're canonical, a rational is never a small integer
    if (expr.isCanonical)
        return null;
    // We're not canonical, a rational could be a small integer, i.e. 4/2
    const r = num;
    if (Array.isArray(r)) {
        const [n, d] = r;
        let v;
        if (typeof n === 'number' && typeof d === 'number')
            v = n / d;
        else
            v = Number(n) / Number(d);
        if (Number.isInteger(v) && v >= -SMALL_INTEGER && v <= SMALL_INTEGER)
            return v;
        return null;
    }
    return null;
}
function chop(n, tolerance) {
    if (typeof n === 'number' && Math.abs(n) <= tolerance)
        return 0;
    if (n instanceof Decimal && n.abs().lte(tolerance))
        return 0;
    if (n instanceof Complex &&
        Math.abs(n.re) <= tolerance &&
        Math.abs(n.im) <= tolerance)
        return 0;
    return n;
}

function bigint(a) {
    if (typeof a === 'bigint')
        return a;
    if (a instanceof Decimal)
        return bigint(a.toString());
    // BigInt constructor does not deal well with e.g. `1e30` or `1.2e5`
    let s = a.toString();
    const m = s.match(/([^\.]+)(?:\.([0-9]+))?e(.+)$/);
    if (m) {
        s =
            m[1] +
                (m[2] ?? '') +
                '0'.repeat(parseInt(m[3]) - (m[2] ? m[2].length : 0));
    }
    return BigInt(s);
}
function gcd(a, b) {
    while (b !== BigInt(0))
        [a, b] = [b, a % b];
    return a < 0 ? -a : a;
}
// Difference between primes from 7 to 31
const PRIME_WHEEL_INC = [
    BigInt(4),
    BigInt(2),
    BigInt(4),
    BigInt(2),
    BigInt(4),
    BigInt(6),
    BigInt(2),
    BigInt(6),
];
function primeFactors(d) {
    if (d < Number.MAX_SAFE_INTEGER) {
        const factors = primeFactors$1(Number(d));
        const result = new Map();
        for (const f of Object.keys(factors))
            result.set(bigint(f), factors[f]);
        return result;
    }
    //https:rosettacode.org/wiki/Prime_decomposition#JavaScript
    let n = d;
    const result = new Map();
    // Wheel factorization
    // @todo: see https://github.com/Fairglow/prime-factor/blob/main/src/lib.rs
    let count2 = 0;
    let count3 = 0;
    let count5 = 0;
    let k = BigInt(10);
    while (n % k === BigInt(0)) {
        count2 += 1;
        count5 += 1;
        n = n / k;
    }
    k = BigInt(5);
    while (n % k === BigInt(0)) {
        count5 += 1;
        n = n / k;
    }
    k = BigInt(3);
    while (n % k === BigInt(0)) {
        count3 += 1;
        n = n / k;
    }
    k = BigInt(2);
    while (n % k === BigInt(0)) {
        count2 += 1;
        n = n / k;
    }
    if (count2 > 0)
        result.set('2', count2);
    if (count3 > 0)
        result.set('3', count3);
    if (count5 > 0)
        result.set('5', count5);
    k = BigInt(7);
    let kIndex = '';
    let i = 0;
    while (k * k < n) {
        if (n % k === BigInt(0)) {
            if (!kIndex)
                kIndex = k.toString();
            result.set(kIndex, (result.get(kIndex) ?? 0) + 1);
            n = n / k;
        }
        else {
            k = k + PRIME_WHEEL_INC[i];
            kIndex = '';
            i = i < 7 ? i + 1 : 0;
        }
    }
    if (n !== BigInt(1))
        result.set(n.toString(), (result.get(n.toString()) ?? 0) + 1);
    const r = new Map();
    for (const [k, v] of result)
        r.set(bigint(k), v);
    return r;
}
/** Return `[factor, root]` such that
 * pow(n, 1/exponent) = factor * pow(root, 1/exponent)
 *
 * factorPower(75, 2) -> [5, 3] = 5^2 * 3
 *
 */
function factorPower(n, exponent) {
    // @todo: handle negative n
    const factors = primeFactors(n);
    let f = BigInt(1);
    let r = BigInt(1);
    const exp = bigint(exponent);
    for (const [k, v] of factors) {
        const v2 = bigint(v);
        f = f * k ** (v2 / exp);
        r = r * k ** (v2 % exp);
    }
    return [f, r];
}

function isLatexString(s) {
    if (typeof s === 'string')
        return s.startsWith('$') && s.endsWith('$');
    return false;
}
function latexString(s) {
    if (typeof s === 'string' && s.startsWith('$') && s.endsWith('$'))
        return s.slice(1, -1);
    return null;
}
/**
 * Return a multiple of the imaginary unit, e.g.
 * - 'ImaginaryUnit'
 * - ['Negate', 'ImaginaryUnit']
 * - ['Negate', ['Multiply', 3, 'ImaginaryUnit']]
 * - ['Multiply', 5, 'ImaginaryUnit']
 * - ['Multiply', 'ImaginaryUnit', 5]
 */
function getImaginaryCoef(expr) {
    if (expr.symbol === 'ImaginaryUnit')
        return 1;
    const z = expr.numericValue;
    if (z !== null && z instanceof Complex && z.re === 0)
        return z.im;
    if (expr.head === 'Negate') {
        const v = getImaginaryCoef(expr.op1);
        if (v === null)
            return null;
        return -v;
    }
    if (expr.head === 'Multiply' && expr.nops === 2) {
        if (expr.op1.symbol === 'ImaginaryUnit')
            return asFloat(expr.op2);
        if (expr.op2.symbol === 'ImaginaryUnit')
            return asFloat(expr.op1);
    }
    return 0;
}
/**
 * Return the free symbols in the expression, recursively.
 * A variable, or free symbol, is a symbol that is not bound to a value.
 * Note: do not use `isFree`: it has a side effect of creating a definition
 * if one does not exist, and we want to avoid that. For example, `assume()`
 * relies on `expr.freeVars` *not* creating a definition.
 */
function getFreeVars(expr, set) {
    if (expr.symbol) {
        const def = expr.engine.lookupSymbol(expr.symbol);
        if (def?.value === undefined)
            set.add(expr.symbol);
        return;
    }
    if (!expr.ops && !expr.keys)
        return;
    if (expr.ops)
        for (const op of expr.ops)
            getFreeVars(op, set);
    if (expr.keys)
        for (const key of expr.keys)
            getFreeVars(expr.getKey(key), set);
    return;
}
function getSymbols(expr, set) {
    if (expr.symbol) {
        set.add(expr.symbol);
        return;
    }
    if (!expr.ops && !expr.keys)
        return;
    if (expr.ops)
        for (const op of expr.ops)
            getSymbols(op, set);
    if (expr.keys)
        for (const key of expr.keys)
            getSymbols(expr.getKey(key), set);
    return;
}
function getSubexpressions(expr, head) {
    const result = !head || expr.head === head ? [expr] : [];
    if (expr.ops) {
        for (const op of expr.ops)
            result.push(...getSubexpressions(op, head));
    }
    else if (expr.keys) {
        for (const op of expr.keys)
            result.push(...getSubexpressions(expr.getKey(op), head));
    }
    return result;
}
/**
 * For any numeric result, if `bignumPreferred()` is true, calculate using
 * bignums. If `bignumPreferred()` is false, calculate using machine numbers
 */
function bignumPreferred(ce) {
    return ce.numericMode === 'bignum' || ce.numericMode === 'auto';
}
/** When result of a numeric evaluation is a complex number,
 * return `NaN` if not `complexallowed()`
 */
function complexAllowed(ce) {
    return ce.numericMode === 'auto' || ce.numericMode === 'complex';
}
function hashCode(s) {
    let hash = 0;
    for (let i = 0; i < s.length; i++)
        hash = (Math.imul(31, hash) + s.charCodeAt(i)) | 0; // | 0 to convert to 32-bit int
    return Math.abs(hash);
}
function bigintValue(ce, expr) {
    if (expr === null || expr === undefined)
        return null;
    if (typeof expr === 'number')
        return Number.isInteger(expr) ? bigint(expr) : null;
    if (isNumberExpression(expr)) {
        const num = isNumberObject(expr) ? expr.num.toString() : expr;
        let s = num
            .toLowerCase()
            .replace(/[nd]$/g, '')
            .replace(/[\u0009-\u000d\u0020\u00a0]/g, '');
        if (/\([0-9]+\)/.test(s)) {
            const [_, body, repeat, trail] = s.match(/(.+)\(([0-9]+)\)(.*)$/) ?? [];
            s =
                body +
                    repeat.repeat(Math.ceil(ce.precision / repeat.length)) +
                    (trail ?? '');
        }
        if (s === 'nan')
            return null;
        if (s === 'infinity' || s === '+infinity')
            return null;
        if (s === '-infinity')
            return null;
        if (s.includes('.'))
            return null;
        return bigint(s);
    }
    return null;
}
function asBigint(expr) {
    const num = expr.numericValue;
    if (num === null)
        return null;
    if (typeof num === 'number' && Number.isInteger(num))
        return bigint(num);
    if (num instanceof Decimal && num.isInteger())
        return bigint(num);
    return null;
}

/**
 * Go through all the rules in the rule set, and for all the rules that match
 * return the rhs of the rule applied to `expr`.
 * @param rules
 */
function matchRules(expr, rules, sub) {
    const result = [];
    for (const rule of rules) {
        const r = applyRule(rule, expr, sub);
        if (r !== null)
            result.push(r);
    }
    return result;
}
// @future Generator functions
// export function fixPoint(rule: Rule);
// export function chain(rules: RuleSet);
// @future load rules from JSONC
// - describe conditions with a condition expression:
//    "x.isInteger && y.isFreeOf('x')"
//  or"x:integer && y:freeOf(x)"
// function parseCondition(s:string, lhs: (sub)=> boolean) =>
//    [rest: string, fn: (sub) => boolean]
// @future: priority for rules, sort and apply rules by priority
function boxRules(ce, rs) {
    const result = new Set();
    for (const [rawLhs, rawRhs, options] of rs) {
        // Normalize the condition to a function
        let cond;
        const latex = latexString(options?.condition);
        if (latex) {
            // Substitute any unbound vars in the condition to a wildcard
            const condPattern = ce.pattern(latex);
            cond = (x) => condPattern.subs(x).value?.symbol === 'True';
        }
        else
            cond = options?.condition;
        result.add([
            ce.pattern(rawLhs),
            ce.pattern(rawRhs),
            options?.priority ?? 0,
            cond,
        ]);
    }
    return result;
}
function applyRule([lhs, rhs, _priority, condition], expr, substitution, options) {
    const sub = lhs.match(expr, { substitution, ...options });
    // If the `expr` does not match the pattern, the rule doesn't apply
    if (sub === null)
        return null;
    // If the condition doesn't match, the rule doesn't apply
    if (typeof condition === 'function' && !condition(sub))
        return null;
    // @debug
    // console.log('Applying rule ', lhs.latex, '->', rhs.latex);
    return rhs.subs(sub, { canonical: true });
}
/**
 * Apply the rules in the ruleset and return a modified expression.
 *
 * If no rule applied, return `null`.
 */
function replace(expr, ruleSet, options) {
    const iterationLimit = options?.iterationLimit ?? 1;
    let iterationCount = 0;
    const once = options?.once ?? false;
    let done = false;
    let atLeastOneRule = false;
    try {
        while (!done && iterationCount < iterationLimit) {
            done = true;
            for (const rule of ruleSet) {
                const result = applyRule(rule, expr, {}, options);
                if (result !== null && result !== expr) {
                    // If once flag is set, bail on first matching rule
                    if (once)
                        return result;
                    done = false;
                    atLeastOneRule = true;
                    expr = result;
                }
            }
            iterationCount += 1;
        }
    }
    catch (e) {
        console.error(e);
    }
    return atLeastOneRule ? expr : null;
}
/**
 * Substitute some symbols with an expression.
 *
 * This is applied recursively to all subexpressions.
 *
 * While `replace()` applies a rule which may include expressions in
 * its `lhs` to an expression, `substitute` is a specialized version
 * that only apply rules that have a `lhs` made of a symbol.
 */
// export function substitute(
//   expr: BoxedExpression,
//   substitution: Substitution
// ): Pattern {
//   //
//   // Symbol
//   //
//   const symbol = expr.symbol;
//   if (symbol !== null) return expr.engine.pattern(substitution[symbol] ?? expr);
//   const ce = expr.engine;
//   //
//   // Dictionary
//   //
//   const keys = expr.keys;
//   if (keys !== null) {
//     const result = {};
//     for (const key of keys) result[key] = substitute(keys[key], substitution);
//     return ce.pattern({ dict: result });
//   }
//   // Not a function (or a dictionary or a symbol) => atomic
//   if (expr.ops === null) return ce.pattern(expr);
//   //
//   // Function
//   //
//   const tail: SemiBoxedExpression = [];
//   for (const arg of expr.ops) {
//     const symbol = arg.symbol;
//     if (symbol !== null && symbol.startsWith('__')) {
//       // Wildcard sequence: `__` or `___`
//       const seq = substitution[getWildcardName(symbol)];
//       if (seq === undefined || seq.head !== 'Sequence') {
//         tail.push(symbol);
//       } else {
//         tail.push(...seq.ops!);
//       }
//     } else {
//       tail.push(substitute(arg, substitution));
//     }
//   }
//   return ce.pattern(ce.fn(substitute(ce.box(expr.head), substitution), tail));
// }
function getWildcardName(s) {
    const m = s.match(/^(__?_?[a-zA-Z0-9]+)/);
    if (m === null)
        return '';
    return m[1];
}
// @todo ['Alternatives', ...]:
// @todo: ['Condition',...] : Conditional match
// @todo: ['Repeated',...] : repeating match
// @todo _x:Head or _x:RealNumber

function isRational(x) {
    return x !== null && Array.isArray(x);
}
function isMachineRational(x) {
    return x !== null && Array.isArray(x) && typeof x[0] === 'number';
}
function isBigRational(x) {
    return x !== null && Array.isArray(x) && typeof x[0] === 'bigint';
}
function isRationalZero(x) {
    // Note '==' to convert bigint to number
    return x[0] == 0;
}
function isRationalOne(x) {
    return x[0] === x[1];
}
function isRationalNegativeOne(x) {
    return x[0] === -x[1];
}
function machineNumerator(x) {
    return Number(x[0]);
}
function machineDenominator(x) {
    return Number(x[1]);
}
function isNeg(x) {
    return x[0] < 0;
}
function neg(x) {
    return [-x[0], x[1]];
}
function inverse(x) {
    return x[0] < 0 ? [-x[1], -x[0]] : [x[1], x[0]];
}
function asRational(expr) {
    const num = expr.numericValue;
    if (num === null)
        return undefined;
    if (Array.isArray(num))
        return num;
    if (typeof num === 'number' && Number.isInteger(num))
        return [num, 1];
    if (num instanceof Decimal && num.isInteger())
        return [bigint(num), BigInt(1)];
    return undefined;
}
function asMachineRational(r) {
    return [Number(r[0]), Number(r[1])];
}
/**
 * Add a literal numeric value to a rational.
 * If the rational is a bignum, this is a hint to do the calculation in bignum
 * (no need to check `bignumPreferred()`).
 * @param lhs
 * @param rhs
 * @returns
 */
function add(lhs, rhs) {
    console.assert(Array.isArray(rhs) ||
        (rhs.numericValue !== null && !(rhs instanceof Complex)));
    if (Array.isArray(rhs)) {
        if (isBigRational(rhs)) {
            lhs = [bigint(lhs[0]), bigint(lhs[1])];
            return [rhs[1] * lhs[0] + rhs[0] * lhs[1], rhs[1] * lhs[1]];
        }
        if (isBigRational(lhs)) {
            rhs = [bigint(rhs[0]), bigint(rhs[1])];
            return [rhs[1] * lhs[0] + rhs[0] * lhs[1], rhs[1] * lhs[1]];
        }
        return [rhs[1] * lhs[0] + rhs[0] * lhs[1], rhs[1] * lhs[1]];
    }
    let rhsNum = rhs.numericValue;
    console.assert(rhs.isInteger);
    if (rhsNum !== null && typeof rhsNum === 'number') {
        if (isMachineRational(lhs))
            return [lhs[0] + lhs[1] * rhsNum, lhs[1]];
        return [lhs[0] + lhs[1] * bigint(rhsNum), lhs[1]];
    }
    if (rhsNum instanceof Decimal) {
        if (isMachineRational(lhs))
            lhs = [bigint(lhs[0]), bigint(lhs[1])];
        return [lhs[0] + lhs[1] * bigint(rhsNum.toString()), lhs[1]];
    }
    if (Array.isArray(rhsNum)) {
        if (isMachineRational(rhsNum))
            rhsNum = [bigint(rhsNum[0]), bigint(rhsNum[1])];
        if (isMachineRational(lhs))
            lhs = [bigint(lhs[0]), bigint(lhs[1])];
        return [rhsNum[1] * lhs[0] + rhsNum[0] * lhs[1], rhsNum[1] * lhs[1]];
    }
    debugger;
    return lhs;
}
function mul(lhs, rhs) {
    console.assert(Array.isArray(rhs) ||
        (rhs.numericValue !== null && !(rhs instanceof Complex)));
    if (Array.isArray(rhs)) {
        if (isMachineRational(lhs) && isMachineRational(rhs))
            return [lhs[0] * rhs[0], lhs[1] * rhs[1]];
        if (isMachineRational(lhs))
            lhs = [bigint(lhs[0]), bigint(lhs[1])];
        if (isMachineRational(rhs))
            rhs = [bigint(rhs[0]), bigint(rhs[1])];
        return [lhs[0] * rhs[0], lhs[1] * rhs[1]];
    }
    const rhsNum = rhs.numericValue;
    if (rhsNum !== null && typeof rhsNum === 'number') {
        console.assert(Number.isInteger(rhsNum));
        if (isMachineRational(lhs))
            return [lhs[0] * rhsNum, lhs[1]];
        return [lhs[0] * bigint(rhsNum), lhs[1]];
    }
    if (rhsNum instanceof Decimal) {
        console.assert(rhsNum.isInteger());
        if (isMachineRational(lhs))
            return [bigint(rhsNum.toString()) * bigint(lhs[0]), bigint(lhs[1])];
        return [bigint(rhsNum.toString()) * lhs[0], lhs[1]];
    }
    if (Array.isArray(rhsNum)) {
        if (isBigRational(rhsNum))
            return [rhsNum[0] * bigint(lhs[0]), rhsNum[1] * bigint(lhs[1])];
        else if (isMachineRational(lhs))
            return [lhs[0] * rhsNum[0], lhs[1] * rhsNum[1]];
        return [lhs[0] * bigint(rhsNum[0]), lhs[1] * bigint(rhsNum[1])];
    }
    debugger;
    return lhs;
}
function pow(r, exp) {
    console.assert(Number.isInteger(exp));
    if (exp === 0)
        return [1, 1];
    if (exp < 0) {
        r = inverse(r);
        exp = -exp;
    }
    if (exp === 1)
        return r;
    if (isMachineRational(r))
        return [Math.pow(r[0], exp), Math.pow(r[1], exp)];
    const bigexp = bigint(exp);
    return [r[0] ** bigexp, r[1] ** bigexp];
}
function reducedRational(r) {
    if (isMachineRational(r)) {
        if (r[0] === 1 || r[1] === 1)
            return r;
        if (r[1] < 0)
            r = [-r[0], -r[1]];
        if (!Number.isFinite(r[1]))
            return [0, 1];
        const g = gcd$1(r[0], r[1]);
        //  If the gcd is 0, return the rational unchanged
        return g <= 1 ? r : [r[0] / g, r[1] / g];
    }
    if (r[0] === BigInt(1) || r[1] === BigInt(1))
        return r;
    if (r[1] < 0)
        r = [-r[0], -r[1]];
    const g = gcd(r[0], r[1]);
    //  If the gcd is 0, return the rational unchanged
    if (g <= 1)
        return r;
    return [r[0] / g, r[1] / g];
}
/** Return a rational approximation of x */
function rationalize(x) {
    if (!Number.isFinite(x))
        return x;
    const fractional = x % 1;
    if (fractional === 0)
        return x;
    // const real = x - fractional;
    // const exponent = String(fractional).length - 2; // Number of fractional digits
    // const denominator = Math.pow(10, exponent);
    // const mantissa = fractional * denominator;
    // const numerator = real * denominator + mantissa;
    // const g = gcd(numerator, denominator);
    // return [numerator / g, denominator / g];
    const eps = 1.0e-15;
    let a = Math.floor(x);
    let h1 = 1;
    let k1 = 0;
    let h = a;
    let k = 1;
    while (x - a > eps * k * k) {
        x = 1 / (x - a);
        a = Math.floor(x);
        const h2 = h1;
        h1 = h;
        const k2 = k1;
        k1 = k;
        h = h2 + a * h1;
        k = k2 + a * k1;
    }
    return [h, k];
}
// export function asRationalRoot(
//   expr: BoxedExpression
// ): [numer: number, denom: number] | null {
//   if (expr.head !== 'Sqrt' || !expr.op1.isLiteral) return null;
//   return expr.asRational;
// }
// export function asBigRationalRoot(
//   expr: BoxedExpression
// ): [numer: Decimal, denom: Decimal] | null {
//   if (expr.head !== 'Sqrt' || !expr.op1.isLiteral) return null;
//   return expr.asBigRational;
// }
/**
 * Attempt to factor a rational coefficient `c` and a `rest` out of a
 * canonical expression `expr` such that `ce.mul(c, rest)` is equal to `expr`.
 *
 * Attempts to make `rest` a positive value (i.e. pulls out negative sign).
 *
 *
 * ['Multiply', 2, 'x', 3, 'a', ['Sqrt', 5]]
 *    -> [[6, 1], ['Multiply', 'x', 'a', ['Sqrt', 5]]]
 *
 * ['Divide', ['Multiply', 2, 'x'], ['Multiply', 3, 'y', 'a']]
 *    -> [[2, 3], ['Divide', 'x', ['Multiply, 'y', 'a']]]
 */
function asCoefficient(expr) {
    console.assert(expr.isCanonical);
    const ce = expr.engine;
    //
    // Multiply
    //
    if (expr.head === 'Multiply') {
        const rest = [];
        let coef = [1, 1];
        for (const arg of expr.ops) {
            const n = arg.numericValue;
            if (n !== null &&
                ((typeof n === 'number' && Number.isInteger(n)) ||
                    (n instanceof Decimal && n.isInteger()) ||
                    isRational(n)))
                coef = mul(coef, arg);
            else
                rest.push(arg);
        }
        coef = reducedRational(coef);
        if (isRationalOne(coef))
            return [[1, 1], expr];
        if (rest.length === 0)
            return [coef, ce._ONE];
        if (rest.length === 1)
            return [coef, rest[0]];
        return [coef, ce.mul(rest)];
    }
    //
    // Divide
    //
    if (expr.head === 'Divide') {
        // eslint-disable-next-line prefer-const
        let [coef1, numer] = asCoefficient(expr.op1);
        const [coef2, denom] = asCoefficient(expr.op2);
        const coef = reducedRational(mul(coef1, inverse(coef2)));
        if (denom.isOne)
            return [coef, numer];
        return [coef, ce.div(numer, denom)];
    }
    //
    // Power
    //
    if (expr.head === 'Power') {
        // We can only extract a coef if the exponent is a literal
        if (expr.op2.numericValue === null)
            return [[1, 1], expr];
        // eslint-disable-next-line prefer-const
        let [coef, base] = asCoefficient(expr.op1);
        if (isRationalOne(coef))
            return [[1, 1], expr];
        const exponent = expr.op2;
        const e = asSmallInteger(exponent);
        if (e === -1)
            return [inverse(coef), ce.inv(base)];
        if (e !== null)
            return [pow(coef, e), ce.pow(base, exponent)];
        // The exponent might be a rational (square root, cubic root...)
        if (exponent.numericValue !== null &&
            Array.isArray(exponent.numericValue)) {
            const [en, ed] = asMachineRational(exponent.numericValue);
            const [numer, denom] = asMachineRational(coef);
            if (numer > 0 && Math.abs(en) === 1) {
                const [nCoef, nRest] = factorPower$1(numer, ed);
                const [dCoef, dRest] = factorPower$1(denom, ed);
                if (nCoef === 1 && dCoef === 1)
                    return [[1, 1], expr];
                // en = -1 -> inverse the extracted coef
                return [
                    en === 1 ? [nCoef, dCoef] : [dCoef, nCoef],
                    ce.pow(ce.mul([ce.number([nRest, dRest]), base]), exponent),
                ];
            }
        }
        return [[1, 1], expr];
    }
    //
    // Add
    //
    if (expr.head === 'Add') ;
    //
    // Negate
    //
    if (expr.head === 'Negate') {
        const [coef, rest] = asCoefficient(expr.op1);
        return [neg(coef), rest];
    }
    // @todo:  could consider others.. `Ln`, `Abs`, trig functions
    //
    // Literal
    //
    const n = expr.numericValue;
    if (n !== null) {
        if (n instanceof Decimal) {
            if (n.isInteger())
                return [[bigint(n.toString()), BigInt(1)], ce._ONE];
            if (n.isNegative())
                return [[-1, 1], ce.number(n.neg())];
        }
        if (typeof n === 'number') {
            if (Number.isInteger(n))
                return [[n, 1], ce._ONE];
            if (n < 0)
                return [[-1, 1], ce.number(-n)];
        }
        if (isRational(n))
            return [n, ce._ONE];
        // Make the part positive if the real part is negative
        if (n instanceof Complex && n.re < 0)
            return [[-1, 1], ce.number(ce.complex(-n.re, -n.im))];
    }
    return [[1, 1], expr];
}
/**
 *
 * @param lhs
 * @param rhs
 * @returns the sign (-1, 0, 1) of the difference between `lhs` and `rhs`
 */
function signDiff(lhs, rhs, tolerance) {
    if (lhs === rhs)
        return 0;
    const lhsN = lhs.N();
    const rhsN = rhs.N();
    const lhsNum = lhsN.numericValue;
    const rhsNum = rhsN.numericValue;
    if (lhsNum === null || rhsNum === null) {
        // Couldn't calculate numeric value, use the `sgn` property
        const lhsS = lhs.sgn;
        const rhsS = rhs.sgn;
        if (typeof lhsS !== 'number' || typeof rhsS !== 'number')
            return undefined;
        if (lhsS === 0 && rhsS === 0)
            return 0;
        if (lhsS < 0 && rhsS > 0)
            return -1;
        if (lhsS > 0 && rhsS < 0)
            return +1;
        return undefined;
    }
    tolerance ?? (tolerance = lhs.engine.tolerance);
    if (lhsNum instanceof Complex && rhsNum instanceof Complex)
        return chop(lhsNum.re - rhsNum.re, tolerance) === 0 &&
            chop(lhsNum.im - rhsNum.im, tolerance) === 0
            ? 0
            : undefined;
    if (lhsNum instanceof Complex || rhsNum instanceof Complex)
        return undefined;
    // In general, it is impossible to always prove equality
    // (Richardson's theorem) but this works often...
    // At this point, lhsNum and rhsNum are either number or Decimal
    // (it can't be a rational, because lhs.N() simplifies rationals to number or Decimal)
    if (isRational(lhsNum) || isRational(rhsNum))
        return undefined;
    if (typeof lhsNum === 'number' && typeof rhsNum === 'number') {
        if (chop(rhsNum - lhsNum, tolerance) === 0)
            return 0;
        return lhsNum < rhsNum ? -1 : 1;
    }
    const ce = lhs.engine;
    const delta = ce.bignum(rhsNum).sub(ce.bignum(lhsNum));
    if (chop(delta, tolerance) === 0)
        return 0;
    return delta.isPos() ? 1 : -1;
}

/**
 * Flatten the arguments.
 * If `expr` was canonical, the result it canonical.
 */
function flattenOps(ops, head) {
    if (!head)
        return ops;
    // Bypass memory allocation for the common case where there is nothing to flatten
    if (ops.every((x) => !x.ops || x.head !== head))
        return ops;
    const result = [];
    for (const arg of ops) {
        if (!arg.ops || arg.head !== head)
            result.push(arg);
        else {
            // ["f", a, ["f", b, c]] -> ["f", a, b, c]
            // or ["f", ["f", a]] -> ["f", a]
            result.push(...flattenOps(arg.ops, head));
        }
    }
    // If number of arguments didn't change, we didn't flatten
    console.assert(result.length !== ops.length); // @todo check below may not be necessary
    if (result.length === ops.length)
        return ops;
    return result;
}
function flattenSequence(xs) {
    // Bypass memory allocation for the common case where there are no sequences
    if (xs.every((x) => x.head !== 'Sequence'))
        return xs;
    const ys = [];
    for (const x of xs) {
        if (x.isValid && x.head === 'Sequence') {
            if (x.ops)
                ys.push(...x.ops);
        }
        else
            ys.push(x);
    }
    return ys;
}
function canonical(xs) {
    // Avoid memory allocation if possible
    return xs.every((x) => x.isCanonical) ? xs : xs.map((x) => x.canonical);
}

function negateLiteral(expr, metadata) {
    // Applying negation is safe (doesn't introduce numeric errors)
    // even on floating point numbers
    let n = expr.numericValue;
    if (n === null)
        return null;
    if (typeof n === 'number')
        n = -n;
    else if (n instanceof Decimal)
        n = n.neg();
    else if (n instanceof complex.exports.Complex)
        n = n.neg();
    else if (Array.isArray(n))
        n = neg(n);
    return expr.engine.number(n, { metadata });
}
/**
 * Distribute `Negate` (multiply by -1) if expr is a number literal, an
 * addition or multiplication or another `Negate`.
 *
 * It is important to do all these to handle cases like
 * `-3x` -> ["Negate, ["Multiply", 3, "x"]] -> ["Multiply, -3, x]
 */
function canonicalNegate(expr, metadata) {
    // Negate(Negate(x)) -> x
    if (expr.head === 'Negate')
        return expr.op1;
    if (expr.numericValue !== null)
        return negateLiteral(expr, metadata);
    // Distribute over addition
    // Negate(Add(a, b)) -> Add(Negate(a), Negate(b))
    if (expr.head === 'Add') {
        let ops = expr.ops.map((x) => canonicalNegate(x));
        ops = flattenOps(ops, 'Add');
        return expr.engine.add(ops, metadata);
    }
    // Distribute over multiplication
    // Negate(Multiply(a, b)) -> Multiply(Negate(a), b)
    if (expr.head === 'Multiply') {
        return negateProduct(expr.engine, expr.ops);
    }
    // Distribute over division
    // Negate(Divide(a, b)) -> Divide(Negate(a), b)
    if (expr.head === 'Divide')
        return expr.engine._fn('Divide', [canonicalNegate(expr.op1), expr.op2]);
    // 'Subtract' is canonicalized into `Add`, so don't have to worry about it
    console.assert(expr.head !== 'Subtract');
    return expr.engine._fn('Negate', [expr], metadata);
}
// Given a list of terms in a product, find the "best" one to negate in
// order to negate the entire product:
// 1/ constants over symbols and expressions
// 2/ negative constants over positive ones
// 3/ `Negate` expressions
function negateProduct(ce, args) {
    let result = [];
    let done = false;
    // If there is `Negate` as one of the args, remove it
    for (const arg of args) {
        if (!done && arg.head === 'Negate') {
            done = true;
            result.push(arg.op1);
        }
        else
            result.push(arg);
    }
    if (done)
        return ce.mul(result);
    // else If there is a literal integer, negate it
    result = [];
    for (const arg of args) {
        if (done || arg.numericValue === null || !arg.isInteger)
            result.push(arg);
        else {
            done = true;
            result.push(canonicalNegate(arg));
        }
    }
    if (done)
        return ce.mul(result);
    // else If there is a literal number, negate it
    result = [];
    for (const arg of args) {
        if (done || arg.numericValue === null || !arg.isNumber)
            result.push(arg);
        else {
            done = true;
            result.push(canonicalNegate(arg));
        }
    }
    if (done)
        return ce.mul(result);
    return ce._fn('Negate', [ce._fn('Multiply', args)]);
}
function processNegate(_ce, x, _mode = 'simplify') {
    return canonicalNegate(x);
}

/**
 * Return the expansion of ['Multiply', lhs, rhs]
 * - lhs = 'a + b', rhs = '2'
 *      ->  '2a + 2b'
 * - lhs = 'a + b', rhs = 'a + c'
 *      -> 'a^2 + ac + ab + bc'
 */
function expand2(lhs, rhs) {
    const ce = lhs.engine;
    if (lhs.head === 'Negate' && rhs.head === 'Negate')
        return expand2(lhs.op1, rhs.op1);
    if (lhs.head === 'Negate')
        return canonicalNegate(expand2(lhs.op1, rhs));
    if (rhs.head === 'Negate')
        return canonicalNegate(expand2(lhs, rhs.op1));
    lhs = expand(lhs);
    rhs = expand(rhs);
    if (lhs.head === 'Add')
        return ce.add(lhs.ops.map((x) => expand2(x, rhs)));
    if (rhs.head === 'Add')
        return ce.add(rhs.ops.map((x) => expand2(lhs, x)));
    return ce.mul([lhs, rhs]);
}
function expandN(expr, n) {
    // if (n === 1) return expr;
    // if (n === 2) return expand2(expr, expr);
    // let e = expr;
    // while (n > 1) {
    //   e = expand2(e, expr);
    //   n -= 1;
    // }
    // return e;
    if (n === 1)
        return expr;
    const x2 = expand2(expr, expr);
    if (n === 2)
        return x2;
    if (n % 2 === 0)
        return expandN(x2, n / 2);
    const x = expandN(x2, Math.round(n / 2) - 1);
    return expand2(x, expr);
}
function expand(expr) {
    expr = expr.simplify();
    const ce = expr.engine;
    if (expr.head === 'Add')
        return ce.add(expr.ops.map((x) => expand(x))).simplify();
    if (expr.head === 'Negate')
        return expand2(ce._NEGATIVE_ONE, expr.op1).simplify();
    if (expr.head === 'Subtract')
        return ce
            .add([expand(expr.op1), expand2(ce._NEGATIVE_ONE, expr.op1)])
            .simplify();
    if (expr.head === 'Divide')
        return ce.div(expand(expr.op1), expand(expr.op2)).simplify();
    if (expr.head === 'Multiply') {
        if (expr.nops === 2)
            return expand2(expr.op1, expr.op2);
        return expr.ops.reduce((acc, v) => expand2(acc, v), ce._ONE).simplify();
    }
    if (expr.head === 'Power') {
        const op1head = expr.op1.head;
        if (op1head === 'Multiply')
            return ce.mul(expr.op1.ops.map((x) => ce.pow(x, expr.op2))).simplify();
        if (op1head === 'Negate') {
            const n = asSmallInteger(expr.op2);
            if (n !== null && n > 0) {
                if (n % 2 === 0)
                    return ce.pow(expr.op1.op1, expr.op2).simplify();
                return ce.neg(ce.pow(expr.op1.op1, expr.op2)).simplify();
            }
        }
        if (op1head === 'Add') {
            const n = asSmallInteger(expr.op2);
            if (n !== null) {
                if (n > 0)
                    return expandN(expr.op1, n).simplify();
                return ce.inv(expandN(expr.op1, -n)).simplify();
            }
        }
    }
    return expr.simplify();
}

// https://en.wikipedia.org/wiki/Equation_solving
//
// UNIVARIATE_ROOTS is a collection of rules that find the roots for
// various expressions.
//
// The lhs pattern is a function of (x, a, b)
//
// @todo: MOAR RULES
// x^2, x^2 + a,  a x^2 + b
// \sin(x)...
// polynomials...
// a \sqrt{x} + b
// a \ln x + b
// a e^x + b
//
// cos x, acos x, n cos x + a
// Set of rules to find the root(s) for `x`
// Note: this is not a RuleSet because for each matching pattern, there
// may be more than one solution/root
const UNIVARIATE_ROOTS = [
    // ax = 0
    [['Multiply', '_x', '_a'], ['0']],
    // x + a = 0
    [
        ['Add', '_a', '_x'],
        ['Negate', '_a'],
    ],
    [['Add', ['Negate', '_x'], '_a'], '_a'],
    // ax + b = 0
    [
        ['Add', ['Multiply', '_x', '_a'], '_b'],
        ['Divide', ['Negate', '_b'], '_a'],
    ],
    // Quadratic formula (real)
    // ax^2 + bx + c = 0
    [
        [
            'Add',
            ['Multiply', ['Power', '_x', 2], '_a'],
            ['Multiply', '_x', '_b'],
            '_c',
        ],
        [
            'Divide',
            [
                'Add',
                ['Negate', '_b'],
                ['Sqrt', ['Subtract', ['Square', '_b'], ['Multiply', 4, '_a', '_c']]],
            ],
            ['Multiply', 2, '_a'],
        ],
        // (_ce, vars): boolean => vars.x.isReal === true,
    ],
    [
        [
            'Add',
            ['Multiply', ['Power', '_x', 2], '_a'],
            ['Multiply', '_x', '_b'],
            '_c',
        ],
        [
            'Divide',
            [
                'Subtract',
                ['Negate', '_b'],
                ['Sqrt', ['Subtract', ['Square', '_b'], ['Multiply', 4, '_a', '_c']]],
            ],
            ['Multiply', 2, '_a'],
        ],
        // (_ce, vars): boolean => vars.x.isReal === true,
    ],
    // ax^2 + bx = 0
    [
        ['Add', ['Multiply', ['Power', '_x', 2], '_a'], ['Multiply', '_x', '_b']],
        0,
        // (_ce, vars): boolean => vars.x.isReal === true,
    ],
    [
        ['Add', ['Multiply', ['Power', '_x', 2], '_a'], ['Multiply', '_x', '_b']],
        ['Divide', ['Negate', '_b'], '_a'],
        // (_ce, vars): boolean => vars.x.isReal === true,
    ],
    // ax^2 + b = 0
    [
        ['Add', ['Multiply', ['Power', '_x', 2], '_a'], '_b'],
        ['Sqrt', ['Divide', ['Negate', '_b'], '_a']],
        // (_ce, vars): boolean => vars.x.isReal === true,
    ],
    [
        ['Add', ['Multiply', ['Power', '_x', 2], '_a'], '_b'],
        ['Negate', ['Sqrt', ['Divide', ['Negate', '_b'], '_a']]],
        // (_ce, vars): boolean => vars.x.isReal === true,
    ],
    // Quadratic formula (complex)
    // [
    //   '$ax^2 + bx + c$',
    //   [
    //     '$-\\frac{b}{2a} - \\imaginaryI \\frac{\\sqrt{4ac - b^2}}{2a}$',
    //     '$-\\frac{b}{2a} + \\imaginaryI \\frac{\\sqrt{4ac - b^2}}{2a}$',
    //   ],
    //   (_ce, vars): boolean => vars.x.isImaginary === true,
    // ],
];
/**
 * Expression is a function of a single variable (`x`) or an Equality
 *
 * Return the roots of that variable
 *
 */
function findUnivariateRoots(expr, x) {
    const ce = expr.engine;
    if (expr.head === 'Equal') {
        expr = ce.add([expr.op1.canonical, ce.neg(expr.op2.canonical)]).simplify();
    }
    const rules = ce.cache('univariate-roots-rules', () => boxRules(ce, UNIVARIATE_ROOTS));
    const result = matchRules(expand(expr).subs({ [x]: '_x' }, { canonical: false }), rules, { _x: ce.symbol('_x') });
    // return result;
    return result.map((x) => x.canonical.evaluate());
}

/**
 * Add an assumption, in the form of a predicate, for example:
 *
 * - `x = 5`
 * - `x ∈ ℕ`
 * - `x > 3`
 * - `x + y = 5`
 *
 * Some assumptions are handled separately, specifically, those that can
 * be represented as a symbol definition (equality to an expression,
 * membership to Integer, RealNumber, etc..., >0, <=0, etc...). The result
 * of these are stored directly in the current scope's symbols dictionary
 * (and an entry for the symbol is created if necessary).
 *
 * New assumptions can 'refine' previous assumptions, that is they are valid
 * if they don't contradict previous assumptions. To set new assumptions
 * that contradict previous ones, you must first `forget` about any symbols
 * in the new assumption.
 *
 * Predicates that involve multiple symbols are simplified (for example
 * `x + y = 5` becomes `x + y - 5 = 0`, then stored in the `assumptions` of the
 * current context).
 *
 */
function assume(proposition) {
    if (proposition.head === 'Element')
        return assumeElement(proposition);
    if (proposition.head === 'Equal')
        return assumeEquality(proposition);
    if (isInequality(proposition))
        return assumeInequality(proposition);
    return 'not-a-predicate';
}
function assumeEquality(proposition) {
    console.assert(proposition.head === 'Equal');
    // Four cases:
    // 1/ proposition contains no free variables
    //    e.g. `2 + 1 = 3`, `\pi + 1 = \pi`
    //    => evaluate and return
    // 2/ lhs is a single free variable and `rhs` does not contain `lhs`
    //    e.g. `x = 2`, `x = 2\pi`
    //    => if `lhs` has a definition, set its value to `rhs`, otherwise
    //          define a new symbol with a value of `rhs`
    // 3/ proposition contains a single free variable
    //    => solve for the free variable, create new def or set value of the
    //      free variable with the root(s) as value
    // 4/ proposition contains multiple free variables
    //    => add (lhs - rhs = 0) to assumptions DB
    // Case 1
    const freeVars = proposition.freeVars;
    if (freeVars.length === 0) {
        const val = proposition.evaluate();
        if (val.symbol === 'True')
            return 'tautology';
        if (val.symbol === 'False')
            return 'contradiction';
        console.log(proposition.canonical.evaluate());
        return 'not-a-predicate';
    }
    const ce = proposition.engine;
    // Case 2
    const lhs = proposition.op1.symbol;
    if (lhs && !hasValue(ce, lhs) && !proposition.op2.has(lhs)) {
        const val = proposition.op2.evaluate();
        if (!val.isValid)
            return 'not-a-predicate';
        const def = ce.lookupSymbol(lhs);
        if (!def) {
            ce.defineSymbol(lhs, { value: val });
            return 'ok';
        }
        if (def.domain && !val.domain.isCompatible(def.domain))
            return 'contradiction';
        def.value = val;
        return 'ok';
    }
    // Case 3
    if (freeVars.length === 1) {
        const lhs = freeVars[0];
        const sols = findUnivariateRoots(proposition, lhs);
        if (sols.length === 0) {
            ce.assumptions.set(ce.box([
                'Equal',
                ce
                    .add([proposition.op1.canonical, ce.neg(proposition.op2.canonical)])
                    .simplify(),
                0,
            ]), true);
        }
        const val = sols.length === 1 ? sols[0] : ce.box(['List', ...sols]);
        const def = ce.lookupSymbol(lhs);
        if (!def) {
            ce.defineSymbol(lhs, { value: val });
            return 'ok';
        }
        if (def.domain && !sols.every((sol) => val.domain.isCompatible(sol.domain)))
            return 'contradiction';
        def.value = val;
        return 'ok';
    }
    ce.assumptions.set(proposition, true);
    return 'ok';
}
function assumeInequality(proposition) {
    //
    // 1/ lhs is a single **undefined** free var e.g. "x < 0"
    //    => define a new var, if the domain can be inferred set it, otherwise
    // RealNumber and add to assumptions (e.g. x < 5)
    // 2/ (lhs - rhs) is an expression with no free vars
    //  e.g. "\pi < 5"
    //  => evaluate
    // 3/ (lhs - rhs) is an expression with a single **undefined** free var
    //    e.g. "x + 1 < \pi"
    //    => add def as RealNumber, add to assumptions
    // 4/ (lhs - rhs) is an expression with multiple free vars
    //    e.g. x + y < 0
    //    => add to assumptions
    const ce = proposition.engine;
    // Case 1
    if (proposition.op1.symbol && !hasDef(ce, proposition.op1.symbol)) {
        if (proposition.op2.evaluate().isZero) {
            if (proposition.head === 'Less') {
                ce.defineSymbol(proposition.op1.symbol, {
                    domain: ce.domain('NegativeNumber'),
                });
            }
            else if (proposition.head === 'LessEqual') {
                ce.defineSymbol(proposition.op1.symbol, {
                    domain: ce.domain('NonPositiveNumber'),
                });
            }
            else if (proposition.head === 'Greater') {
                ce.defineSymbol(proposition.op1.symbol, {
                    domain: ce.domain('PositiveNumber'),
                });
            }
            else if (proposition.head === 'GreaterEqual') {
                ce.defineSymbol(proposition.op1.symbol, {
                    domain: ce.domain('NonNegativeNumber'),
                });
            }
        }
        else {
            ce.defineSymbol(proposition.op1.symbol, {
                domain: ce.domain('ExtendedRealNumber'),
            });
            ce.assumptions.set(proposition, true);
        }
        return 'ok';
    }
    // @todo: handle if proposition.op1 *has* a def (and no value)
    // Normalize to Less, LessEqual
    let op = '';
    let lhs;
    let rhs;
    if (proposition.head === 'Less') {
        lhs = proposition.op1;
        rhs = proposition.op2;
        op = '<';
    }
    else if (proposition.head === 'LessEqual') {
        lhs = proposition.op1;
        rhs = proposition.op2;
        op = '<=';
    }
    else if (proposition.head === 'Greater') {
        lhs = proposition.op2;
        rhs = proposition.op1;
        op = '<';
    }
    else if (proposition.head === 'GreaterEqual') {
        lhs = proposition.op2;
        rhs = proposition.op1;
        op = '<=';
    }
    if (!op)
        return 'internal-error';
    const p = ce.add([lhs.canonical, ce.neg(rhs.canonical)]).simplify();
    // Case 2
    const result = ce.box([op === '<' ? 'Less' : 'LessEqual', p, 0]).evaluate();
    if (result.symbol === 'True')
        return 'tautology';
    if (result.symbol === 'False')
        return 'contradiction';
    const freeVars = result.freeVars;
    if (freeVars.length === 0)
        return 'not-a-predicate';
    // Case 3
    if (freeVars.length === 1) {
        if (!ce.lookupSymbol(freeVars[0]))
            ce.defineSymbol(freeVars[0], { domain: 'ExtendedRealNumber' });
    }
    // Case 3, 4
    console.assert(result.head === 'Less' || result.head === 'LessEqual');
    ce.assumptions.set(result, true);
    return 'ok';
}
function assumeElement(proposition) {
    console.assert(proposition.head === 'Element');
    // Four cases:
    // 1/ lhs is a single free variable with no definition
    //    e.g. `x \in \R`
    //    => define a new var with the specified domain
    // 2/ lhs is a symbol with a definition
    //    => update domain, if compatible
    // 3/ lhs is an expression with some free variables with no definition
    //    => add to assumptions DB
    // 4/ otherwise  (expression)
    //    e.g. `x+2 \in \R`
    //    => evaluate and return result (contradiction or tautology)
    const ce = proposition.engine;
    const undefs = undefinedIdentifiers(proposition.op1);
    // Case 1
    if (undefs.length === 1) {
        const dom = ce.domain(proposition.op2.evaluate().json);
        if (!dom.isValid)
            return 'not-a-predicate';
        if (dom.isCompatible('Function'))
            ce.defineFunction(undefs[0], { signature: { domain: 'Function' } });
        else
            ce.defineSymbol(undefs[0], { domain: dom });
        return 'ok';
    }
    // Case 2
    if (proposition.op1.symbol && hasDef(ce, proposition.op1.symbol)) {
        const dom = ce.domain(proposition.op2.evaluate().json);
        if (!dom.isValid)
            return 'not-a-predicate';
        const def = ce.lookupSymbol(proposition.op1.symbol);
        if (def) {
            if (def.domain && !dom.isCompatible(def.domain))
                return 'contradiction';
            def.domain = dom;
            return 'ok';
        }
        const fdef = ce.lookupFunction(proposition.op1.symbol);
        if (fdef?.signature?.domain) {
            if (!dom.isCompatible(fdef.signature.domain))
                return 'contradiction';
            if (dom.isCompatible(fdef.signature.domain, 'bivariant'))
                return 'tautology';
            return 'not-a-predicate';
        }
        return 'ok';
    }
    // Case 3
    if (undefs.length > 0) {
        ce.assumptions.set(proposition, true);
        return 'ok';
    }
    // Case 4
    const val = proposition.evaluate();
    if (val.symbol === 'True')
        return 'tautology';
    if (val.symbol === 'False')
        return 'contradiction';
    return 'not-a-predicate';
}
function hasDef(ce, s) {
    return (ce.lookupSymbol(s) ?? ce.lookupFunction(s)) !== undefined;
}
function undefinedIdentifiers(expr) {
    return expr.symbols.filter((x) => !hasDef(expr.engine, x));
}
function hasValue(ce, s) {
    if (ce.lookupFunction(s))
        return false;
    return ce.lookupSymbol(s)?.value !== undefined;
}
function isInequality(expr) {
    const h = expr.head;
    if (typeof h !== 'string')
        return false;
    return ['Less', 'Greater', 'LessEqual', 'GreaterEqual'].includes(h);
}

/**
 * AbstractBoxedExpression
 */
class AbstractBoxedExpression {
    constructor(ce, metadata) {
        this.engine = ce;
        if (metadata?.latex !== undefined)
            this._latex = metadata.latex;
        if (metadata?.wikidata !== undefined)
            this._wikidata = metadata.wikidata;
    }
    /** `Object.valueOf()`: return a primitive value for the object
     *
     */
    valueOf() {
        if (this.symbol === 'True')
            return true;
        if (this.symbol === 'False')
            return false;
        return (asFloat(this) ?? this.string ?? this.symbol ?? JSON.stringify(this.json));
    }
    /** Object.toString() */
    toString() {
        if (this.symbol)
            return this.symbol;
        if (this.string)
            return this.string;
        const num = this.numericValue;
        if (num !== null) {
            if (typeof num === 'number')
                return num.toString();
            if (isMachineRational(num))
                return `${num[0].toString()}/${num[1].toString()}`;
            if (isBigRational(num))
                return `${num[0].toString()}/${num[1].toString()}`;
            if (num instanceof complex.exports.Complex) {
                const im = num.im === 1 ? '' : num.im === -1 ? '-' : num.im.toString();
                if (num.re === 0)
                    return im + 'i';
                if (num.im < 0)
                    return `${num.re.toString()}${im}i`;
                return `${num.re.toString()}+${im}i`;
            }
        }
        return JSON.stringify(this.json);
    }
    [Symbol.toPrimitive](hint) {
        if (hint === 'number') {
            const v = this.valueOf();
            return typeof v === 'number' ? v : null;
        }
        return this.toString();
    }
    /** Called by `JSON.stringify()` when serializing to json */
    toJSON() {
        return this.json;
    }
    get scope() {
        return null;
    }
    /** Object.is() */
    is(rhs) {
        if (rhs === null || rhs === undefined)
            return false;
        return this.isSame(this.engine.box(rhs));
    }
    get latex() {
        return this._latex ?? this.engine.serialize(this);
    }
    set latex(val) {
        this._latex = val;
    }
    get symbol() {
        return null;
    }
    get isNothing() {
        return false;
    }
    get string() {
        return null;
    }
    getSubexpressions(head) {
        return getSubexpressions(this, head);
    }
    get subexpressions() {
        return this.getSubexpressions('');
    }
    get symbols() {
        const set = new Set();
        getSymbols(this, set);
        return Array.from(set);
    }
    get freeVars() {
        const set = new Set();
        getFreeVars(this, set);
        return Array.from(set);
    }
    get errors() {
        return this.getSubexpressions('Error');
    }
    // Only return non-null for functions
    get ops() {
        return null;
    }
    get nops() {
        return 0;
    }
    get op1() {
        return this.engine.symbol('Nothing');
    }
    get op2() {
        return this.engine.symbol('Nothing');
    }
    get op3() {
        return this.engine.symbol('Nothing');
    }
    get isValid() {
        return true;
    }
    get isPure() {
        return false;
    }
    get isExact() {
        return true;
    }
    /** For a symbol, true if the symbol is a free variable (no value) */
    get isFree() {
        return false;
    }
    /** For a symbol, true if the symbol is a constant (unchangeable value) */
    get isConstant() {
        return false;
    }
    get canonical() {
        return this;
    }
    apply(_fn, _head) {
        return this;
    }
    subs(_sub, options) {
        if (options?.canonical)
            return this.canonical;
        return this;
    }
    solve(_vars) {
        return null;
    }
    replace(_rules) {
        return null;
    }
    has(_v) {
        return false;
    }
    get isNaN() {
        return undefined;
    }
    get isZero() {
        return undefined;
    }
    get isNotZero() {
        return undefined;
    }
    get isOne() {
        return undefined;
    }
    get isNegativeOne() {
        return undefined;
    }
    get isInfinity() {
        return undefined;
    }
    // Not +- Infinity, not NaN
    get isFinite() {
        return undefined;
    }
    get isEven() {
        return undefined;
    }
    get isOdd() {
        return undefined;
    }
    get isPrime() {
        return undefined;
    }
    get isComposite() {
        return undefined;
    }
    get numericValue() {
        return null;
    }
    get sgn() {
        return null;
    }
    isLess(_rhs) {
        return undefined;
    }
    isLessEqual(_rhs) {
        return undefined;
    }
    isGreater(_rhs) {
        return undefined;
    }
    isGreaterEqual(_rhs) {
        return undefined;
    }
    // x > 0
    get isPositive() {
        return undefined;
    }
    // x >= 0
    get isNonNegative() {
        return undefined;
    }
    // x < 0
    get isNegative() {
        return undefined;
    }
    // x <= 0
    get isNonPositive() {
        return undefined;
    }
    //
    //
    //
    //
    //
    isCompatible(_dom, _kind) {
        return false;
    }
    get description() {
        return undefined;
    }
    get url() {
        return undefined;
    }
    get wikidata() {
        return this._wikidata;
    }
    set wikidata(val) {
        this._wikidata = val;
    }
    get complexity() {
        return undefined;
    }
    get basedDefinition() {
        return undefined;
    }
    get symbolDefinition() {
        return undefined;
    }
    get functionDefinition() {
        return undefined;
    }
    bind(_scope) {
        return;
    }
    unbind() {
        return;
    }
    get keys() {
        return null;
    }
    get keysCount() {
        return 0;
    }
    getKey(_key) {
        return undefined;
    }
    hasKey(_key) {
        return false;
    }
    get value() {
        return undefined;
    }
    set value(_value) {
        throw new Error(`Can't change the value of \\(${this.latex}\\)`);
    }
    get domain() {
        return this.engine.domain('Void');
    }
    set domain(_domain) {
        throw new Error(`Can't change the domain of \\(${this.latex}\\)`);
    }
    get explicitDomain() {
        return this.domain;
    }
    get isNumber() {
        return undefined;
    }
    get isInteger() {
        return undefined;
    }
    get isRational() {
        return undefined;
    }
    get isAlgebraic() {
        return false;
    }
    get isReal() {
        return undefined;
    }
    // Real or +-Infinity
    get isExtendedReal() {
        return undefined;
    }
    get isComplex() {
        return undefined;
    }
    get isImaginary() {
        return undefined;
    }
    get isExtendedComplex() {
        return undefined;
    }
    simplify(_options) {
        return this;
    }
    evaluate(options) {
        return this.simplify(options);
    }
    N(_options) {
        return this.evaluate();
    }
}

function factorial(ce, n) {
    if (!n.isInteger() || n.isNegative())
        return ce._BIGNUM_NAN;
    if (n.lessThan(10))
        return ce.bignum([1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800][n.toNumber()]);
    if (n.gt(Number.MAX_SAFE_INTEGER)) {
        let val = ce._BIGNUM_ONE;
        let i = ce._BIGNUM_TWO;
        while (i.lessThan(n)) {
            val = val.mul(i);
            i = i.add(1);
        }
        return val;
    }
    if (n.modulo(2).eq(1)) {
        return n.times(factorial(ce, n.minus(1)));
    }
    let loop = n.toNumber();
    let sum = n;
    let val = n;
    while (loop > 2) {
        loop -= 2;
        sum = sum.add(loop);
        val = val.mul(sum);
    }
    return val;
}
const gammaG = 7;
// Spouge approximation (suitable for large arguments)
function lngamma$1(ce, z) {
    if (z.isNegative())
        return ce._BIGNUM_NAN;
    const GAMMA_P_LN = ce.cache('gamma-p-ln', () => {
        return [
            '0.99999999999999709182',
            '57.156235665862923517',
            '-59.597960355475491248',
            '14.136097974741747174',
            '-0.49191381609762019978',
            '0.33994649984811888699e-4',
            '0.46523628927048575665e-4',
            '-0.98374475304879564677e-4',
            '0.15808870322491248884e-3',
            '-0.21026444172410488319e-3',
            '0.2174396181152126432e-3',
            '-0.16431810653676389022e-3',
            '0.84418223983852743293e-4',
            '-0.2619083840158140867e-4',
            '0.36899182659531622704e-5',
        ].map((x) => ce.bignum(x));
    });
    let x = GAMMA_P_LN[0];
    for (let i = GAMMA_P_LN.length - 1; i > 0; --i) {
        x = x.add(GAMMA_P_LN[i].div(z.add(i)));
    }
    const GAMMA_G_LN = ce.cache('gamma-g-ln', () => ce.bignum(607).div(128));
    const t = z.add(GAMMA_G_LN).add(ce._BIGNUM_HALF);
    return ce._BIGNUM_NEGATIVE_ONE
        .acos()
        .mul(ce._BIGNUM_TWO)
        .log()
        .mul(ce._BIGNUM_HALF)
        .add(t.log().mul(z.add(ce._BIGNUM_HALF)).minus(t).add(x.log()).minus(z.log()));
}
// From https://github.com/substack/gamma.js/blob/master/index.js
function gamma$1(ce, z) {
    if (z.lessThan(ce._BIGNUM_HALF)) {
        const pi = ce._BIGNUM_NEGATIVE_ONE.acos();
        return pi.div(pi
            .mul(z)
            .sin()
            .mul(gamma$1(ce, ce._BIGNUM_ONE.sub(z))));
    }
    if (z.greaterThan(100))
        return lngamma$1(ce, z).exp();
    z = z.sub(1);
    // coefficients for gamma=7, kmax=8  Lanczos method
    // Source: GSL/specfunc/gamma.c
    const LANCZOS_7_C = ce.cache('lanczos-7-c', () => {
        return [
            '0.99999999999980993227684700473478',
            '676.520368121885098567009190444019',
            '-1259.13921672240287047156078755283',
            '771.3234287776530788486528258894',
            '-176.61502916214059906584551354',
            '12.507343278686904814458936853',
            '-0.13857109526572011689554707',
            '9.984369578019570859563e-6',
            '1.50563273514931155834e-7',
        ].map((x) => ce.bignum(x));
    });
    let x = LANCZOS_7_C[0];
    for (let i = 1; i < gammaG + 2; i++)
        x = x.add(LANCZOS_7_C[i].div(z.add(i)));
    const t = z.add(gammaG).add(ce._BIGNUM_HALF);
    return ce._BIGNUM_NEGATIVE_ONE
        .acos()
        .times(ce._BIGNUM_TWO)
        .sqrt()
        .mul(x.mul(t.neg().exp()).mul(t.pow(z.add(ce._BIGNUM_HALF))));
}
/**
 * If the exponent of the bignum is in the range of the exponents
 * for machine numbers,return true.
 */
function isInMachineRange(d) {
    if (!d.isFinite())
        return true; // Infinity and NaN are in machine range
    // Are there too many significant digits?
    // Maximum Safe Integer is 9007199254740991
    // Digits in Decimal are stored by blocks of 7.
    // Three blocks, with the first block = 90 is close to the maximum
    if (d.d.length > 3 || (d.d.length === 3 && d.d[0] >= 90))
        return false;
    console.assert(d.precision() <= 16);
    // Is the exponent within range?
    // With a binary 64 IEEE 754 number:
    // significant bits: 53 -> 15 digits
    // exponent bits: 11. emax = 307, emin = -306)
    return d.e < 308 && d.e > -306;
}
// export function asMachineNumber(d: Decimal): number | null {
//   if (d.precision() < 15 && d.e < 308 && d.e > -306) return d.toNumber();
//   return null;
// }

/**
 * The total degree of an expression is the sum of the
 * of the positive integer degrees of the factors in the expression:
 *
 * `3√2x^5y^3` -> 8 (5 + 3)
 */
function totalDegree(expr) {
    if (expr.head === 'Power' && expr.op2.numericValue !== null) {
        const deg = asSmallInteger(expr.op2);
        if (deg !== null && deg > 0)
            return deg;
        return 1;
    }
    if (expr.head === 'Multiply') {
        let deg = 1;
        for (const arg of expr.ops) {
            const t = totalDegree(arg);
            if (t > 1)
                deg = deg + t;
        }
        return deg;
    }
    return 1;
}
/**
 * The max degree of an expression is the largest positive integer degree
 * in the factors of the expression
 *
 * `3√2x^5y^3` -> 5
 *
 */
function maxDegree(expr) {
    if (expr.head === 'Power' && expr.op2.numericValue !== null) {
        const deg = asSmallInteger(expr.op2);
        if (deg !== null && deg > 0)
            return deg;
        return 1;
    }
    if (expr.head === 'Multiply') {
        let deg = 1;
        for (const arg of expr.ops)
            deg = Math.max(deg, totalDegree(arg));
        return deg;
    }
    return 1;
}
/**
 * Return a lexicographic key of the expression
 */
function lex(expr) {
    if (expr.symbol)
        return expr.symbol;
    if (expr.ops) {
        const h = typeof expr.head === 'string' ? expr.head : lex(expr.head);
        return (h +
            '"' +
            expr.ops
                .map((x) => lex(x))
                .filter((x) => x.length > 0)
                .join('"'));
    }
    return '';
}

const DEFAULT_COMPLEXITY = 100000;
/**
 * Sort by higher total degree (sum of degree), if tied, sort by max degree,
 * if tied,
 */
function sortAdd(ce, ops) {
    return ops.sort((a, b) => {
        const aLex = lex(a);
        const bLex = lex(b);
        if (!aLex && !bLex)
            return order(a, b);
        if (!aLex)
            return +1;
        if (!bLex)
            return -1;
        if (aLex < bLex)
            return -1;
        if (aLex > bLex)
            return +1;
        const aTotalDeg = totalDegree(a);
        const bTotalDeg = totalDegree(b);
        if (aTotalDeg !== bTotalDeg)
            return bTotalDeg - aTotalDeg;
        const aMaxDeg = maxDegree(a);
        const bMaxDeg = maxDegree(b);
        if (aMaxDeg !== bMaxDeg)
            return aMaxDeg - bMaxDeg;
        return order(a, b);
    });
}
// export function isSorted(expr: BoxedExpression): BoxedExpression {
// }
/**
 * Given two expressions `a` and `b`, return:
 * - `-1` if `a` should be ordered before `b`
 * - `+1` if `b` should be ordered before `a`
 * - `0` if they have the same order (they are structurally equal)
 *
 * The default order is as follow:
 *
 * 1/ Literal numeric values (rational,  machine numbers and Decimal numbers),
 *  ordered by they numeric value (smaller numbers before larger numbers)
 *
 * 2/ Literal complex numbers, ordered by their real parts. In case of a tie,
 * ordered by the absolute value of their imaginary parts. In case of a tie,
 * ordered by the value of their imaginary parts.
 *
 * 3/ Symbols, ordered by their name as strings
 *
 * 4/ Addition, ordered as a polynom, with higher degree terms first
 *
 * 5/ Other functions, ordered by their `complexity` property. In case
 * of a tie, ordered by the head of the expression as a string. In case of a
 * tie, by the leaf count of each expression. In case of a tie, by the order
 * of each argument, left to right.
 *
 * 6/ Strings, ordered by comparing their Unicode code point values. While this
 * sort order is quick to calculate, it can produce unexpected results, for
 * example "E" < "e" < "È" and "11" < "2". This ordering is not suitable to
 * collate natural language strings.
 *
 * 7/ Dictionaries, ordered by the number of keys. If there is a tie, by the
 * sum of the complexities of the values of the dictionary
 *
 *
 */
function order(a, b) {
    // console.assert(a.isCanonical && b.isCanonical);
    if (a === b)
        return 0;
    if (a.numericValue !== null && a.numericValue === b.numericValue)
        return 0;
    //
    //  1/ Literal numeric values
    //
    const af = asFloat(a);
    if (af !== null) {
        const bf = asFloat(b);
        if (bf !== null)
            return af - bf;
        return -1;
    }
    //
    // 2/ Complex numbers
    //
    if (a.numericValue instanceof Complex) {
        if (b.numericValue instanceof Complex) {
            if (a.numericValue.re === b.numericValue.re) {
                if (Math.abs(a.numericValue.im) === Math.abs(b.numericValue.im)) {
                    return a.numericValue.im - b.numericValue.im;
                }
                return Math.abs(a.numericValue.im) - Math.abs(b.numericValue.im);
            }
            return a.numericValue.re - b.numericValue.re;
        }
        if (b.numericValue !== null)
            return +1;
        return -1;
    }
    if (a.numericValue) {
        if (b.numericValue) {
            return +1;
        }
        return -1;
    }
    if (a.head === 'Sqrt' && a.op1.numericValue) {
        if (b.head === 'Sqrt' && b.op1.numericValue)
            return order(a.op1, b.op1);
        return -1;
    }
    //
    // 3/ Symbols
    //
    if (a.symbol) {
        if (b.symbol) {
            if (a.symbol === b.symbol)
                return 0;
            return a.symbol > b.symbol ? 1 : -1;
        }
        if (b.numericValue !== null)
            return +1;
        return -1;
    }
    //
    // 4/ Additive functions
    // The `Add` function has a custom `order` handler
    // @todo
    //
    // 5/ Functions
    //
    if (a.ops) {
        if (b.ops) {
            // Note: we may not have a function definition if it's
            // an "anonymous" function, i.e. `f` in `f(x)`
            const aComplexity = a.functionDefinition?.complexity ?? DEFAULT_COMPLEXITY;
            const bComplexity = b.functionDefinition?.complexity ?? DEFAULT_COMPLEXITY;
            if (aComplexity === bComplexity) {
                if (typeof a.head === 'string' && typeof b.head === 'string') {
                    if (a.head === b.head) {
                        return getLeafCount(a) - getLeafCount(b);
                    }
                    if (a.head < b.head)
                        return +1;
                    return -1;
                }
                return getLeafCount(a) - getLeafCount(b);
            }
            return aComplexity - bComplexity;
        }
        if (b.numericValue !== null || b.symbol)
            return +1;
        return -1;
    }
    //
    // 6/ Strings
    //
    if (a.string) {
        if (b.string) {
            // Order strings by their length, then by their lexicographic order
            if (a.string.length !== b.string.length)
                return b.string.length - a.string.length;
            if (b.string < a.string)
                return -1;
            if (a.string > b.string)
                return +1;
            return 0;
        }
        if (b.keys)
            return -1;
        return +1;
    }
    //
    // 7/ Dictionaries
    //
    if (a.keys && b.keys) {
        if (a.keysCount !== b.keysCount)
            return b.keysCount - a.keysCount;
        let bComplexity = 0;
        let aComplexity = 0;
        for (const key of b.keys)
            bComplexity += b.getKey(key).complexity ?? DEFAULT_COMPLEXITY;
        for (const key of a.keys)
            aComplexity += a.getKey(key).complexity ?? DEFAULT_COMPLEXITY;
        return aComplexity - bComplexity;
    }
    return ((a.complexity ?? DEFAULT_COMPLEXITY) - (b.complexity ?? DEFAULT_COMPLEXITY));
}
/** Get the number of atomic elements in the expression */
function getLeafCount(expr) {
    if (expr.keys !== null)
        return 1 + expr.keysCount;
    if (!expr.ops)
        return 1;
    return ((typeof expr.head === 'string' ? 1 : getLeafCount(expr.head)) +
        [...expr.ops].reduce((acc, x) => acc + getLeafCount(x), 0));
}

/**
 * Group terms in a product by common term.
 *
 * All the terms should be canonical.
 * - the arguments should have been flattened for `Multiply`
 *
 * - any argument of power been factored out, i.e.
 *      (ab)^2 ->  a^2 b^2
 * *
 * 3 + √5 + √(x+1) + x^2 + (a+b)^2 + d
 *  -> [ [[3, "d"], [1, 1]],
 *       [[5, "x+1"], [1, 2]],
 *       [[x, "a+b"], [2, 1]]
 *      ]
 *
 */
class Product {
    constructor(ce, xs, options) {
        // Other terms of the product, `term` is the key
        this._terms = [];
        this._hasInfinity = false;
        this._hasZero = false;
        // If `false`, the running products are not calculated
        this._isCanonical = true;
        options ?? (options = {});
        if (!('canonical' in options))
            options.canonical = true;
        this._isCanonical = options.canonical;
        this.engine = ce;
        this._sign = 1;
        this._rational = bignumPreferred(ce) ? [BigInt(1), BigInt(1)] : [1, 1];
        // this._squareRootRational = this._rational;
        this._complex = Complex.ONE;
        this._bignum = ce._BIGNUM_ONE;
        this._number = 1;
        if (xs)
            for (const x of xs)
                this.addTerm(x);
    }
    get isEmpty() {
        if (!this._isCanonical)
            return this._terms.length === 0;
        return (this._terms.length === 0 &&
            this._hasInfinity === false &&
            this._hasZero === false &&
            this._sign === 1 &&
            isRationalOne(this._rational) &&
            // isRationalOne(this._squareRootRational) &&
            this._complex.re === 1 &&
            this._complex.im === 0 &&
            this._bignum.eq(this.engine._BIGNUM_ONE) &&
            this._number === 1);
    }
    /**
     * Add a term to the product.
     *
     * If `this._isCanonical` a running product of exact terms is kept.
     * Otherwise, terms and their exponent are tallied.
     */
    addTerm(term) {
        console.assert(term.isCanonical);
        if (term.head === 'Multiply') {
            for (const t of term.ops)
                this.addTerm(t);
            return;
        }
        if (this._isCanonical) {
            if (term.isNothing)
                return;
            // If we're calculation a canonical  product, fold exact literals into
            // running terms
            if (term.numericValue !== null) {
                if (term.isOne)
                    return;
                if (term.isZero) {
                    this._hasZero = true;
                    return;
                }
                if (term.isNegativeOne) {
                    this._sign *= -1;
                    return;
                }
                if (term.isInfinity) {
                    this._hasInfinity = true;
                    if (term.isNegative)
                        this._sign *= -1;
                    return;
                }
                let num = term.numericValue;
                if (typeof num === 'number') {
                    if (num < 0) {
                        this._sign *= -1;
                        num = -num;
                    }
                    if (Number.isInteger(num))
                        this._rational = mul(this._rational, [num, 1]);
                    else if (bignumPreferred(this.engine))
                        this._bignum = this._bignum.mul(num);
                    else
                        this._number *= num;
                    return;
                }
                if (num instanceof Decimal) {
                    if (num.isNegative()) {
                        this._sign *= -1;
                        num = num.neg();
                    }
                    if (num.isInteger())
                        this._rational = mul(this._rational, [bigint(num), BigInt(1)]);
                    else if (bignumPreferred(this.engine))
                        this._bignum = this._bignum.mul(num);
                    else
                        this._number *= num.toNumber();
                    return;
                }
                if (num instanceof Complex) {
                    this._complex = this._complex.mul(num);
                    return;
                }
                if (isRational(num)) {
                    this._rational = mul(this._rational, num);
                    if (isNeg(this._rational)) {
                        this._sign *= -1;
                        this._rational = neg(this._rational);
                    }
                    return;
                }
            }
        }
        let rest = term;
        if (this._isCanonical) {
            // If possible, factor out a rational coefficient
            let coef;
            [coef, rest] = asCoefficient(term);
            this._rational = mul(this._rational, coef);
            if (isNeg(this._rational)) {
                this._sign *= -1;
                this._rational = neg(this._rational);
            }
        }
        // Note: rest should be positive, so no need to handle the -1 case
        if (rest.numericValue !== null && rest.isOne)
            return;
        // If this is a power expression, extract the exponent
        let exponent = [1, 1];
        if (rest.head === 'Power') {
            // Term is `Power(op1, op2)`
            const r = asRational(rest.op2);
            if (r) {
                exponent = r;
                rest = rest.op1;
            }
        }
        else if (rest.head === 'Divide') {
            this.addTerm(rest.op1);
            exponent = [-1, 1];
            rest = rest.op2;
        }
        // Look for the base, and add the exponent if already in the list of terms
        let found = false;
        for (const x of this._terms) {
            if (x.term.isSame(rest)) {
                x.exponent = add(x.exponent, exponent);
                found = true;
                break;
            }
        }
        if (!found)
            this._terms.push({ term: rest, exponent });
    }
    unitTerms(mode) {
        const ce = this.engine;
        if (mode === 'numeric') {
            if (!complexAllowed(ce) && this._complex.im !== 0)
                return null;
            // Collapse all numeric literals
            if (bignumPreferred(ce)) {
                let b = ce._BIGNUM_ONE;
                if (!isRationalOne(this._rational)) {
                    if (isBigRational(this._rational))
                        b = ce
                            .bignum(this._rational[0].toString())
                            .div(ce.bignum(this._rational[1].toString()));
                    else
                        b = ce.bignum(this._rational[0]).div(this._rational[1]);
                }
                b = b.mul(this._bignum).mul(this._sign * this._number);
                if (this._complex.im !== 0) {
                    const z = this._complex.mul(b.toNumber());
                    if (z.equals(1))
                        return [];
                    return [{ exponent: [1, 1], terms: [ce.number(z)] }];
                }
                b = b.mul(this._complex.re);
                if (b.equals(1))
                    return [];
                return [{ exponent: [1, 1], terms: [ce.number(b)] }];
            }
            // Machine preferred
            let n = 1;
            if (!isRationalOne(this._rational)) {
                if (isBigRational(this._rational))
                    n = Number(this._rational[0]) / Number(this._rational[1]);
                else
                    n = this._rational[0] / this._rational[1];
            }
            n *= this._sign * this._number * this._bignum.toNumber();
            if (this._complex.im !== 0) {
                const z = this._complex.mul(n);
                if (z.equals(1))
                    return [];
                return [{ exponent: [1, 1], terms: [ce.number(z)] }];
            }
            n *= this._complex.re;
            if (n === 1)
                return [];
            return [{ exponent: [1, 1], terms: [ce.number(n)] }];
        }
        //
        // Terms of degree 1 (exponent = [1,1])
        //
        const xs = [];
        const unitTerms = [];
        if (this._hasInfinity)
            unitTerms.push(ce._POSITIVE_INFINITY);
        this._rational = reducedRational(this._rational);
        // this._squareRootRational = reducedRational(this._squareRootRational);
        // Complex
        if (this._complex.re !== 1 || this._complex.im !== 0) {
            if (this._complex.im === 0)
                this._number *= Math.abs(this._complex.re);
            if (this._complex.re < 0)
                this._rational = neg(this._rational);
            else {
                unitTerms.push(ce.number(this._complex));
            }
        }
        let n = this._sign * this._number;
        let b = this._bignum;
        if (!isRationalOne(this._rational)) {
            if (mode === 'rational') {
                if (machineNumerator(this._rational) !== 1) {
                    if (isBigRational(this._rational))
                        b = b.mul(ce.bignum(this._rational[0]));
                    else
                        n *= this._rational[0];
                }
                if (machineDenominator(this._rational) !== 1)
                    xs.push({
                        exponent: [-1, 1],
                        terms: [ce.number(this._rational[1])],
                    });
            }
            else {
                if (n === -1) {
                    unitTerms.push(ce.number(neg(this._rational)));
                    n = 1;
                }
                else
                    unitTerms.push(ce.number(this._rational));
            }
        }
        // Literal
        if (!b.equals(ce._BIGNUM_ONE))
            unitTerms.push(ce.number(b.mul(n)));
        else if (n !== 1)
            unitTerms.push(ce.number(n));
        if (unitTerms.length > 0)
            xs.push({ exponent: [1, 1], terms: unitTerms });
        return xs;
    }
    /** The terms of the product, grouped by degrees.
     *
     * If `mode` is `rational`, rationals are split into separate numerator and
     * denominator, so that a rational expression can be created later
     * If `mode` is `expression`, a regular expression is returned, without
     * splitting rationals
     * If `mode` is `numeric`, the literals are combined into one expression
     *
     */
    groupedByDegrees(options) {
        options ?? (options = {});
        if (!('mode' in options))
            options.mode = 'expression';
        const ce = this.engine;
        if (options.mode === 'numeric') {
            if (this._complex.im !== 0 && !complexAllowed(ce))
                return null;
            if (this._hasInfinity)
                return [{ exponent: [1, 1], terms: [ce._POSITIVE_INFINITY] }];
        }
        const xs = this.unitTerms(options.mode ?? 'expression');
        if (xs === null)
            return null;
        //
        // Other terms
        //
        for (const t of this._terms) {
            // Exponent of 0 indicate a term that has been simplified, i.e. `x/x`
            const exponent = reducedRational(t.exponent);
            if (exponent[0] === 0)
                continue;
            let found = false;
            for (const x of xs) {
                if (exponent[0] === x.exponent[0] && exponent[1] === x.exponent[1]) {
                    x.terms.push(t.term);
                    found = true;
                    break;
                }
            }
            if (!found)
                xs.push({ exponent, terms: [t.term] });
        }
        return xs;
    }
    asExpression(mode = 'evaluate') {
        const ce = this.engine;
        if (this._hasInfinity) {
            if (this._hasZero)
                return ce._NAN;
            if (this._terms.length === 0) {
                if (machineNumerator(this._rational) > 0)
                    return ce._POSITIVE_INFINITY;
                return ce._NEGATIVE_INFINITY;
            }
        }
        if (this._hasZero)
            return ce._ZERO;
        const groupedTerms = this.groupedByDegrees({
            mode: mode === 'N' ? 'numeric' : 'expression',
        });
        if (groupedTerms === null)
            return ce._NAN;
        const terms = termsAsExpressions(ce, groupedTerms);
        if (terms.length === 0)
            return ce._ONE;
        if (terms.length === 1)
            return terms[0];
        return this.engine._fn('Multiply', terms);
    }
    /** The product, expressed as a numerator and denominator */
    asNumeratorDenominator() {
        const xs = this.groupedByDegrees({ mode: 'rational' });
        if (xs === null)
            return [this.engine._NAN, this.engine._NAN];
        const xsNumerator = [];
        const xsDenominator = [];
        for (const x of xs)
            if (x.exponent[0] >= 0)
                xsNumerator.push(x);
            else
                xsDenominator.push({
                    exponent: neg(x.exponent),
                    terms: x.terms,
                });
        const ce = this.engine;
        const numeratorTerms = termsAsExpressions(ce, xsNumerator);
        let numerator = ce._ONE;
        if (numeratorTerms.length === 1)
            numerator = numeratorTerms[0];
        else if (numeratorTerms.length > 0)
            numerator = ce._fn('Multiply', numeratorTerms);
        const denominatorTerms = termsAsExpressions(ce, xsDenominator);
        let denominator = ce._ONE;
        if (denominatorTerms.length === 1)
            denominator = denominatorTerms[0];
        else if (denominatorTerms.length > 0)
            denominator = ce._fn('Multiply', denominatorTerms);
        return [numerator, denominator];
    }
    asRationalExpression() {
        const [numerator, denominator] = this.asNumeratorDenominator();
        if (denominator.numericValue !== null) {
            if (denominator.isOne)
                return numerator;
            if (denominator.isNegativeOne)
                return this.engine.neg(numerator);
        }
        return this.engine._fn('Divide', [numerator, denominator]);
    }
}
// Put the exponents in a bucket:
// - exponent 1
// - positive integer exponents
// - positive fractional exponents
// - negative integer exponents
// - negative fractional exponents
function degreeKey(exponent) {
    if (isRationalOne(exponent))
        return 0;
    const [n, d] = [machineNumerator(exponent), machineDenominator(exponent)];
    if (n > 0 && Number.isInteger(n / d))
        return 1;
    if (n > 0)
        return 2;
    if (Number.isInteger(n / d))
        return 3;
    return 4;
}
function degreeOrder(a, b) {
    const keyA = degreeKey(a.exponent);
    const keyB = degreeKey(b.exponent);
    if (keyA !== keyB)
        return keyA - keyB;
    const [a_n, a_d] = [
        machineNumerator(a.exponent),
        machineDenominator(a.exponent),
    ];
    const [b_n, b_d] = [
        machineNumerator(b.exponent),
        machineDenominator(b.exponent),
    ];
    return a_n / a_d - b_n / b_d;
}
function termsAsExpressions(ce, terms) {
    const result = terms.sort(degreeOrder).map((x) => {
        const t = flattenOps(x.terms, 'Multiply');
        const base = t.length <= 1 ? t[0] : ce._fn('Multiply', t.sort(order));
        if (isRationalOne(x.exponent))
            return base;
        return ce.pow(base, x.exponent);
    });
    return flattenOps(result, 'Multiply') ?? result;
}

function subtract(ce, a, b, metadata) {
    if (a.numericValue !== null) {
        if (isRational(a.numericValue)) {
            if (machineNumerator(a.numericValue) < 0) {
                return serializeJsonFunction(ce, 'Subtract', [b, ce.number(neg(a.numericValue))], metadata);
            }
            return null;
        }
        const t0 = asSmallInteger(a);
        if (t0 !== null && t0 < 0)
            return serializeJsonFunction(ce, 'Subtract', [b, ce.number(-t0)], metadata);
    }
    if (a.head === 'Negate')
        return serializeJsonFunction(ce, 'Subtract', [b, a.op1], metadata);
    return null;
}
/**
 * The canonical version of `serializeJsonFunction()` applies
 * additional transformations to "reverse" some of the effects
 * of canonicalization (or boxing), for example it uses `Divide`
 * instead of `Multiply`/`Power` when applicable.
 */
function serializeJsonCanonicalFunction(ce, head, args, metadata) {
    const exclusions = ce.jsonSerializationOptions.exclude;
    if (head === 'Add' && args.length === 2 && !exclusions.includes('Subtract')) {
        const sub = subtract(ce, args[0], args[1], metadata) ??
            subtract(ce, args[1], args[0], metadata);
        if (sub)
            return sub;
    }
    if (head === 'Divide' && args.length === 2 && exclusions.includes('Divide')) {
        return serializeJsonFunction(ce, 'Multiply', [args[0], ce._fn('Power', [args[1], ce._NEGATIVE_ONE])], metadata);
    }
    if (head === 'Multiply' && !exclusions.includes('Negate')) {
        if (asFloat(args[0]) === -1)
            return serializeJsonFunction(ce, 'Negate', [ce._fn('Multiply', args.slice(1))], metadata);
    }
    if (head === 'Multiply' && !exclusions.includes('Divide')) {
        // Display a product with negative exponents as a division if
        // there are terms with a negative degree
        const result = new Product(ce, args, {
            canonical: false,
        }).asRationalExpression();
        if (result.head === 'Divide')
            return serializeJsonFunction(ce, result.head, result.ops, metadata);
    }
    if (head === 'Power') {
        if (!exclusions.includes('Exp') && args[0]?.symbol === 'ExponentialE')
            return serializeJsonFunction(ce, 'Exp', [args[1]], metadata);
        if (args[1]?.numericValue !== null) {
            const exp = asSmallInteger(args[1]);
            if (exp === 2 && !exclusions.includes('Square'))
                return serializeJsonFunction(ce, 'Square', [args[0]], metadata);
            if (exp !== null && exp < 0 && !exclusions.includes('Divide')) {
                return serializeJsonFunction(ce, 'Divide', [ce._ONE, exp === -1 ? args[0] : ce.pow(args[0], -exp)], metadata);
            }
            const r = args[1].numericValue;
            if (!exclusions.includes('Sqrt') && r === 0.5)
                return serializeJsonFunction(ce, 'Sqrt', [args[0]], metadata);
            if (!exclusions.includes('Sqrt') && r === -0.5)
                return serializeJsonFunction(ce, 'Divide', [ce._ONE, ce._fn('Sqrt', [args[0]])], metadata);
            if (isRational(r)) {
                const n = machineNumerator(r);
                const d = machineDenominator(r);
                if (n === 1) {
                    if (!exclusions.includes('Sqrt') && d === 2)
                        return serializeJsonFunction(ce, 'Sqrt', [args[0]], metadata);
                    if (!exclusions.includes('Root'))
                        return serializeJsonFunction(ce, 'Root', [args[0], ce.number(r[1])], metadata);
                }
                if (n === -1) {
                    if (!exclusions.includes('Sqrt') && d === 2)
                        return serializeJsonFunction(ce, 'Divide', [ce._ONE, ce._fn('Sqrt', [args[0]])], metadata);
                    if (!exclusions.includes('Root'))
                        return serializeJsonFunction(ce, 'Divide', [ce._ONE, ce._fn('Root', [args[0], ce.number(r[1])])], metadata);
                }
            }
        }
    }
    return serializeJsonFunction(ce, head, args, metadata);
}
function serializeJsonFunction(ce, head, args, metadata) {
    // Special case some functions...
    const exclusions = ce.jsonSerializationOptions.exclude;
    if ((head === 'Rational' || head === 'Divide') &&
        args.length === 2 &&
        asSmallInteger(args[0]) === 1 &&
        asSmallInteger(args[1]) === 2 &&
        !exclusions.includes('Half')) {
        return serializeJsonSymbol(ce, 'Half', {
            ...metadata,
            wikidata: 'Q39373172',
        });
    }
    if (args.length === 1) {
        const num0 = args[0].numericValue;
        if (head === 'Negate' && num0 !== null) {
            if (typeof num0 === 'number')
                return serializeJsonNumber(ce, -num0);
            if (num0 instanceof Decimal)
                return serializeJsonNumber(ce, num0.neg());
            if (num0 instanceof complex.exports.Complex)
                return serializeJsonNumber(ce, num0.neg());
            if (isRational(num0))
                return serializeJsonNumber(ce, neg(num0));
        }
    }
    if (typeof head === 'string' && exclusions.includes(head)) {
        if (head === 'Rational' && args.length === 2)
            return serializeJsonFunction(ce, 'Divide', args, metadata);
        if (head === 'Complex' && args.length === 2)
            return serializeJsonFunction(ce, 'Add', [args[0], ce._fn('Multiply', [args[1], ce.symbol('ImaginaryUnit')])], metadata);
        if (head === 'Sqrt' && args.length === 1)
            return serializeJsonFunction(ce, 'Power', [args[0], exclusions.includes('Half') ? ce.number([1, 2]) : ce._HALF], metadata);
        if (head === 'Root' && args.length === 2 && args[1].numericValue !== null) {
            const n = asSmallInteger(args[1]);
            if (n === 2)
                return serializeJsonFunction(ce, 'Sqrt', [args[0]]);
            if (n !== null) {
                if (n < 0)
                    return serializeJsonFunction(ce, 'Divide', [ce._ONE, ce._fn('Power', [args[0], ce.number([1, -n])])], metadata);
                return serializeJsonFunction(ce, 'Power', [args[0], ce.number([1, -n])], metadata);
            }
        }
        if (head === 'Square' && args.length === 1)
            return serializeJsonFunction(ce, 'Power', [args[0], ce.number(2)], metadata);
        if (head === 'Exp' && args.length === 1)
            return serializeJsonFunction(ce, 'Power', [ce.symbol('ExponentialE'), args[0]], metadata);
        // Note: even though 'Subtract' is boxed out, we still need to handle it here
        // because the function may be called with a 'Subtract' head.
        if (head === 'Subtract' && args.length === 2)
            return serializeJsonFunction(ce, 'Add', [args[0], ce._fn('Negate', [args[1]])], metadata);
        if (head === 'Subtract' && args.length === 1)
            return serializeJsonFunction(ce, 'Negate', args, metadata);
    }
    if (head === 'Add' && args.length === 2 && !exclusions.includes('Subtract')) {
        if (args[1].numericValue !== null) {
            const t1 = asSmallInteger(args[1]);
            if (t1 !== null && t1 < 0)
                return serializeJsonFunction(ce, 'Subtract', [args[0], ce.number(-t1)], metadata);
        }
        if (args[1].head === 'Negate') {
            return serializeJsonFunction(ce, 'Subtract', [args[0], args[1].op1], metadata);
        }
    }
    if (head === 'Tuple') {
        if (args.length === 1 && !exclusions.includes('Single'))
            return serializeJsonFunction(ce, 'Single', args, metadata);
        if (args.length === 2 && !exclusions.includes('Pair'))
            return serializeJsonFunction(ce, 'Pair', args, metadata);
        if (args.length === 3 && !exclusions.includes('Triple'))
            return serializeJsonFunction(ce, 'Triple', args, metadata);
    }
    const jsonHead = typeof head === 'string' ? _escapeJsonString(head) : head.json;
    const fn = [jsonHead, ...args.map((x) => x.json)];
    const md = { ...(metadata ?? {}) };
    // Determine if we need some LaTeX metadata
    if (ce.jsonSerializationOptions.metadata.includes('latex')) {
        md.latex = _escapeJsonString(md.latex ?? ce.serialize({ fn }));
    }
    else
        md.latex = '';
    // Determine if we have some wikidata metadata
    if (!ce.jsonSerializationOptions.metadata.includes('wikidata'))
        md.wikidata = '';
    //  Is shorthand allowed, and no metadata to include
    if (!md.latex &&
        !md.wikidata &&
        ce.jsonSerializationOptions.shorthands.includes('function'))
        return fn;
    // No shorthand allowed, or some metadata to include
    if (md.latex && md.wikidata)
        return { fn, latex: md.latex, wikidata: md.wikidata };
    if (md.latex)
        return { fn, latex: md.latex };
    if (md.wikidata)
        return { fn, wikidata: md.wikidata };
    return { fn };
}
function serializeJsonString(ce, s) {
    s = _escapeJsonString(s);
    if (ce.jsonSerializationOptions.shorthands.includes('string'))
        return `'${s}'`;
    return { str: s };
}
function serializeJsonSymbol(ce, sym, metadata) {
    if (sym === 'Half' && ce.jsonSerializationOptions.exclude.includes('Half')) {
        return serializeJsonNumber(ce, [1, 2], metadata);
    }
    metadata = { ...metadata };
    if (ce.jsonSerializationOptions.metadata.includes('latex')) {
        metadata.latex = metadata.latex ?? ce.serialize({ sym });
        if (metadata.latex !== undefined)
            metadata.latex = _escapeJsonString(metadata.latex);
    }
    else
        metadata.latex = undefined;
    if (ce.jsonSerializationOptions.metadata.includes('wikidata')) {
        if (metadata.wikidata === undefined) {
            const wikidata = ce.lookupSymbol(sym)?.wikidata;
            if (wikidata !== undefined)
                metadata.wikidata = _escapeJsonString(wikidata);
        }
    }
    else
        metadata.wikidata = undefined;
    sym = _escapeJsonString(sym);
    if (metadata.latex === undefined &&
        metadata.wikidata === undefined &&
        ce.jsonSerializationOptions.shorthands.includes('symbol'))
        return sym;
    if (metadata.latex !== undefined && metadata.wikidata !== undefined)
        return { sym, latex: metadata.latex, wikidata: metadata.wikidata };
    if (metadata.latex !== undefined)
        return { sym, latex: metadata.latex };
    if (metadata.wikidata !== undefined)
        return { sym, wikidata: metadata.wikidata };
    return { sym };
}
function serializeJsonNumber(ce, value, metadata) {
    metadata = { ...metadata };
    if (!ce.jsonSerializationOptions.metadata.includes('latex'))
        metadata.latex = undefined;
    const shorthandAllowed = metadata.latex === undefined &&
        metadata.wikidata === undefined &&
        !ce.jsonSerializationOptions.metadata.includes('latex') &&
        ce.jsonSerializationOptions.shorthands.includes('number');
    //
    // Bignum
    //
    let num = '';
    if (value instanceof Decimal) {
        if (value.isNaN())
            num = 'NaN';
        else if (!value.isFinite())
            num = value.isPositive() ? '+Infinity' : '-Infinity';
        else {
            // Use the number shorthand if the number can be represented as a machine number
            if (shorthandAllowed && isInMachineRange(value))
                return value.toNumber();
            // Use the scientific notation only if the resulting integer is not
            // too big...
            if (value.isInteger() && value.e < value.precision() + 4)
                num = value.toFixed(0);
            else {
                const precision = ce.jsonSerializationOptions.precision;
                const s = precision === 'max'
                    ? value.toString()
                    : value.toPrecision(precision === 'auto' ? ce.precision : precision);
                num = repeatingDecimals(ce, s);
                if (shorthandAllowed) {
                    // Can we shorthand to a JSON number after accounting for serialization precision?
                    const val = value.toNumber();
                    if (val.toString() === num)
                        return val;
                }
            }
        }
        if (ce.jsonSerializationOptions.metadata.includes('latex'))
            metadata.latex = metadata.latex ?? ce.serialize({ num });
        return metadata.latex !== undefined
            ? { num, latex: metadata.latex }
            : shorthandAllowed
                ? num
                : { num };
    }
    //
    // Complex
    //
    if (value instanceof complex.exports.Complex) {
        if (value.isInfinite())
            return serializeJsonSymbol(ce, 'ComplexInfinity', metadata);
        if (value.isNaN()) {
            num = 'NaN';
            if (ce.jsonSerializationOptions.metadata.includes('latex'))
                metadata.latex = metadata.latex ?? ce.serialize({ num });
            return metadata.latex !== undefined
                ? { num, latex: metadata.latex }
                : { num };
        }
        return serializeJsonFunction(ce, 'Complex', [ce.number(value.re), ce.number(value.im)], {
            ...metadata,
            wikidata: 'Q11567',
        });
    }
    //
    // Rational
    //
    if (isRational(value)) {
        //  Shorthand allowed, and no metadata to include?
        if (shorthandAllowed &&
            ce.jsonSerializationOptions.shorthands.includes('function') &&
            isMachineRational(value)) {
            return ['Rational', value[0], value[1]];
        }
        return serializeJsonFunction(ce, 'Rational', [ce.number(value[0]), ce.number(value[1])], { ...metadata });
    }
    //
    // Machine number
    //
    if (Number.isNaN(value))
        num = 'NaN';
    else if (!Number.isFinite(value))
        num = value > 0 ? '+Infinity' : '-Infinity';
    else {
        if (shorthandAllowed)
            return value;
        num = repeatingDecimals(ce, value.toString());
    }
    if (ce.jsonSerializationOptions.metadata.includes('latex'))
        metadata.latex = metadata.latex ?? ce.serialize({ num });
    return metadata.latex !== undefined
        ? { num, latex: metadata.latex }
        : { num };
}
function _escapeJsonString(s) {
    return s;
}
function repeatingDecimals(ce, s) {
    if (!ce.jsonSerializationOptions.repeatingDecimals)
        return s;
    // eslint-disable-next-line prefer-const
    let [_, wholepart, fractionalPart, exponent] = s.match(/^(.*)\.([0-9]+)([e|E][-+]?[0-9]+)?$/) ?? [];
    if (!fractionalPart)
        return s.toLowerCase();
    // The last digit may have been rounded off if it exceeds the precision,
    // which could throw off the repeating pattern detection. Ignore it.
    const lastDigit = fractionalPart[fractionalPart.length - 1];
    fractionalPart = fractionalPart.slice(0, -1);
    const MAX_REPEATING_PATTERN_LENGTH = 16;
    let prefix = '';
    for (let i = 0; i < fractionalPart.length - MAX_REPEATING_PATTERN_LENGTH; i++) {
        prefix = fractionalPart.substring(0, i);
        // Try to find a repeating pattern of length j
        for (let j = 0; j <= MAX_REPEATING_PATTERN_LENGTH; j++) {
            const repetend = fractionalPart.substring(i, i + j + 1);
            const times = Math.floor((fractionalPart.length - prefix.length) / repetend.length);
            if (times < 3)
                break;
            if ((prefix + repetend.repeat(times + 1)).startsWith(fractionalPart)) {
                // Found a repeating pattern
                // Aktually...
                if (repetend === '0') {
                    if (lastDigit === '0')
                        return wholepart + '.' + prefix + (exponent ?? '');
                    return s;
                }
                return (wholepart + '.' + prefix + '(' + repetend + ')' + (exponent ?? ''));
            }
        }
    }
    fractionalPart += lastDigit;
    while (fractionalPart.endsWith('0'))
        fractionalPart = fractionalPart.slice(0, -1);
    if (exponent)
        return `${wholepart}.${fractionalPart}${exponent.toLowerCase()}`;
    return `${wholepart}.${fractionalPart}`;
}

/**
 * BoxedDictionary
 */
class BoxedDictionary extends AbstractBoxedExpression {
    constructor(ce, dict, options) {
        options ?? (options = {});
        super(ce, options.metadata);
        this._value = new Map();
        const canonical = options.canonical ?? true;
        for (const key of Object.keys(dict))
            this._value.set(key, ce.box(dict[key], { canonical }));
        ce._register(this);
    }
    unbind() {
        for (const [_k, v] of this._value)
            v.unbind();
        return undefined;
    }
    get hash() {
        let h = hashCode('Dictionary');
        for (const [k, v] of this._value)
            h ^= hashCode(k) ^ v.hash;
        return h;
    }
    get complexity() {
        return 97;
    }
    get head() {
        return 'Dictionary';
    }
    get isPure() {
        // @todo
        return false;
    }
    getKey(key) {
        return this._value.get(key);
    }
    hasKey(key) {
        return this._value.has(key);
    }
    get keys() {
        return this._value.keys();
    }
    get keysCount() {
        return this._value.size;
    }
    has(x) {
        for (const [_k, v] of this._value)
            if (v.has(x))
                return true;
        return false;
    }
    get domain() {
        const result = ['Dictionary'];
        for (const [k, v] of this._value)
            result.push(['Tuple', k, v.domain]);
        return this.engine.domain(result);
    }
    get json() {
        // Is dictionary shorthand notation allowed?
        if (this.engine.jsonSerializationOptions.shorthands.includes('dictionary')) {
            const dict = {};
            for (const key of this._value.keys())
                dict[key] = this._value.get(key).json;
            return { dict };
        }
        // The dictionary shorthand is not allowed, output it as a "Dictionary"
        // function
        const kvs = [];
        for (const key of this._value.keys())
            kvs.push(this.engine._fn('KeyValuePair', [
                this.engine.string(key),
                this._value.get(key),
            ]));
        return serializeJsonFunction(this.engine, 'Dictionary', kvs, {
            latex: this._latex,
        });
    }
    /** Structural equality */
    isSame(rhs) {
        if (this === rhs)
            return true;
        if (!(rhs instanceof BoxedDictionary))
            return false;
        if (this._value.size !== rhs._value.size)
            return false;
        for (const [k, v] of this._value) {
            const rhsV = rhs.getKey(k);
            if (!rhsV || !v.isSame(rhsV))
                return false;
        }
        return true;
    }
    match(rhs, _options) {
        if (!(rhs instanceof BoxedDictionary))
            return null;
        if (this._value.size !== rhs._value.size)
            return null;
        let result = {};
        for (const [k, v] of this._value) {
            const rhsV = rhs.getKey(k);
            if (!rhsV)
                return null;
            const m = v.match(rhsV);
            if (m === null)
                return null;
            result = { ...result, ...m };
        }
        return result;
    }
    /** Mathematical equality */
    isEqual(rhs) {
        if (this === rhs)
            return true;
        if (!(rhs instanceof BoxedDictionary))
            return false;
        if (!rhs.keys || this._value.size !== rhs._value.size)
            return false;
        for (const [k, v] of this._value) {
            const rhsV = rhs.getKey(k);
            if (!rhsV || !v.isEqual(rhsV))
                return false;
        }
        return true;
    }
    apply(fn, head) {
        const result = {};
        for (const key of this.keys)
            result[key] = this.engine.box(fn(this.getKey(key)));
        if (head)
            return this.engine.fn(head, [{ dict: result }]);
        return new BoxedDictionary(this.engine, result);
    }
    evaluate(options) {
        return this.apply((x) => x.evaluate(options) ?? x);
    }
    get isCanonical() {
        return this._isCanonical;
    }
    set isCanonical(val) {
        this._isCanonical = val;
    }
    get canonical() {
        if (this.isCanonical)
            return this;
        const result = this.apply((x) => x.canonical);
        result.isCanonical = true;
        return result;
    }
    simplify(options) {
        if (!(options?.recursive ?? true))
            return this;
        // In general, we should simplify the canonical form of this
        // expression, but for dictionaries, there is no canonical
        // form, except the canonical form of its elements
        return this.apply((x) => x.simplify(options) ?? x);
    }
    N(options) {
        return this.apply((x) => x.N(options));
    }
    replace(rules, options) {
        // @todo: rules that apply to a `Dictionary` head should be accounted for
        let changeCount = 0;
        const result = {};
        for (const key of this.keys) {
            const val = this.getKey(key);
            const newVal = val.replace(rules, options);
            if (newVal !== null)
                changeCount += 1;
            result[key] = newVal ?? val;
        }
        return changeCount === 0 ? null : new BoxedDictionary(this.engine, result);
    }
    subs(sub, options) {
        const result = {};
        for (const key of this.keys)
            result[key] = this.getKey(key).subs(sub, options);
        return new BoxedDictionary(this.engine, result, options);
    }
}

/**
 * A set of simplification rules.
 *
 * The rules are expressed as
 *
 *    `[lhs, rhs, condition]`
 *
 * where `lhs` is rewritten as `rhs` if `condition` is true.
 *
 * `lhs` and `rhs` can be either an Expression or a LaTeX string.
 *
 * If using an Expression, the expression is *not* canonicalized before being
 * used. Therefore in some cases using Expression, while more verbose,
 * may be necessary as the expression could be simplified by the canonicalization.
 */
const SIMPLIFY_RULES = [];
//  [
//   // `Subtract`
//   ['$\\_ - \\_$', 0],
//   [['Subtract', '\\_x', 0], 'x'],
//   [['Subtract', 0, '\\_x'], '$-x$'],
//   // `Add`
//   [['Add', '_x', ['Negate', '_x']], 0],
//   // `Multiply`
//   ['$\\_ \\times \\_ $', '$\\_^2$'],
//   // `Divide`
//   [['Divide', '_x', 1], { sym: '_x' }],
//   [['Divide', '_x', '_x'], 1, { condition: (sub) => sub.x.isNotZero ?? false }],
//   [
//     ['Divide', '_x', 0],
//     { num: '+Infinity' },
//     { condition: (sub) => sub.x.isPositive ?? false },
//   ],
//   [
//     ['Divide', '_x', 0],
//     { num: '-Infinity' },
//     { condition: (sub) => sub.x.isNegative ?? false },
//   ],
//   [['Divide', 0, 0], NaN],
//   // `Power`
//   [['Power', '_x', 'Half'], '$\\sqrt{x}$'],
//   [
//     ['Power', '_x', 2],
//     ['Square', '_x'],
//   ],
//   // Complex
//   [
//     ['Divide', ['Complex', '_re', '_im'], '_x'],
//     ['Add', ['Divide', ['Complex', 0, '_im'], '_x'], ['Divide', '_re', '_x']],
//     {
//       condition: (sub: Substitution): boolean =>
//         (sub.re.isNotZero ?? false) &&
//         (sub.re.isInteger ?? false) &&
//         (sub.im.isInteger ?? false),
//     },
//   ],
//   // `Abs`
//   [
//     ['Abs', '_x'],
//     { sym: '_x' },
//     {
//       condition: (sub: Substitution): boolean => sub.x.isNonNegative ?? false,
//     },
//   ],
//   [
//     ['Abs', '_x'],
//     ['Negate', '_x'],
//     {
//       condition: (sub: Substitution): boolean => sub.x.isNegative ?? false,
//     },
//   ],
//   //
//   // Boolean
//   //
//   [['Not', ['Not', '_x']], '_x'], // @todo Since Not is an involution, should not be needed
//   [['Not', 'True'], 'False'],
//   [['Not', 'False'], 'True'],
//   [['Not', 'Maybe'], 'Maybe'],
//   [['And'], 'True'],
//   [['And', '__x'], '__x'],
//   [['And', '__x', 'True'], '_x'],
//   [['And', '__', 'False'], 'False'],
//   [['And', '__', 'Maybe'], 'Maybe'],
//   [['And', '__x', ['Not', '__x']], 'False'],
//   [['And', ['Not', '__x'], '__x'], 'False'],
//   [['Or'], 'False'],
//   [['Or', '__x'], '__x'],
//   [['Or', '__', 'True'], 'True'],
//   [['Or', '__x', 'False'], '__x'],
//   [
//     ['Or', '__x', 'Maybe'],
//     ['Or', '__x'],
//   ],
//   [
//     ['NotEqual', '__x'],
//     ['Not', ['Equal', '__x']],
//   ],
//   [
//     ['NotElement', '__x'],
//     ['Not', ['Element', '__x']],
//   ],
//   [
//     ['NotLess', '__x'],
//     ['Not', ['Less', '__x']],
//   ],
//   [
//     ['NotLessNotEqual', '__x'],
//     ['Not', ['LessEqual', '__x']],
//   ],
//   [
//     ['NotTildeFullEqual', '__x'],
//     ['Not', ['TildeFullEqual', '__x']],
//   ],
//   [
//     ['NotApprox', '__x'],
//     ['Not', ['Approx', '__x']],
//   ],
//   [
//     ['NotApproxEqual', '__x'],
//     ['Not', ['ApproxEqual', '__x']],
//   ],
//   [
//     ['NotGreater', '__x'],
//     ['Not', ['Greater', '__x']],
//   ],
//   [
//     ['NotApproxNotEqual', '__x'],
//     ['Not', ['GreaterEqual', '__x']],
//   ],
//   [
//     ['NotPrecedes', '__x'],
//     ['Not', ['Precedes', '__x']],
//   ],
//   [
//     ['NotSucceeds', '__x'],
//     ['Not', ['Succeeds', '__x']],
//   ],
//   [
//     ['NotSubset', '__x'],
//     ['Not', ['Subset', '__x']],
//   ],
//   [
//     ['NotSuperset', '__x'],
//     ['Not', ['Superset', '__x']],
//   ],
//   [
//     ['NotSubsetNotEqual', '__x'],
//     ['Not', ['SubsetEqual', '__x']],
//   ],
//   [
//     ['NotSupersetEqual', '__x'],
//     ['Not', ['SupersetEqual', '__x']],
//   ],
//   // DeMorgan's Laws
//   [
//     ['Not', ['And', ['Not', '_a'], ['Not', '_b']]],
//     ['Or', '_a', '_b'],
//   ],
//   [
//     ['And', ['Not', '_a'], ['Not', '_b']],
//     ['Not', ['Or', '_a', '_b']],
//   ],
//   [
//     ['Not', ['Or', ['Not', '_a'], ['Not', '_b']]],
//     ['And', '_a', '_b'],
//   ],
//   [
//     ['Or', ['Not', '_a'], ['Not', '_b']],
//     ['Not', ['And', '_a', '_b']],
//   ],
//   // Implies
//   [['Implies', 'True', 'False'], 'False'],
//   [['Implies', '_', 'Maybe'], 'True'],
//   [['Implies', '_', 'True'], 'True'],
//   [['Implies', 'False', '_'], 'True'],
//   [
//     ['Or', ['Not', '_p'], '_q'],
//     ['Implies', '_p', '_q'],
//   ], // p => q := (not p) or q
//   // if           Q=F & P= T      F
//   // otherwise                    T
//   //  Equivalent
//   [
//     ['Or', ['And', '_p', '_q'], ['And', ['Not', '_p'], ['Not', '_q']]],
//     ['Equivalent', '_p', '_q'],
//   ], // p <=> q := (p and q) or (not p and not q), aka `iff`
//   //   if (q = p), T. Otherwise, F
//   [['Equivalent', 'True', 'True'], 'True'],
//   [['Equivalent', 'False', 'False'], 'True'],
//   [['Equivalent', 'Maybe', 'Maybe'], 'True'],
//   [['Equivalent', 'True', 'False'], 'False'],
//   [['Equivalent', 'False', 'True'], 'False'],
//   [['Equivalent', 'True', 'Maybe'], 'False'],
//   [['Equivalent', 'False', 'Maybe'], 'False'],
//   [['Equivalent', 'Maybe', 'True'], 'False'],
//   [['Equivalent', 'Maybe', 'False'], 'False'],
// ];
// export function internalSimplify(
//   ce: ComputeEngine,
//   expr: BoxedExpression | null,
//   simplifications?: Simplification[]
// ): BoxedExpression | null {
//   if (expr === null) return null;
//   //
//   // 1/ Apply simplification rules
//   //
//   simplifications = simplifications ?? ['simplify-all'];
//   if (simplifications.length === 1 && simplifications[0] === 'simplify-all') {
//     simplifications = [
//       'simplify-arithmetic',
//       // 'simplify-logarithmic',
//       // 'simplify-trigonometric',
//     ];
//   }
//   for (const simplification of simplifications) {
//     expr = ce.replace(
//       expr,
//       ce.cache<RuleSet>(
//         simplification,
//         (): RuleSet => compileRules(ce, SIMPLIFY_RULES[simplification])
//       )
//     );
//   }
//   //
//   // 2/ Numeric simplifications
//   //
//   // expr = simplifyNumber(ce, expr!) ?? expr;
//   //
//   // 3/ Simplify boolean expressions, using assumptions.
//   //
//   //
//   expr = simplifyBoolean(expr);
//   if (isAtomic(expr!)) return expr;
//   //
//   // 4/ Simplify Dictionary
//   //
//   // if (getDictionary(expr!) !== null) {
//   //   return applyRecursively(
//   //     expr!,
//   //     (x) => internalSimplify(ce, x, simplifications) ?? x
//   //   );
//   // }
//   //
//   // 5/ It's a function (not a dictionary and not atomic)
//   //
//   const head = internalSimplify(
//     ce,
//     getFunctionHead(expr) ?? 'Missing',
//     simplifications
//   );
//   if (typeof head === 'string') {
//     const def = ce.getFunctionDefinition(head);
//     if (def) {
//       // Simplify the arguments, except those affected by `hold`
//       const args: BoxedExpression[] = [];
//       const tail = getTail(expr);
//       for (let i = 0; i < tail.length; i++) {
//         const name = getFunctionName(tail[i]);
//         if (name === 'Evaluate') {
//           args.push(internalSimplify(ce, tail[i], simplifications) ?? tail[i]);
//         } else if (name === 'Hold') {
//           args.push(getArg(tail[i], 1) ?? 'Missing');
//         } else if (
//           (i === 0 && def.hold === 'first') ||
//           (i > 0 && def.hold === 'rest') ||
//           def.hold === 'all'
//         ) {
//           args.push(tail[i]);
//         } else {
//           args.push(internalSimplify(ce, tail[i], simplifications) ?? tail[i]);
//         }
//       }
//       const result =
//         typeof def.simplify === 'function'
//           ? def.simplify(ce, ...args) ?? expr
//           : [head, ...args];
//       return ce.cost(result) <= ce.cost(expr) ? result : expr;
//     }
//   }
//   if (head !== null) {
//     // If we can't identify the function, we don't know how to process
//     // the arguments (they may be Hold...), so don't attempt to process them.
//     return [head, ...getTail(expr)];
//   }
//   return expr;
// }

function validateArgumentCount(ce, ops, count) {
    if (ops.length === count)
        return ops;
    const xs = [...ops.slice(0, count)];
    let i = Math.min(count, ops.length);
    while (i < count) {
        xs.push(ce.error('missing'));
        i += 1;
    }
    while (i < ops.length) {
        xs.push(ce.error('unexpected-argument', ops[i]));
        i += 1;
    }
    return xs;
}
/**
 * Validation of arguments is normally done by checking the signature of the
 * function vs the arguments of the expression. However, we have a fastpath
 * for some common operations (add, multiply, power, neg, etc...) that bypasses
 * the regular checks. This is its replacements. Since all those fastpath
 * functions are numeric (i.e. have numeric arguments and return a numeric
 * value), we do a simple numeric check of all arguments, and verify we have
 * the number of expected arguments.
 */
function validateNumericArgs(ce, ops, count) {
    // @fastpath
    if (!ce.strict)
        return ops;
    let xs;
    if (count === undefined)
        xs = ops;
    else {
        xs = [];
        for (let i = 0; i <= Math.max(count - 1, ops.length - 1); i++) {
            if (i > count - 1)
                xs.push(ce.error('unexpected-argument', ops[i]));
            else
                xs.push(ops[i] !== undefined
                    ? ce.box(ops[i])
                    : ce.error(['missing', 'Number']));
        }
    }
    return xs.map((op) => !op.isValid || op.isNumber
        ? op
        : ce.error(['incompatible-domain', 'Number', op.domain], op));
}
/** Return `null` if the `ops` match the sig. Otherwise, return an array
 * of expressions indicating the mismatched arguments.
 *
 */
function validateSignature(sig, ops, codomain) {
    const ce = sig.engine;
    // @fastpath
    if (!ce.strict)
        return ops;
    const opsDomain = ops.map((x) => x.domain);
    const targetSig = ce.domain([
        'Function',
        ...opsDomain,
        codomain ?? 'Anything',
    ]);
    if (sig.isCompatible(targetSig))
        return null;
    //
    // There was a problem:
    // 1/ not enough arguments
    // 2/ too many arguments
    // 3/ incompatible argument domain
    //
    // Iterate over each arg, and replace with error expression when appropriate
    //
    const expectedArgs = sig.domainArgs.slice(0, -1);
    const count = Math.max(expectedArgs.length, opsDomain.length);
    let newOps = [];
    let rest = [...ops];
    for (let i = 0; i <= count - 1; i++)
        [newOps, rest] = validateNextArgument(ce, expectedArgs[i], newOps, rest);
    // Remove any 'Nothing' at the end
    while (newOps.length > 0 && newOps[newOps.length - 1].symbol === 'Nothing')
        newOps.pop();
    return newOps;
}
function validateArgument(ce, arg, dom) {
    if (dom === undefined)
        return ce.error('unexpected-argument', arg);
    if (arg === undefined)
        return ce.error(['missing', dom]);
    if (!arg.isValid)
        return arg;
    if (arg?.domain.isCompatible(dom))
        return arg;
    return ce.error(['incompatible-domain', dom, arg.domain], arg);
}
function validateNextArgument(ce, dom, matched, ops) {
    let next = ops.shift();
    if (dom === undefined)
        return [[...matched, ce.error('unexpected-argument', next)], ops];
    if (!Array.isArray(dom)) {
        if (!next)
            return [[...matched, ce.error(['missing', dom])], ops];
        if (!next.domain.isCompatible(dom)) {
            return [
                [...matched, ce.error(['incompatible-domain', dom, next.domain], next)],
                ops,
            ];
        }
        return [[...matched, next], ops];
    }
    const ctor = dom[0];
    if (next === undefined) {
        //
        // An expected argument is missing. Is that OK?
        //
        let valid = false;
        if (ctor === 'Union') {
            //  If an `Union`, was `Nothing` an option?
            for (let k = 1; k <= dom.length - 1; k++) {
                if (dom[k] === 'Nothing') {
                    valid = true;
                    break;
                }
            }
        }
        else if (ctor === 'Maybe')
            valid = true;
        if (valid)
            return [[...matched, ce.symbol('Nothing')], ops];
        return [[...matched, ce.error(['missing', dom])], ops];
    }
    if (ctor === 'Union') {
        //
        // We expect one of several domains. Check if at least one matches
        //
        let found = false;
        for (let k = 1; k <= dom.length - 1; k++) {
            if (next.domain.isCompatible(dom[k])) {
                found = true;
                break;
            }
        }
        if (found)
            return [[...matched, next], ops];
        return [
            [...matched, ce.error(['incompatible-domain', dom, next.domain], next)],
            ops,
        ];
    }
    if (ctor === 'Sequence') {
        const seq = dom[1];
        if (!next || !next.domain.isCompatible(seq)) {
            return [
                [...matched, ce.error(['incompatible-domain', seq, next.domain], next)],
                ops,
            ];
        }
        let done = false;
        const result = [...matched, next];
        while (!done) {
            next = ops.shift();
            if (!next)
                done = false;
            else if (!next.domain.isCompatible(seq)) {
                ops.unshift(next);
                done = false;
            }
            else
                result.push(next);
        }
        return [result, ops];
    }
    if (ctor === 'Maybe') {
        if (next === undefined || next.symbol === 'Nothing')
            return [[...matched, ce.symbol('Nothing')], ops];
        return validateNextArgument(ce, dom[1], matched, [next, ...ops]);
    }
    console.error('Unhandled ctor', ctor);
    return [[...matched, next], ops];
}
function validateArguments(ce, args, doms) {
    // Do a quick check for the common case where everything is as expected.
    // Avoid allocating arrays and objects
    if (args.length === doms.length &&
        args.every((x, i) => x.domain.isCompatible(doms[i])))
        return args;
    const xs = [];
    for (let i = 0; i <= doms.length - 1; i++)
        xs.push(validateArgument(ce, args[i], doms[i]));
    for (let i = doms.length; i <= args.length - 1; i++)
        xs.push(ce.error('unexpected-argument', args[i]));
    return xs;
}

/**
 * Considering an old (existing) expression and a new (simplified) one,
 * return the cheapest of the two, with a bias towards the new (which can
 * actually be a bit more expensive than the old one, and still be picked).
 */
function cheapest(oldExpr, newExpr) {
    if (newExpr === null || newExpr === undefined)
        return oldExpr;
    if (oldExpr === newExpr)
        return oldExpr;
    const ce = oldExpr.engine;
    const boxedNewExpr = ce.box(newExpr);
    if (ce.costFunction(boxedNewExpr) <= 1.7 * ce.costFunction(oldExpr)) {
        // console.log(
        //   'Picked new' + boxedNewExpr.toString() + ' over ' + oldExpr.toString()
        // );
        return boxedNewExpr;
    }
    // console.log(
    //   'Picked old ' + oldExpr.toString() + ' over ' + newExpr.toString()
    // );
    return oldExpr;
}
/**
 * BoxedFunction
 */
class BoxedFunction extends AbstractBoxedExpression {
    constructor(ce, head, ops, options) {
        options ?? (options = {});
        options.canonical ?? (options.canonical = false);
        super(ce, options.metadata);
        this._scope = ce.context;
        this._head = head;
        this._ops = ops;
        this._def = options.def ?? null; // Mark the def as not yet cached if none is provided
        if (options.canonical) {
            if (!this._def)
                this._def = ce.lookupFunction(head, ce.context);
            this._canonical = this;
        }
        this._codomain = null;
        if (!options.canonical) {
            this._codomain = ce.domain('Anything');
        }
        else {
            if (typeof this._head !== 'string')
                this._codomain = this._head.domain.codomain;
            else if (this._def) {
                const sig = this._def.signature;
                if (typeof sig.codomain === 'function') {
                    this._codomain = sig.codomain(ce, this._ops) ?? null;
                }
                else {
                    this._codomain = sig.codomain ?? null;
                }
            }
            if (!this._codomain)
                this._codomain = ce.defaultDomain ?? ce.domain('Void');
        }
        // Note: _isPure is computed on demand and cached
        ce._register(this);
    }
    //
    // NON-CANONICAL OR CANONICAL OPERATIONS
    //
    // Those operations/properties can be applied to a canonical or
    // non-canonical expression
    //
    get hash() {
        if (this._hash !== undefined)
            return this._hash;
        let h = 0;
        for (const op of this._ops)
            h = ((h << 1) ^ op.hash) | 0;
        if (typeof this._head === 'string')
            h = (h ^ hashCode(this._head)) | 0;
        else
            h = (h ^ this._head.hash) | 0;
        this._hash = h;
        return h;
    }
    get isCanonical() {
        return this._canonical === this;
    }
    set isCanonical(val) {
        this._canonical = val ? this : undefined;
    }
    get isPure() {
        if (this._isPure !== undefined)
            return this._isPure;
        if (!this.isCanonical) {
            this._isPure = false;
            return false;
        }
        let result = undefined;
        if (this.functionDefinition?.pure !== undefined)
            result = this.functionDefinition.pure;
        // The function might be pure. Let's check that all its arguments are pure.
        if (result !== false)
            result = this._ops.every((x) => x.isPure);
        this._isPure = result;
        return result;
    }
    get json() {
        // If this expression is canonical, apply some transformations to the
        // JSON serialization to "reverse" some of the effects of canonicalization.
        if (this.isValid && this._canonical === this)
            return serializeJsonCanonicalFunction(this.engine, this._head, this._ops, { latex: this._latex, wikidata: this._wikidata });
        return serializeJsonFunction(this.engine, this._head, this._ops, {
            latex: this._latex,
            wikidata: this._wikidata,
        });
    }
    get scope() {
        return this._scope;
    }
    get head() {
        return this._head;
    }
    get ops() {
        return this._ops;
    }
    get nops() {
        return this._ops.length;
    }
    get op1() {
        return this._ops[0] ?? this.engine.symbol('Nothing');
    }
    get op2() {
        return this._ops[1] ?? this.engine.symbol('Nothing');
    }
    get op3() {
        return this._ops[2] ?? this.engine.symbol('Nothing');
    }
    get isValid() {
        if (this._head === 'Error')
            return false;
        if (typeof this._head !== 'string' && !this._head.isValid)
            return false;
        return this._ops.every((x) => x.isValid);
    }
    get canonical() {
        if (this._canonical)
            return this._canonical;
        this._canonical = this.isValid
            ? makeCanonicalFunction(this.engine, this._head, this._ops)
            : this;
        return this._canonical;
    }
    *map(fn) {
        let i = 0;
        while (i < this._ops.length)
            yield fn(this._ops[i++]);
    }
    subs(sub, options) {
        options ?? (options = {});
        if (!('canonical' in options))
            options.canonical = true;
        const ops = this._ops.map((x) => x.subs(sub, options));
        if (options.canonical && ops.every((x) => x.isValid))
            return makeCanonicalFunction(this.engine, this._head, ops);
        return new BoxedFunction(this.engine, this._head, ops, {
            canonical: false,
        });
    }
    replace(rules, options) {
        return replace(this, rules, options);
    }
    has(x) {
        if (typeof this._head === 'string') {
            if (typeof x === 'string') {
                if (this._head === x)
                    return true;
            }
            else if (x.includes(this._head))
                return true;
        }
        for (const arg of this._ops)
            if (arg.has(x))
                return true;
        return false;
    }
    /** `isSame` is structural/symbolic equality */
    isSame(rhs) {
        if (this === rhs)
            return true;
        if (!(rhs instanceof BoxedFunction))
            return false;
        // Number of arguments must match
        if (this.nops !== rhs.nops)
            return false;
        // Head must match
        if (typeof this.head === 'string') {
            if (this.head !== rhs.head)
                return false;
        }
        else {
            if (typeof rhs.head === 'string')
                return false;
            else if (!rhs.head || !this.head.isSame(rhs.head))
                return false;
        }
        // Each argument must match
        const lhsTail = this._ops;
        const rhsTail = rhs._ops;
        for (let i = 0; i < lhsTail.length; i++)
            if (!lhsTail[i].isSame(rhsTail[i]))
                return false;
        return true;
    }
    match(rhs, options) {
        if (!(rhs instanceof BoxedFunction))
            return null;
        let result = {};
        // Head must match
        if (typeof this.head === 'string') {
            if (this.head !== rhs.head)
                return null;
        }
        else {
            if (typeof rhs.head === 'string')
                return null;
            else {
                if (!rhs.head)
                    return null;
                const m = this.head.match(rhs.head, options);
                if (m === null)
                    return null;
                result = { ...result, ...m };
            }
        }
        // Each argument must match
        const lhsTail = this._ops;
        const rhsTail = rhs._ops;
        for (let i = 0; i < lhsTail.length; i++) {
            const m = lhsTail[i].match(rhsTail[i], options);
            if (m === null)
                return null;
            result = { ...result, ...m };
        }
        return result;
    }
    //
    // CANONICAL OPERATIONS
    //
    // These operations apply only to canonical expressions
    //
    unbind() {
        // Note: a non-canonical expression is never bound
        this._value = undefined;
        this._numericValue = undefined;
        // this._def = null;
    }
    get wikidata() {
        // Since the canonical and non-canonical version of the expression
        // may have different heads, not applicable to non-canonical expressions.
        if (!this.isCanonical)
            return undefined;
        return this._wikidata ?? this.functionDefinition?.wikidata ?? undefined;
    }
    get description() {
        // Since the canonical and non-canonical version of the expression
        // may have different heads, not applicable to non-canonical expressions.
        if (!this.isCanonical)
            return undefined;
        const def = this.functionDefinition;
        if (!def)
            return [];
        if (!def.description)
            return undefined;
        if (typeof def.description === 'string')
            return [def.description];
        return def.description;
    }
    get url() {
        // Since the canonical and non-canonical version of the expression
        // may have different heads, not applicable to non-canonical expressions.
        if (!this.isCanonical)
            return '';
        return this.functionDefinition?.url ?? undefined;
    }
    get complexity() {
        // Since the canonical and non-canonical version of the expression
        // may have different heads, not applicable to non-canonical expressions.
        if (!this.isCanonical)
            return undefined;
        return this.functionDefinition?.complexity ?? DEFAULT_COMPLEXITY;
    }
    get functionDefinition() {
        if (!this.isCanonical)
            return undefined;
        if (this._def !== null)
            return this._def;
        return undefined;
    }
    bind(_scope) {
        debugger;
    }
    get value() {
        if (!this.isCanonical || !this.isPure)
            return undefined;
        // Use cached value if the function is pure
        if (!this._value)
            this._value = this.evaluate();
        return this._value;
    }
    /** `isEqual` is mathematical equality */
    isEqual(rhs) {
        const s = signDiff(this, rhs);
        if (s === 0)
            return true;
        if (s !== undefined)
            return false;
        return this.isSame(rhs);
    }
    isLess(rhs) {
        const s = signDiff(this, rhs);
        if (s === undefined)
            return undefined;
        return s < 0;
    }
    isLessEqual(rhs) {
        const s = signDiff(this, rhs);
        if (s === undefined)
            return undefined;
        return s <= 0;
    }
    isGreater(rhs) {
        const s = signDiff(this, rhs);
        if (s === undefined)
            return undefined;
        return s > 0;
    }
    isGreaterEqual(rhs) {
        const s = signDiff(this, rhs);
        if (s === undefined)
            return undefined;
        return s >= 0;
    }
    get isZero() {
        const s = this.sgn;
        if (s === null)
            return false;
        if (typeof s === 'number')
            return s === 0;
        return undefined;
        // @todo: use this.functionDefinition.range
    }
    get isNotZero() {
        const s = this.sgn;
        if (s === null)
            return false;
        if (typeof s === 'number')
            return s !== 0;
        return undefined;
        // @todo: use this.functionDefinition.range
    }
    get isOne() {
        return this.isEqual(this.engine._ONE);
    }
    get isNegativeOne() {
        return this.isEqual(this.engine._NEGATIVE_ONE);
    }
    // x > 0
    get isPositive() {
        const s = this.sgn;
        if (s === null)
            return false;
        if (typeof s === 'number')
            return s > 0;
        return undefined;
    }
    // x <= 0
    get isNonPositive() {
        const s = this.sgn;
        if (s === null)
            return false;
        if (typeof s === 'number')
            return s <= 0;
        return undefined;
    }
    // x < 0
    get isNegative() {
        const s = this.sgn;
        if (s === null)
            return false;
        if (typeof s === 'number')
            return s < 0;
        return undefined;
    }
    // x >= 0
    get isNonNegative() {
        const s = this.sgn;
        if (s === null)
            return false;
        if (typeof s === 'number')
            return s >= 0;
        return undefined;
    }
    get isNumber() {
        return this.domain.isCompatible('Number');
    }
    get isInteger() {
        return this.domain.isCompatible('Integer');
    }
    get isRational() {
        return this.domain.isCompatible('RationalNumber');
    }
    get isAlgebraic() {
        return this.domain.isCompatible('AlgebraicNumber');
    }
    get isReal() {
        return this.domain.isCompatible('RealNumber');
    }
    get isExtendedReal() {
        return this.domain.isCompatible('ExtendedRealNumber');
    }
    get isComplex() {
        return this.domain.isCompatible('ComplexNumber');
    }
    get isImaginary() {
        return this.domain.isCompatible('ImaginaryNumber');
    }
    get sgn() {
        if (!this.isCanonical)
            return undefined;
        // @todo: if there is a this.functionDefinition.range, use it
        // @todo if inconclusive, and there is a this.def._sgn, call it
        // @todo: add sgn() function to FunctionDefinition
        const head = this.head;
        if (head === 'Negate') {
            const s = this._ops[0]?.sgn;
            if (s === undefined)
                return undefined;
            if (s === null)
                return null;
            return s === 0 ? 0 : s > 0 ? -1 : +1;
        }
        if (head === 'Multiply') {
            const total = this._ops.reduce((acc, x) => acc * (x.sgn ?? NaN), 1);
            if (isNaN(total))
                return null;
            if (total > 0)
                return 1;
            if (total < 0)
                return -1;
            return 0;
        }
        if (head === 'Add') {
            let posCount = 0;
            let negCount = 0;
            let zeroCount = 0;
            const count = this._ops.length;
            for (const op of this._ops) {
                const s = op.sgn;
                if (s === null || s === undefined)
                    break;
                if (s === 0)
                    zeroCount += 1;
                if (s > 0)
                    posCount += 1;
                if (s < 0)
                    negCount += 1;
            }
            if (zeroCount === count)
                return 0;
            if (posCount === count)
                return 1;
            if (negCount === count)
                return -1;
            return null;
        }
        if (head === 'Divide') {
            const n = this._ops[0]?.sgn;
            const d = this._ops[1]?.sgn;
            if (n === null || d === null || n === undefined || d === undefined)
                return null;
            if (n === 0)
                return 0;
            if ((n > 0 && d > 0) || (n < 0 && d < 0))
                return +1;
            return -1;
        }
        if (head === 'Square') {
            if (this._ops[0]?.isImaginary)
                return -1;
            if (this._ops[0]?.isZero)
                return 0;
            return +1;
        }
        if (head === 'Abs') {
            if (this._ops[0]?.isZero)
                return 0;
            return +1;
        }
        if (head === 'Sqrt') {
            if (this._ops[0]?.isZero)
                return 0;
            if (this._ops[0]?.isImaginary)
                return null;
            return +1;
        }
        // @todo: trig functions, geometric functions
        const v = asFloat(this.N());
        if (v === null)
            return undefined;
        if (v === 0)
            return 0;
        if (v < 0)
            return -1;
        return +1;
    }
    //
    // AUTO-CANONICAL OPERATIONS
    //
    // The operations are automatically done on the canonical form of the
    // expression
    //
    get domain() {
        return this._codomain;
    }
    simplify(options) {
        //
        // 1/ Use the canonical form
        //
        if (!this.isValid)
            return this;
        if (!this.isCanonical) {
            const canonical = this.canonical;
            if (!canonical.isCanonical || !canonical.isValid)
                return this;
            return canonical.simplify(options);
        }
        //
        // 2/ Simplify the applicable operands
        // @todo not clear if this is always the best strategy. Might be better to
        // defer to the handler.
        //
        const def = this.functionDefinition;
        const tail = holdMap(this._ops, def?.hold ?? 'none', def?.associative ? def.name : '', (x) => x.simplify(options));
        //
        // 3/ If a function expression, apply the arguments, and simplify the result
        //
        if (typeof this._head !== 'string') {
            const expr = apply$1(this._head, tail);
            if (typeof expr.head !== 'string')
                return expr;
            return expr.simplify(options);
        }
        //
        // 4/ Apply `simplify` handler
        //
        let expr;
        if (def) {
            if (def.inert)
                expr = tail[0]?.canonical ?? this;
            else {
                const sig = def.signature;
                if (sig?.simplify)
                    expr = sig.simplify(this.engine, tail);
            }
        }
        if (!expr)
            expr = this.engine.fn(this._head, tail);
        else
            expr = cheapest(this.engine.fn(this._head, tail), expr);
        expr = cheapest(this, expr);
        //
        // 5/ Apply rules, until no rules can be applied
        //
        const rules = options?.rules ??
            this.engine.cache('standard-simplification-rules', () => boxRules(this.engine, SIMPLIFY_RULES), (rules) => {
                for (const [lhs, rhs, _priority, _condition] of rules) {
                    lhs.unbind();
                    rhs.unbind();
                }
                return rules;
            });
        let iterationCount = 0;
        let done = false;
        do {
            const newExpr = expr.replace(rules);
            if (newExpr !== null) {
                expr = cheapest(newExpr, expr);
                if (expr === newExpr)
                    done = true;
            }
            else
                done = true; // no rules applied
            iterationCount += 1;
            // @debug-begin
            // if (iterationCount > 100) {
            //   console.log('Iterating... ', newExpr?.toJSON() ?? '()', expr.toJSON());
            // }
            // @debug-end
        } while (!done && iterationCount < this.engine.iterationLimit);
        // @debug-begin
        // if (iterationCount >= this.engine.iterationLimit) {
        //   console.error('Iteration Limit reached simplifying', this.toJSON());
        // }
        // @debug-end
        return cheapest(this, expr);
    }
    evaluate(options) {
        //
        // 1/ Use the canonical form
        //
        if (!this.isValid)
            return this;
        if (!this.isCanonical) {
            const canonical = this.canonical;
            if (!canonical.isCanonical || !canonical.isValid)
                return this;
            return canonical.evaluate(options);
        }
        //
        // 2/ Evaluate the applicable operands
        //
        const def = this.functionDefinition;
        const tail = holdMap(this._ops, def?.hold ?? 'none', def?.associative ? def.name : '', (x) => x.evaluate(options));
        //
        // 3/ Is it a Lambda?
        //
        if (typeof this._head !== 'string') {
            const expr = apply$1(this._head, tail);
            if (typeof expr.head !== 'string')
                return expr;
            return expr.evaluate(options);
        }
        //
        // 4/ No def? Inert? We're done.
        //
        if (!def)
            return this.engine.fn(this._head, tail);
        if (def.inert)
            return tail[0] ?? this;
        //
        // 5/ Use the signature associated with his definition
        //
        const sig = def.signature;
        //
        // 6/ Call the `evaluate` handler
        //
        // 5.1/ No evaluate handler, we're done
        if (!sig || !sig.evaluate)
            return this.engine.fn(this._head, tail);
        // 5.2/ A function expression handler
        if (typeof sig.evaluate !== 'function')
            return apply$1(sig.evaluate, tail);
        // 5.3/ A regular function handler
        return sig.evaluate(this.engine, tail) ?? this.engine.fn(this._head, tail);
    }
    N(options) {
        //
        // 1/ Use canonical form
        //
        if (this._numericValue)
            return this._numericValue;
        if (this.engine.strict && !this.isValid)
            return this;
        if (!this.isCanonical) {
            const canonical = this.canonical;
            if (!canonical.isCanonical || !canonical.isValid)
                return this;
            return canonical.N(options);
        }
        //
        // 2/ Evaluate the applicable operands
        //
        const def = this.functionDefinition;
        const tail = holdMap(this._ops, def?.hold ?? 'none', def?.associative ? def.name : '', (x) => x.N(options));
        //
        // 3/ Is it a function expression
        //
        if (typeof this._head !== 'string') {
            const expr = apply$1(this._head, tail);
            if (typeof expr.head !== 'string')
                return expr;
            return expr.N(options);
        }
        //
        // 4/ No def? Inert? We're done.
        //
        if (!def)
            return this.engine.fn(this._head, tail);
        if (def.inert)
            return tail[0] ?? this;
        //
        // 5/ Call `N` handler or fallback to `evaluate`
        //
        const sig = def.signature;
        let result = sig?.N?.(this.engine, tail) ??
            this.engine.fn(this._head, tail).evaluate();
        const num = result.numericValue;
        if (num !== null) {
            if (!complexAllowed(this.engine) && num instanceof Complex)
                result = this.engine._NAN;
            else if (!bignumPreferred(this.engine) && num instanceof Decimal)
                result = this.engine.number(num.toNumber());
        }
        if (this.isPure)
            this._numericValue = result;
        return result;
    }
    solve(vars) {
        if (vars.length !== 1)
            return null;
        const roots = findUnivariateRoots(this.simplify(), vars[0]);
        return roots;
    }
}
function makeNumericFunction(ce, head, semiOps, metadata) {
    let ops = [];
    if (head === 'Add' || head === 'Multiply')
        ops = validateNumericArgs(ce, flattenOps(flattenSequence(ce.canonical(semiOps)), head));
    else if (head === 'Negate' || head === 'Square' || head === 'Sqrt')
        ops = validateNumericArgs(ce, flattenSequence(ce.canonical(semiOps)), 1);
    else if (head === 'Divide' || head === 'Power')
        ops = validateNumericArgs(ce, flattenSequence(ce.canonical(semiOps)), 2);
    else
        return null;
    // If some of the arguments are not valid, make a non-canonical expression
    if (!ops.every((x) => x.isValid))
        return new BoxedFunction(ce, head, ops, { metadata, canonical: false });
    //
    // Short path for some functions
    // (avoid looking up a definition)
    //
    if (head === 'Add')
        return ce.add(ops, metadata);
    if (head === 'Negate')
        return ce.neg(ops[0] ?? ce.error('missing'), metadata);
    if (head === 'Multiply')
        return ce.mul(ops, metadata);
    if (head === 'Divide')
        return ce.div(ops[0], ops[1], metadata);
    if (head === 'Power')
        return ce.pow(ops[0], ops[1], metadata);
    if (head === 'Square')
        return ce.pow(ops[0], ce.number(2), metadata);
    if (head === 'Sqrt') {
        const op = ops[0].canonical;
        if (isRational(op.numericValue))
            return new BoxedFunction(ce, 'Sqrt', [op], { metadata, canonical: true });
        return ce.pow(op, ce._HALF, metadata);
    }
    // if (head === 'Pair') return ce.pair(ops[0], ops[1], metadata);
    // if (head === 'Tuple') return ce.tuple(ops, metadata);
    return null;
}
function makeCanonicalFunction(ce, head, ops, metadata) {
    //
    // Is the head an expression? For example, `['InverseFunction', 'Sin']`
    //
    if (typeof head !== 'string')
        head = head.evaluate().symbol ?? head;
    if (typeof head === 'string') {
        const result = makeNumericFunction(ce, head, ops, metadata);
        if (result)
            return result;
    }
    else {
        if (!head.isValid)
            return new BoxedFunction(ce, head, ops.map((x) => ce.box(x, { canonical: false })), { metadata, canonical: false });
    }
    //
    // Didn't match a short path, look for a definition
    //
    const def = ce.lookupFunction(head, ce.context);
    if (typeof head !== 'string' || !def) {
        return new BoxedFunction(ce, head, flattenSequence(ops.map((x) => ce.box(x))), { metadata, canonical: true });
    }
    let xs = [];
    for (let i = 0; i < ops.length; i++) {
        if (applicable(def.hold, ops.length - 1, i)) {
            xs.push(ce.box(ops[i]));
        }
        else {
            const y = ce.box(ops[i], { canonical: false });
            if (y.head === 'ReleaseHold')
                xs.push(y.op1.canonical);
            else
                xs.push(y);
        }
    }
    const sig = def.signature;
    //
    // 3/ Apply `canonical` handler
    //
    // If present, the canonical handler is responsible for validating
    // arguments, sorting them, applying involution and idempotent to
    // the expression.
    //
    if (sig.canonical) {
        try {
            const result = sig.canonical(ce, xs);
            if (result)
                return result;
        }
        catch (e) {
            console.error(e);
        }
        return new BoxedFunction(ce, head, xs, { metadata, canonical: false });
    }
    //
    // Flatten any sequence
    // f(a, Sequence(b, c), d) -> f(a, b, c, d)
    //
    xs = flattenSequence(xs);
    if (def.associative)
        xs = flattenOps(xs, head);
    // If some of the arguments are not valid, can't make a canonical expression
    if (!xs.every((x) => x.isValid))
        return new BoxedFunction(ce, head, xs, { metadata, canonical: false });
    xs = validateSignature(sig.domain, xs) ?? xs;
    if (!xs.every((x) => x.isValid))
        return new BoxedFunction(ce, head, xs, { metadata, canonical: false });
    //
    // 4/ Apply `idempotent` and `involution`
    //
    if (xs.length === 1 && xs[0].head === head) {
        // f(f(x)) -> x
        if (def.involution)
            return xs[0].op1;
        // f(f(x)) -> f(x)
        if (def.idempotent)
            xs = xs[0].ops;
    }
    //
    // 5/ Sort the arguments
    //
    if (xs.length > 1 && def.commutative === true)
        xs = xs.sort(order);
    return new BoxedFunction(ce, head, xs, { metadata, def, canonical: true });
}
/** Apply arguments to an expression. If the expression is a lambda expression
 * it's wildcard arguments are substituted before being evaluated. Otherwise
 * the expression is just evaluated.
 */
function apply$1(fn, args) {
    if (fn.head !== 'Lambda')
        return fn.engine._fn(fn.evaluate(), args);
    const subs = {
        '__': fn.engine.tuple(args),
        '_#': fn.engine.number(args.length),
    };
    let n = 1;
    for (const op of args)
        subs[`_${n++}`] = op;
    subs['_'] = subs['_1'];
    // Substitute the arguments in the lambda expression
    const savedContext = this.context;
    this.context = fn.scope ?? null;
    const result = fn.subs(subs).evaluate();
    this.context = savedContext;
    return result;
}
/** Apply the function `f` to elements of `xs`, except to the elements
 * described by `skip`:
 * - `all`: don't apply f to any elements
 * - `none`: apply `f` to all elements
 * - `first`: apply `f` to all elements except the first
 * - `rest`: apply `f` to the first element, skip the  others
 * - 'last': apply `f` to all elements except the last
 * - 'most': apply `f` to the last elements, skip the others
 *
 * Account for `Hold`, `ReleaseHold`, `Sequence`, `Symbol` and `Nothing`.
 *
 * If `f` returns `null`, the element is not added to the result
 */
function holdMap(xs, skip, associativeHead, f) {
    if (xs.length === 0)
        return [];
    // f(a, f(b, c), d) -> f(a, b, c, d)
    xs = flattenOps(xs, associativeHead);
    //
    // Apply the hold as necessary
    //
    // @fastpath
    if (skip === 'all')
        return xs;
    if (skip === 'none') {
        const result = [];
        for (const x of xs) {
            const h = x.head;
            if (h === 'Hold')
                result.push(x);
            else {
                const op = h === 'ReleaseHold' ? x.op1 : x;
                if (op) {
                    const y = f(op);
                    if (y !== null)
                        result.push(y);
                }
            }
        }
        return flattenOps(result, associativeHead);
    }
    const result = [];
    for (let i = 0; i < xs.length; i++) {
        if (xs[i].head === 'Hold') {
            result.push(xs[i]);
        }
        else {
            let y = undefined;
            if (xs[i].head === 'ReleaseHold')
                y = xs[i].op1;
            else if (applicable(skip, xs.length - 1, i))
                y = xs[i];
            else
                result.push(xs[i]);
            if (y) {
                const x = f(y);
                if (x !== null)
                    result.push(x);
            }
        }
    }
    return flattenOps(result, associativeHead);
}
function applicable(skip, count, index) {
    if (skip === 'all')
        return false;
    if (skip === 'none')
        return true;
    if (skip === 'first')
        return index !== 0;
    if (skip === 'rest')
        return index === 0;
    if (skip === 'last')
        return index !== count;
    if (skip === 'most')
        return index === count;
    return false;
}
// @todo: allow selection of one signature amongst multiple
// function matchSignature(
//   ce: IComputeEngine,
//   def: BoxedFunctionDefinition,
//   tail: BoxedExpression[],
//   codomain?: BoxedExpression
// ): BoxedFunctionSignature | undefined {
//   return def.signature;
// }

/** Quickly determine the numeric domain of a number or constant
 * For the symbols, this is a hard-coded optimization that doesn't rely on the
 * dictionaries. The regular path is in `internalDomain()`
 */
function inferNumericDomain(value) {
    //
    // 1. Is it a number?
    //
    if (typeof value === 'number' && !isNaN(value)) {
        if (!isFinite(value))
            return 'ExtendedRealNumber';
        // if (value === 0) return 'NonNegativeInteger'; // Bias: Could be NonPositiveInteger
        if (Number.isInteger(value)) {
            if (value > 0)
                return 'PositiveInteger';
            if (value < 0)
                return 'NegativeInteger';
            return 'Integer';
        }
        if (value > 0)
            return 'PositiveNumber';
        if (value < 0)
            return 'NegativeNumber';
        return 'RealNumber';
    }
    //
    // 2 Is it a bignum?
    //
    if (value instanceof Decimal) {
        if (value.isNaN())
            return 'Number';
        if (!value.isFinite())
            return 'ExtendedRealNumber';
        // if (value.isZero()) return 'NonNegativeInteger'; // Bias: Could be NonPositiveInteger
        if (value.isInteger()) {
            if (value.isPositive())
                return 'PositiveInteger';
            if (value.isNegative())
                return 'NegativeInteger';
            return 'Integer';
        }
        if (value.isPositive())
            return 'PositiveNumber';
        if (value.isNegative())
            return 'NegativeNumber';
        return 'RealNumber';
    }
    //
    // 3 Is it a complex number?
    //
    if (value instanceof complex.exports.Complex) {
        const c = value;
        console.assert(c.im !== 0);
        if (c.re === 0)
            return 'ImaginaryNumber';
        return 'ComplexNumber';
    }
    //
    // 4. Is it a rational? (machine or bignum)
    //
    if (isRational(value)) {
        const [numer, denom] = value;
        // The value is a rational number
        console.assert(typeof numer !== 'number' ||
            (!Number.isNaN(numer) && !Number.isNaN(denom)));
        return 'RationalNumber';
    }
    return 'Number';
}

const LARGE_PRIME = 1125899906842597; // Largest prime < 2^50
function isPrime(n) {
    if (!Number.isInteger(n) ||
        !Number.isFinite(n) ||
        Number.isNaN(n) ||
        n <= 1) {
        return false;
    }
    // Is it a known small prime?
    if (n <= LARGEST_SMALL_PRIME)
        return SMALL_PRIMES.has(n);
    // Is it a factor of a small known prime?
    for (const smallPrime of SMALL_PRIMES) {
        if (n % smallPrime === 0)
            return false;
    }
    if (n >= LARGE_PRIME) {
        return probablyPrime(n, 30) ? undefined : false;
    }
    return n === leastFactor(n);
}
function leastFactor(n) {
    if (n === 1)
        return 1;
    if (n % 2 === 0)
        return 2;
    if (n % 3 === 0)
        return 3;
    if (n % 5 === 0)
        return 5;
    const m = Math.floor(Math.sqrt(n));
    let i = 7;
    while (i <= m) {
        if (n % i === 0)
            return i;
        if (n % (i + 4) === 0)
            return i + 4;
        if (n % (i + 6) === 0)
            return i + 6;
        if (n % (i + 10) === 0)
            return i + 10;
        if (n % (i + 12) === 0)
            return i + 12;
        if (n % (i + 16) === 0)
            return i + 16;
        if (n % (i + 22) === 0)
            return i + 22;
        if (n % (i + 24) === 0)
            return i + 24;
        i += 30;
    }
    return n;
}
/**
 *  Miller-Rabin primality test
 */
function probablyPrime(n, k) {
    // if (n === 2 || n === 3)
    // 	return true;
    // if (n % 2 === 0 || n < 2)
    // 	return false;
    // Write (n - 1) as 2^s * d
    let s = 0, d = n - 1;
    while (d % 2 === 0) {
        d /= 2;
        ++s;
    }
    WitnessLoop: do {
        // A base between 2 and n - 2
        let x = Math.pow(2 + Math.floor(Math.random() * (n - 3)), d) % n;
        if (x === 1 || x === n - 1)
            continue;
        for (let i = s - 1; i--;) {
            x = (x * x) % n;
            if (x === 1)
                return false;
            if (x === n - 1)
                continue WitnessLoop;
        }
        return false;
    } while (--k);
    return true;
}

/**
 * BoxedNumber
 */
class BoxedNumber extends AbstractBoxedExpression {
    /**
     * By the time the constructor is called, the `value` should have been
     * screened for cases where it's a well-known value (0, NaN, +Infinity,
     * etc...) or non-normal (complex number with im = 0, rational with
     * denom = 1, etc...).
     *
     * This is done in `ce.number()`. In general, use `ce.number()` rather
     * than calling this constructor directly.
     *
     * We may store as a machine number if a Decimal is passed that is in machine
     * range
     */
    constructor(ce, value, options) {
        super(ce, options?.metadata);
        if (typeof value === 'number') {
            this._value = value;
            this._isCanonical = true;
            return;
        }
        if (isRational(value)) {
            //
            // This is a rational (or big rational)
            //
            const [n, d] = value;
            console.assert(typeof n !== 'number' ||
                (Number.isInteger(n) && Number.isInteger(d) && d !== n && d !== 1));
            console.assert(!(typeof n === 'bigint' && typeof d == 'bigint') ||
                (d !== n && d !== BigInt(1)));
            if (options?.canonical ?? true) {
                this._value = canonicalNumber(ce, value);
                this._isCanonical = true;
            }
            else {
                this._value = value;
                // Note: it *could* be already canonical, but we don't
                // bother checking as it could be expensive and might
                // not be worthwhile
                this._isCanonical = false;
            }
        }
        else {
            console.assert(!(value instanceof complex.exports.Complex) ||
                (!Number.isNaN(value.re) &&
                    !Number.isNaN(value.im) &&
                    ce.chop(value.im) !== 0));
            // Any non-rational is already in canonical form
            // but we downconvert decimal to number when possible
            this._value = canonicalNumber(ce, value);
            this._isCanonical = true;
        }
    }
    get hash() {
        if (this._hash !== undefined)
            return this._hash;
        let h = 0;
        if (typeof this._value === 'number')
            h = hashCode(this._value.toString());
        else if (this._value instanceof complex.exports.Complex)
            h = hashCode(this._value.re.toString() + ' +i ' + this._value.im.toString());
        else if (this._value instanceof Decimal)
            h = hashCode(this._value.toString());
        else
            h = hashCode(this._value[0].toString() + ' / ' + this._value[1].toString());
        this._hash = h;
        return h;
    }
    get head() {
        return 'Number';
    }
    get isPure() {
        return true;
    }
    get isExact() {
        if (typeof this._value === 'number')
            return Number.isInteger(this._value);
        if (this._value instanceof Decimal)
            return this._value.isInteger();
        if (this._value instanceof complex.exports.Complex)
            return (Number.isInteger(this._value.re) && Number.isInteger(this._value.im));
        return isRational(this._value);
    }
    get isCanonical() {
        return this._isCanonical;
    }
    set isCanonical(val) {
        this._isCanonical = val;
    }
    get complexity() {
        return 1;
    }
    get value() {
        return this;
    }
    get numericValue() {
        return this._value;
    }
    get domain() {
        if (this._domain === undefined)
            this._domain = this.engine.domain(inferNumericDomain(this._value));
        return this._domain;
    }
    get json() {
        return serializeJsonNumber(this.engine, this._value, {
            latex: this._latex,
        });
    }
    get sgn() {
        if (this.isZero)
            return 0;
        if (this._value instanceof complex.exports.Complex)
            return null;
        if (typeof this._value === 'number') {
            if (this._value < 0)
                return -1;
            if (this._value > 0)
                return 1;
            return null;
        }
        if (this._value instanceof Decimal) {
            if (this._value.isNegative())
                return -1;
            if (this._value.isPositive())
                return 1;
            return null;
        }
        if (Array.isArray(this._value)) {
            // By convention, the denominator is always positive,
            // so the sign is carried by the numerator
            const [numer, denom] = this._value;
            if (numer === 0 && denom !== 0)
                return 0;
            if (numer < 0)
                return -1;
            if (numer > 0)
                return 1;
            return null;
        }
        return null;
    }
    isSame(rhs) {
        if (this === rhs)
            return true;
        if (!(rhs instanceof BoxedNumber))
            return false;
        if (Array.isArray(this._value)) {
            if (!Array.isArray(rhs._value))
                return false;
            const [rhsN, rhsD] = rhs._value;
            return this._value[0] === rhsN && this._value[1] === rhsD;
        }
        if (this._value instanceof Decimal) {
            if (!(rhs._value instanceof Decimal))
                return false;
            return this._value.eq(rhs._value);
        }
        if (this._value instanceof complex.exports.Complex) {
            if (!(rhs._value instanceof complex.exports.Complex))
                return false;
            return this._value.equals(rhs._value);
        }
        if (typeof this._value === 'number') {
            if (typeof rhs._value !== 'number')
                return false;
            return this._value === rhs._value;
        }
        return false;
    }
    isEqual(rhs) {
        if (this === rhs)
            return true;
        const n = rhs.N();
        if (!(n instanceof BoxedNumber))
            return false;
        return signDiff(this.N(), n) === 0;
    }
    match(rhs, options) {
        if (this.isEqualWithTolerance(rhs, options?.numericTolerance ?? 0))
            return {};
        return null;
    }
    /** Compare this with another BoxedNumber.
     * `rhs` must be a BoxedNumber. Use `isEqualWithTolerance(rhs.N())`
     * if necessary.
     */
    isEqualWithTolerance(rhs, tolerance) {
        return rhs instanceof BoxedNumber && signDiff(this, rhs, tolerance) === 0;
    }
    isLess(rhs) {
        const s = signDiff(this, rhs);
        if (s === undefined)
            return undefined;
        return s < 0;
    }
    isLessEqual(rhs) {
        const s = signDiff(this, rhs);
        if (s === undefined)
            return undefined;
        return s <= 0;
    }
    isGreater(rhs) {
        return rhs.isLessEqual(this);
    }
    isGreaterEqual(rhs) {
        return rhs.isLess(this);
    }
    /** x > 0, same as `isGreater(0)` */
    get isPositive() {
        const s = this.sgn;
        if (s === undefined || s === null)
            return undefined;
        return s > 0;
    }
    /** x >= 0, same as `isGreaterEqual(0)` */
    get isNonNegative() {
        const s = this.sgn;
        if (s === undefined || s === null)
            return undefined;
        return s >= 0;
    }
    /** x < 0, same as `isLess(0)` */
    get isNegative() {
        const s = this.sgn;
        if (s === undefined || s === null)
            return undefined;
        return s < 0;
    }
    /** x <= 0, same as `isLessEqual(0)` */
    get isNonPositive() {
        const s = this.sgn;
        if (s === undefined || s === null)
            return undefined;
        return s <= 0;
    }
    get isZero() {
        if (this._value === 0)
            return true;
        if (this._value instanceof Decimal)
            return this._value.isZero();
        if (this._value instanceof complex.exports.Complex)
            return this._value.isZero();
        // Rationals can never be zero: they get downcast to
        // a machine number during boxing (ctor) if numerator is 0
        return false;
    }
    get isNotZero() {
        if (typeof this._value === 'number' && this._value !== 0)
            return true;
        if (this._value instanceof Decimal)
            return !this._value.isZero();
        if (this._value instanceof complex.exports.Complex)
            return !this._value.isZero();
        return true;
    }
    get isOne() {
        if (typeof this._value === 'number')
            return this._value === 1;
        if (this._value instanceof Decimal)
            return this._value.equals(this.engine._BIGNUM_ONE);
        if (this._value instanceof complex.exports.Complex)
            return this._value.im === 0 && this._value.re === 1;
        return isRationalOne(this._value);
    }
    get isNegativeOne() {
        if (typeof this._value === 'number')
            return this._value === -1;
        if (this._value instanceof Decimal)
            return this._value.equals(this.engine._BIGNUM_NEGATIVE_ONE);
        if (Array.isArray(this._value))
            return isRationalNegativeOne(this._value);
        return this._value.equals(-1);
    }
    get isOdd() {
        if (this.isOne || this.isNegativeOne)
            return true;
        if (this.isZero)
            return false;
        if (!this.isInteger)
            return false;
        if (typeof this._value === 'number')
            return this._value % 2 !== 0;
        if (this._value instanceof Decimal)
            return !this._value.mod(2).isZero();
        // Note: rational and complex numbers are not considered even or odd
        return undefined;
    }
    get isEven() {
        if (this.isOne || this.isNegativeOne)
            return false;
        if (this.isZero)
            return true;
        if (!this.isInteger)
            return false;
        if (typeof this._value === 'number')
            return this._value % 2 === 0;
        if (this._value instanceof Decimal)
            return this._value.mod(2).isZero();
        // Note: rational and complex numbers are not considered even or odd
        return undefined;
    }
    get isPrime() {
        if (!this.isInteger ||
            !this.isFinite ||
            this.isNonPositive ||
            this.isOne ||
            this.isZero)
            return false;
        if (typeof this._value === 'number')
            return isPrime(this._value);
        // @todo: prime for Decimal integers
        if (this._value instanceof Decimal)
            return isPrime(this._value.toNumber());
        return undefined;
    }
    get isComposite() {
        if (!this.isInteger ||
            !this.isFinite ||
            this.isNonPositive ||
            this.isOne ||
            this.isZero)
            return false;
        if (typeof this._value === 'number')
            return !isPrime(this._value);
        // @todo: prime for Decimal integers
        if (this._value instanceof Decimal)
            return !isPrime(this._value.toNumber());
        return undefined;
    }
    get isInfinity() {
        if (typeof this._value === 'number')
            return !Number.isFinite(this._value) && !Number.isNaN(this._value);
        if (this._value instanceof Decimal)
            return !this._value.isFinite() && !this._value.isNaN();
        if (this._value instanceof complex.exports.Complex)
            return !this._value.isFinite() && !this._value.isNaN();
        // Note: Rational numbers cannot be Infinity, they are
        // converted to a machine infinity during boxing (ctor)
        return false;
    }
    get isNaN() {
        if (typeof this._value === 'number')
            return Number.isNaN(this._value);
        if (this._value instanceof Decimal)
            this._value.isNaN();
        if (this._value instanceof complex.exports.Complex)
            this._value.isNaN();
        // Note: Rational numbers cannot be NaN, they are
        // converted to a machine NaN during boxing (ctor)
        return false;
    }
    get isFinite() {
        return !this.isInfinity && !this.isNaN;
    }
    get isNumber() {
        return true;
    }
    get isInteger() {
        if (typeof this._value === 'number')
            return Number.isInteger(this._value);
        if (this._value instanceof Decimal)
            return this._value.isInteger();
        // Note that some non-reduced rational numbers, such as `4/2`
        // are not considered integers.
        return false;
    }
    get isRational() {
        // Note that `isRational` is true for some non-canonical
        // rationals, i.e. `4/2`
        if (Array.isArray(this._value))
            return true;
        // Every integer is also a rational
        return this.isInteger;
    }
    get isAlgebraic() {
        // Rational numbers (and integers) are definitely algebraic
        if (this.isRational)
            return true;
        // For the rest, who knows...
        return undefined;
    }
    get isReal() {
        if (!this.isFinite)
            return false;
        if (this._value instanceof complex.exports.Complex)
            return this.engine.chop(this._value.im) === 0;
        return true;
    }
    // Real or +-Infinity
    get isExtendedReal() {
        // We don't have to check for undefined, for BoxedNumber,
        // isInfinity and isReal never return undefined
        return this.isInfinity || this.isReal;
    }
    get isComplex() {
        // A real number, or an imaginary number
        // isFinite
        return !this.isNaN;
    }
    get isImaginary() {
        if (this._value instanceof complex.exports.Complex) {
            console.assert(this._value.im !== 0);
            return true;
        }
        return false;
    }
    get isExtendedComplex() {
        return this.isInfinity || !this.isNaN;
    }
    get canonical() {
        if (this._isCanonical)
            return this;
        return this.engine.number(canonicalNumber(this.engine, this._value));
    }
    simplify(_options) {
        return this.canonical;
    }
    N(_options) {
        if (!Array.isArray(this._value))
            return this;
        // If a rational, evaluate as an approximation
        const ce = this.engine;
        const [numer, denom] = this._value;
        if (typeof numer === 'number' &&
            typeof denom === 'number' &&
            !bignumPreferred(ce))
            return ce.number(numer / denom);
        return ce.number(ce.bignum(numer).div(ce.bignum(denom)));
    }
}
function canonicalNumber(ce, value) {
    // We choose to store bignums as machine numbers when possible
    // This doesn't affect evaluation later. It may require
    // the number to be upconverted later, but is a memory saving now. Not 100% clear what is the best strategy from a performance point of view.
    if (value instanceof Decimal && isInMachineRange(value))
        return value.toNumber();
    if (!isRational(value))
        return value;
    value = reducedRational(value);
    if (isBigRational(value)) {
        let [n, d] = value;
        if (n > Number.MIN_SAFE_INTEGER &&
            n < Number.MAX_SAFE_INTEGER &&
            d > Number.MIN_SAFE_INTEGER &&
            d < Number.MAX_SAFE_INTEGER)
            value = [Number(n), Number(d)];
        else {
            if (d < 0)
                [n, d] = [-n, -d];
            if (d === BigInt(1))
                return ce.bignum(n);
            if (d === BigInt(0)) {
                if (n === d)
                    return NaN;
                return n < 0 ? -Infinity : +Infinity;
            }
            return [n, d];
        }
    }
    let [n, d] = value;
    if (Number.isNaN(n) || Number.isNaN(d))
        return NaN;
    if (d < 0)
        [n, d] = [-n, -d];
    if (d === 1)
        return n;
    if (d === 0) {
        if (n === 0 || !Number.isFinite(n))
            return NaN;
        if (n < 0)
            return -Infinity;
        return +Infinity;
    }
    // Could be +0 or -0
    if (n === 0)
        return n;
    return [n, d];
}

/**
 * BoxedString
 */
class BoxedString extends AbstractBoxedExpression {
    constructor(ce, expr, metadata) {
        super(ce, metadata);
        // Strings are always stored in Unicode NFC canonical order
        // See https://unicode.org/reports/tr15/
        this._string = expr.normalize();
        ce._register(this);
    }
    get hash() {
        return hashCode('String' + this._string);
    }
    get json() {
        return serializeJsonString(this.engine, this._string);
    }
    get head() {
        return 'String';
    }
    get isPure() {
        return true;
    }
    get isCanonical() {
        return true;
    }
    set isCanonical(_va) {
        return;
    }
    get domain() {
        return this.engine.domain('String');
    }
    get complexity() {
        return 19;
    }
    get string() {
        return this._string;
    }
    isEqual(rhs) {
        return rhs.string === this._string;
    }
    isSame(rhs) {
        return rhs.string === this._string;
    }
    match(rhs, _options) {
        if (!(rhs instanceof BoxedString))
            return null;
        if (this._string === rhs._string)
            return {};
        return null;
    }
}

/**
 * **Theory of Operations**
 *
 * 1/ Boxing does not depend on the numeric mode. The numeric mode could be
 * changed later, but the previously boxed numbers could not be retroactively
 * upgraded.
 *
 * The `numericMode` is taken into account only during evaluation.
 *
 * Therefore, a boxed expression may contain a mix of number representations.
 *
 * 2/ The result of boxing is canonical by default.
 *
 * This is the most common need (i.e. as soon as you want to evaluate an
 * expression you need a canonical expression). Creating a boxed expression
 * which is canonical from the start avoid going through an intermediary step
 * with a non-canonical expression.
 *
 * 3/ When implementing an `evaluate()`:
 * - if `bignumPreferred()` all operations should be done in bignum and complex,
 *    otherwise, they should all be done in machine numbers and complex.
 * - if not `complexAllowed()`, return `NaN` if a complex value is encountered
 * - if a `Sqrt` (of a rational) is encountered, preserve it
 * - if a `hold` constant is encountered, preserve it
 * - if a rational is encountered, preserve it
 * - if one of the arguments is not exact, return an approximation
 *
 * EXACT
 * - 2 + 5 -> 7
 * - 2 + 5/7 -> 19/7
 * - 2 + √2 -> 2 + √2
 * - 2 + √(5/7) -> 2 + √(5/7)
 * - 5/7 + 9/11 -> 118/77
 * - 5/7 + √2 -> 5/7 + √2
 * - 10/14 + √(18/9) -> 5/7 + √2
 * - √2 + √5 -> √2 + √5
 * - √2 + √2 -> 2√2
 * - sin(2) -> sin(2)
 * - sin(pi/3) -> √3/2
 *
 * APPROXIMATE
 * - 2 + 2.1 -> 4.1
 * - 2 + √2.1 -> 3.44914
 * - 5/7 + √2.1 -> 2.16342
 * - sin(2) + √2.1 -> 2.35844
 */
/**
 * Return a boxed number representing `num`.
 *
 * Note: `boxNumber()` should only be called from `ce.number()` in order to
 * benefit from number expression caching.
 */
function boxNumber(ce, num, options) {
    //
    // Do we have a machine number or bignum?
    //
    if (typeof num === 'number' || num instanceof Decimal)
        return new BoxedNumber(ce, num, options);
    options ?? (options = {});
    if (!('canonical' in options))
        options.canonical = true;
    //
    // Do we have a rational or big rational?
    //
    if (Array.isArray(num) &&
        num.length === 2 &&
        num[0] instanceof Decimal &&
        num[1] instanceof Decimal) {
        if (!num[0].isInteger() || !num[1].isInteger())
            throw new Error('Array argument to `boxNumber()` should be two integers');
        num = [bigint(num[0].toString()), bigint(num[1].toString())];
    }
    if (isRational(num)) {
        if (num.length !== 2)
            throw new Error('Array argument to `boxNumber()` should be two integers or two bignums');
        const [n, d] = num;
        if (typeof n === 'bigint' && typeof d === 'bigint') {
            if (n === d)
                return d === BigInt(0) ? ce._NAN : ce._ONE;
            if (d === BigInt(1))
                return ce.number(n, options);
            if (d === BigInt(-1))
                return ce.number(-n, options);
            if (n === BigInt(1) && d === BigInt(2))
                return ce._HALF;
            return new BoxedNumber(ce, [n, d], options);
        }
        if (typeof n !== 'number' || typeof d !== 'number')
            throw new Error('Array argument to `boxNumber()` should be two integers or two bignums');
        if (!Number.isInteger(n) || !Number.isInteger(d))
            throw new Error('Array argument to `boxNumber()` should be two integers');
        if (d === n)
            return d === 0 ? ce._NAN : ce._ONE;
        if (d === 1)
            return ce.number(n, options);
        if (d === -1)
            return ce.number(-n, options);
        if (n === 1 && d === 2)
            return ce._HALF;
        return new BoxedNumber(ce, [n, d], options);
    }
    //
    // Do we have a complex number?
    //
    if (num instanceof complex.exports.Complex) {
        if (num.isNaN())
            return ce._NAN;
        if (num.isZero())
            return ce._ZERO;
        if (num.isInfinite())
            return ce._COMPLEX_INFINITY;
        if (ce.chop(num.im) === 0)
            return ce.number(num.re, options);
        return new BoxedNumber(ce, num, options);
    }
    //
    // Do we have a string of digits?
    //
    let strNum = '';
    if (typeof num === 'string')
        strNum = num;
    else if (typeof num === 'object' && 'num' in num) {
        // Technically, num.num as a number is not valid MathJSON: it should be a
        // string, but we'll allow it.
        if (typeof num.num === 'number')
            return ce.number(num.num, options);
        if (typeof num.num !== 'string')
            throw new Error('MathJSON `num` property should be a string of digits');
        strNum = num.num;
    }
    if (strNum) {
        strNum = strNum.toLowerCase();
        // Remove trailing "n" or "d" letter (from legacy version of MathJSON spec)
        if (/[0-9][nd]$/.test(strNum))
            strNum = strNum.slice(0, -1);
        // Remove any whitespace:
        // Tab, New Line, Vertical Tab, Form Feed, Carriage Return, Space, Non-Breaking Space
        strNum = strNum.replace(/[\u0009-\u000d\u0020\u00a0]/g, '');
        // Special case some common values to share boxed instances
        if (strNum === 'nan')
            return ce._NAN;
        if (strNum === 'infinity' || strNum === '+infinity')
            return ce._POSITIVE_INFINITY;
        if (strNum === '-infinity')
            return ce._NEGATIVE_INFINITY;
        if (strNum === '0')
            return ce._ZERO;
        if (strNum === '1')
            return ce._ONE;
        if (strNum === '-1')
            return ce._NEGATIVE_ONE;
        // Do we have repeating digits?
        if (/\([0-9]+\)/.test(strNum)) {
            const [_, body, repeat, trail] = strNum.match(/(.+)\(([0-9]+)\)(.+)?$/) ?? [];
            // @todo we probably shouldn't be using the ce.precision since it may change later
            strNum =
                body +
                    repeat.repeat(Math.ceil(ce.precision / repeat.length)) +
                    (trail ?? '');
        }
        return boxNumber(ce, ce.bignum(strNum), options);
    }
    return null;
}
function boxHold(ce, expr, options) {
    if (expr === null)
        return ce.error('missing');
    if (typeof expr === 'object' && expr instanceof AbstractBoxedExpression)
        return expr;
    expr = missingIfEmpty(expr);
    if (typeof expr === 'string')
        return box(ce, expr, options);
    if (Array.isArray(expr)) {
        const boxed = expr.map((x) => boxHold(ce, x, options));
        return new BoxedFunction(ce, boxed[0], boxed.slice(1));
    }
    if (typeof expr === 'object') {
        if ('dict' in expr)
            return new BoxedDictionary(ce, expr.dict);
        if ('fn' in expr)
            return boxHold(ce, expr.fn, options);
        if ('str' in expr)
            return new BoxedString(ce, expr.str);
        if ('sym' in expr)
            return box(ce, expr.sym, options);
        if ('num' in expr)
            return box(ce, expr.num, options);
    }
    return box(ce, expr, options);
}
/**
 * Given a head and a set of arguments, return a boxed function expression.
 *
 * If available, preserve LaTeX and wikidata metadata in the boxed expression.
 *
 * Note that `boxFunction()` should only be called from `ce.fn()` or `box()`
 */
function boxFunction(ce, head, ops, options) {
    //
    // Hold
    //
    if (head === 'Hold') {
        return new BoxedFunction(ce, 'Hold', [boxHold(ce, ops[0], options)], {
            ...options,
            canonical: true,
        });
    }
    if (head === 'Error' || head === 'ErrorCode') {
        return ce._fn(head, ops.map((x) => ce.box(x, { canonical: false })), options.metadata);
    }
    if (head === 'Domain')
        return ce.domain(ops[0], options.metadata);
    if (head === 'Number' && ops.length === 1)
        return box(ce, ops[0], options);
    if (head === 'String') {
        if (ops.length === 0)
            return new BoxedString(ce, '', options.metadata);
        return new BoxedString(ce, ops.map((x) => asString(x) ?? '').join(''), options.metadata);
    }
    if (head === 'Symbol' && ops.length > 0) {
        return ce.symbol(ops.map((x) => asString(x) ?? '').join(''), options);
    }
    //
    // Rational (as Divide)
    //
    if ((head === 'Divide' || head === 'Rational') && ops.length === 2) {
        if (ops[0] instanceof AbstractBoxedExpression &&
            ops[1] instanceof AbstractBoxedExpression) {
            const [n, d] = [asBigint(ops[0]), asBigint(ops[1])];
            if (n && d)
                return ce.number([n, d], options);
        }
        else {
            const [n, d] = [
                bigintValue(ce, ops[0]),
                bigintValue(ce, ops[1]),
            ];
            if (n && d)
                return ce.number([n, d], options);
        }
        head = 'Divide';
    }
    //
    // Complex
    //
    if (head === 'Complex') {
        if (ops.length === 1) {
            // If single argument, assume it's imaginary
            // @todo: use machineValue() & symbol() instead of box()
            const op1 = box(ce, ops[0], options);
            const im = asFloat(op1);
            if (im !== null && im !== 0)
                return ce.number(ce.complex(0, im), options);
            return ce.mul([op1, ce._I]);
        }
        if (ops.length === 2) {
            const op1 = box(ce, ops[0], options);
            const op2 = box(ce, ops[1], options);
            const re = asFloat(op1);
            const im = asFloat(op2);
            if (im !== null && re !== null) {
                if (im === 0 && re === 0)
                    return ce._ZERO;
                if (im !== null && im !== 0)
                    return ce.number(ce.complex(re, im), options);
                return op1;
            }
            return ce.add([op1, ce.mul([op2, ce._I])], options.metadata);
        }
    }
    //
    // Negate
    //
    // Distribute over literals
    //
    if (head === 'Negate' && ops.length === 1) {
        const op1 = ops[0];
        if (typeof op1 === 'number')
            return ce.number(-op1, options);
        if (op1 instanceof Decimal)
            return ce.number(op1.neg(), options);
        const num = ce.box(op1, options).numericValue;
        if (num !== null) {
            if (typeof num === 'number')
                return ce.number(-num, options);
            if (num instanceof Decimal)
                return ce.number(num.neg(), options);
            if (num instanceof complex.exports.Complex)
                return ce.number(num.neg());
            if (isRational(num))
                return ce.number(neg(num));
        }
    }
    //
    // Dictionary
    //
    if (head === 'Dictionary') {
        const dict = {};
        for (const op of ops) {
            const arg = ce.box(op);
            const head = arg.head;
            if (head === 'KeyValuePair' ||
                head === 'Pair' ||
                (head === 'Tuple' && arg.nops === 2)) {
                const key = arg.op1;
                if (key.isValid && !key.isNothing) {
                    const value = arg.op2;
                    let k = key.symbol ?? key.string;
                    if (!k && (key.numericValue !== null || key.string)) {
                        const n = typeof key.numericValue === 'number'
                            ? key.numericValue
                            : asSmallInteger(key);
                        if (n && Number.isFinite(n) && Number.isInteger(n))
                            k = n.toString();
                    }
                    if (k)
                        dict[k] = value;
                }
            }
        }
        return new BoxedDictionary(ce, dict, options);
    }
    if (options.canonical)
        return makeCanonicalFunction(ce, head, ops, options.metadata);
    return new BoxedFunction(ce, head, ops.map((x) => box(ce, x, { canonical: false })), options);
}
/**
 * Notes about the boxed form:
 *
 * [1] Expression with a head of `Number`, `String`, `Symbol` and `Dictionary`
 *      are converted to the corresponding atomic expression.
 *
 * [2] Expressions with a head of `Complex` are converted to a (complex) number
 *     or a `Add`/`Multiply` expression.
 *
 *     The precedence of `Complex` (for serialization) is sometimes the
 *     precedence of `Add` (when re and im != 0), sometimes the precedence of
 *    `Multiply` (when im or re === 0). Using a number or an explicit
 *    `Add`/`Multiply` expression avoids this ambiguity.
 *
 * [3] An expression with a `Rational` head is converted to a rational number.
 *    if possible, to a `Divide` otherwise.
 *
 * [4] A `Negate` function applied to a number literal is converted to a number.
 *
 *
 * Note that `Negate` is only distributed over addition. In practice, having
 * `Negate` factored on multiply/divide is more useful to detect patterns.
 *
 * Note that the `box()` function should only be called from `ce.box()`
 *
 */
function box(ce, expr, options) {
    if (expr === null || expr === undefined)
        return ce._fn('Sequence', []);
    options ?? (options = {});
    if (!('canonical' in options))
        options.canonical = true;
    if (expr instanceof AbstractBoxedExpression)
        return options.canonical ? expr.canonical : expr;
    //
    //  Box a function or a rational
    //
    if (Array.isArray(expr)) {
        // If the first element is a number, it's not a function, it's a rational
        // `[number, number]`
        if (isMachineRational(expr)) {
            if (Number.isInteger(expr[0]) && Number.isInteger(expr[1]))
                return ce.number(expr);
            // This wasn't a valid rational, turn it into a `Divide`
            return boxFunction(ce, 'Divide', expr, options);
        }
        if (isBigRational(expr))
            return ce.number(expr);
        if (typeof expr[0] === 'string')
            return boxFunction(ce, expr[0], expr.slice(1), options);
        // It's a function with a head expression
        // Try to evaluate to something simpler
        const ops = expr.slice(1).map((x) => box(ce, x, options));
        const head = box(ce, expr[0], options);
        if (head.symbol)
            return new BoxedFunction(ce, head.symbol, ops);
        return apply$1(head, ops);
    }
    //
    // Box a number (other than a rational)
    //
    if (typeof expr === 'number' ||
        expr instanceof complex.exports.Complex ||
        expr instanceof Decimal)
        return ce.number(expr);
    //
    // Box a String, a Symbol or a number as a string shorthand
    //
    if (typeof expr === 'string') {
        // It's a `String` if it bracketed with apostrophes (single quotes)
        if (expr.startsWith("'") && expr.endsWith("'"))
            return new BoxedString(ce, expr.slice(1, -1));
        if (/^[+-]?[0-9]/.test(expr))
            return ce.number(expr);
        return ce.symbol(expr, options);
    }
    //
    // Box a MathJSON object literal
    //
    if (typeof expr === 'object') {
        const metadata = {
            latex: expr.latex,
            wikidata: expr.wikidata,
        };
        if ('dict' in expr)
            return new BoxedDictionary(ce, expr.dict, { canonical: true, metadata });
        if ('fn' in expr) {
            if (typeof expr.fn[0] === 'string')
                return boxFunction(ce, expr.fn[0], expr.fn.slice(1), options);
            return new BoxedFunction(ce, box(ce, expr.fn[0], options), expr.fn.slice(1).map((x) => box(ce, x, options)), { metadata });
        }
        if ('str' in expr)
            return new BoxedString(ce, expr.str, metadata);
        if ('sym' in expr)
            return ce.symbol(expr.sym, options);
        if ('num' in expr)
            return ce.number(expr, options);
    }
    return ce.symbol('Undefined');
}
function asString(expr) {
    if (typeof expr === 'string')
        return expr;
    if (expr instanceof AbstractBoxedExpression) {
        return expr.string ?? expr.symbol ?? expr.toString();
    }
    if (typeof expr === 'object') {
        if ('str' in expr)
            return expr.str;
        if ('fn' in expr &&
            expr.fn[0] === 'String' &&
            typeof expr.fn[1] === 'string')
            // @todo: that's incorrect. That argument would be a string bracketed by quotes
            return expr.fn[1];
    }
    if (Array.isArray(expr)) {
        // @todo: that's incorrect. That argument would be a string bracketed by quotes
        if (expr[0] === 'String' && typeof expr[1] === 'string')
            return expr[1];
    }
    return null;
}

function gamma(c) {
    // @todo
    // Consider: https://github.com/josdejong/mathjs/blob/develop/src/function/probability/gamma.js#L37-L76
    return c;
}
function lngamma(c) {
    return c;
}

class Sum {
    constructor(ce, xs, options) {
        // If `false`, the running sums are not calculated
        this._isCanonical = true;
        this._imaginary = 0; // integers only
        this._posInfinityCount = 0;
        this._negInfinityCount = 0;
        this._naNCount = 0;
        // Each term is factored as the product of a rational and an expression
        // For now, only rationals are factored, so `1.2x + 2.5x` are not combined.
        this._terms = [];
        options ?? (options = {});
        if (!('canonical' in options))
            options.canonical = true;
        this._isCanonical = options.canonical;
        this.engine = ce;
        this._rational = bignumPreferred(ce) ? [BigInt(0), BigInt(1)] : [0, 1];
        this._bignum = ce._BIGNUM_ZERO;
        this._number = 0;
        if (xs)
            for (const x of xs)
                this.addTerm(x);
    }
    get isEmpty() {
        if (!this._isCanonical)
            return this._terms.length === 0;
        return (this._terms.length === 0 &&
            isRationalZero(this._rational) &&
            this._imaginary === 0 &&
            this._number === 0 &&
            this._bignum.isZero() &&
            this._negInfinityCount === 0 &&
            this._posInfinityCount === 0 &&
            this._naNCount === 0);
    }
    /**
     * Add a term to the sum.
     *
     * A term is a rational coefficient and an expression.
     * Optionally, the term is multiplied by the constant `c` before being added.
     *
     * If the sum already has this term, the coefficient is added
     * to the previous one. Otherwise, a new entry is added.
     *
     * E.g. "2x + x + 1/5 y"
     *  -> [['x', [3, 1]], ['y', [1, 5]]]
     */
    addTerm(term, c) {
        if (term.isNothing)
            return;
        if (term.isNaN || (term.isImaginary && !complexAllowed(this.engine))) {
            this._naNCount += 1;
            return;
        }
        if (this._isCanonical) {
            if (term.numericValue !== null) {
                if (term.isInfinity) {
                    if (term.isPositive)
                        this._posInfinityCount += 1;
                    else
                        this._negInfinityCount += 1;
                    return;
                }
                const r = asRational(term);
                if (r) {
                    this._rational = add(this._rational, c === undefined ? r : mul(r, c));
                    return;
                }
                const num = term.numericValue;
                if (num !== null && typeof num === 'number') {
                    console.assert(!Number.isInteger(num));
                    if (bignumPreferred(this.engine))
                        this._bignum = this._bignum.add(num);
                    else
                        this._number += num;
                    return;
                }
                if (num !== null && num instanceof Decimal) {
                    console.assert(!num.isInteger());
                    this._bignum = this._bignum.add(num);
                    return;
                }
                if (num !== null && num instanceof Complex) {
                    let re = num.re;
                    let im = num.im;
                    if (Number.isInteger(re)) {
                        this._rational = add(this._rational, mul([re, 1], c ?? [1, 1]));
                        re = 0;
                    }
                    else {
                        if (bignumPreferred(this.engine))
                            this._bignum = this._bignum.add(re);
                        else
                            this._number += re;
                        re = 0;
                    }
                    if (Number.isInteger(im)) {
                        if (c === undefined)
                            this._imaginary += im;
                        else if (isMachineRational(c))
                            this._imaginary += (im * c[0]) / c[1];
                        else
                            this._imaginary += this.engine
                                .bignum(c[0])
                                .mul(im)
                                .div(this.engine.bignum(c[1]))
                                .toNumber();
                        im = 0;
                    }
                    if (re === 0 && im === 0)
                        return;
                    term = this.engine.number(this.engine.complex(re, im));
                }
            }
        }
        let coef;
        [coef, term] = asCoefficient(term);
        if (isRationalZero(coef))
            return;
        if (c !== undefined)
            coef = mul(coef, c);
        if (term.head === 'Negate') {
            this.addTerm(term.op1, neg(coef));
            return;
        }
        if (term.head === 'Add') {
            for (const x of term.ops)
                this.addTerm(x, coef);
            return;
        }
        let hasTerm = false;
        if (term.numericValue === null) {
            // There's an overhead to calculate the hash.
            // For best results, only use the hash if there are many terms
            if (this._terms.length > 500) {
                const h = term.hash;
                for (let i = 0; i < this._terms.length; i++) {
                    if (this._terms[i].term.numericValue === null &&
                        h === this._terms[i].term.hash &&
                        term.isSame(this._terms[i].term)) {
                        this._terms[i].coef = add(this._terms[i].coef, coef);
                        hasTerm = true;
                        break;
                    }
                }
            }
            else {
                for (let i = 0; i < this._terms.length; i++) {
                    if (this._terms[i].term.numericValue === null &&
                        term.isSame(this._terms[i].term)) {
                        this._terms[i].coef = add(this._terms[i].coef, coef);
                        hasTerm = true;
                        break;
                    }
                }
            }
        }
        if (!hasTerm)
            this._terms.push({ term, coef });
    }
    terms(mode) {
        const ce = this.engine;
        if (this._naNCount > 0)
            return [ce._NAN];
        if (this._imaginary !== 0 && !complexAllowed(ce))
            return [ce._NAN];
        if (this._posInfinityCount > 0 && this._negInfinityCount > 0)
            return [ce._NAN];
        if (this._posInfinityCount > 0)
            return [ce._POSITIVE_INFINITY];
        if (this._negInfinityCount > 0)
            return [ce._NEGATIVE_INFINITY];
        const xs = [];
        for (const { coef, term } of this._terms) {
            if (!isRationalZero(coef)) {
                if (isRationalOne(coef))
                    xs.push(term);
                else if (isRationalNegativeOne(coef))
                    xs.push(ce.neg(term));
                else if (machineDenominator(coef) === 1)
                    xs.push(ce.mul([ce.number(coef[0]), term]));
                else if (machineNumerator(coef) === 1)
                    xs.push(ce.div(term, ce.number(coef[1])));
                else
                    xs.push(ce.mul([ce.number(coef), term]));
            }
        }
        if (mode === 'numeric') {
            if (bignumPreferred(this.engine)) {
                let sum = this._bignum.add(this._number);
                if (!isRationalZero(this._rational))
                    sum = sum.add(ce.bignum(this._rational[0]).div(ce.bignum(this._rational[1])));
                if (this._imaginary !== 0)
                    xs.push(ce.number(ce.complex(sum.toNumber(), this._imaginary)));
                else if (ce.chop(sum) !== 0)
                    xs.push(ce.number(sum));
            }
            else {
                let sum = this._bignum.toNumber() + this._number;
                if (!isRationalZero(this._rational))
                    sum +=
                        machineNumerator(this._rational) /
                            machineDenominator(this._rational);
                if (this._imaginary !== 0)
                    xs.push(ce.number(ce.complex(sum, this._imaginary)));
                else if (ce.chop(sum) !== 0)
                    xs.push(ce.number(sum));
            }
        }
        else {
            if (!isRationalZero(this._rational))
                xs.push(ce.number(this._rational));
            if (this._imaginary !== 0) {
                if (!complexAllowed(ce))
                    return [ce._NAN];
                xs.push(ce.number(ce.complex(0, this._imaginary)));
            }
            if (bignumPreferred(this.engine)) {
                const sum = this._bignum.add(this._number);
                if (ce.chop(sum) !== 0)
                    xs.push(ce.number(sum));
            }
            else {
                if (ce.chop(this._bignum) !== 0)
                    xs.push(ce.number(this._bignum));
                if (ce.chop(this._number) !== 0)
                    xs.push(ce.number(this._number));
            }
        }
        return flattenOps(xs, 'Add');
    }
    asExpression(mode) {
        const ce = this.engine;
        const xs = this.terms(mode);
        if (xs.length === 0)
            return ce._ZERO;
        if (xs.length === 1)
            return xs[0];
        return ce._fn('Add', sortAdd(ce, xs));
    }
}

const DOMAIN_CONSTRUCTORS = [
    'Error',
    'Dictionary',
    'Function',
    'List',
    'Tuple',
    'Intersection',
    'Union',
    'Maybe',
    'Sequence',
    'Interval',
    'Range',
    'Head',
    'Symbol',
    'Value',
];
const DOMAIN_ALIAS = {
    // Function: ['Function', ['Sequence', 'Anything'], 'Anything'],
    NumericFunction: ['Function', ['Sequence', 'Number'], 'Number'],
    RealFunction: [
        'Function',
        ['Sequence', 'ExtendedRealNumber'],
        'ExtendedRealNumber',
    ],
    TrigonometricFunction: ['Function', 'Number', 'Number'],
    // HyperbolicFunction: ['Function', 'Number', 'Number'],
    LogicOperator: [
        'Function',
        'MaybeBoolean',
        ['Maybe', 'MaybeBoolean'],
        'MaybeBoolean',
    ],
    Predicate: ['Function', ['Sequence', 'Anything'], 'MaybeBoolean'],
    RelationalOperator: ['Function', 'Anything', 'Anything', 'MaybeBoolean'],
    // PositiveInteger: ['Range', 1, +Infinity],
    // NonNegativeInteger: ['Range', 0, +Infinity],
    // NegativeInteger: ['Range', -Infinity, -1],
    // NonPositiveInteger: ['Range', -Infinity, 0],
    // PositiveNumber: ['Interval', ['Open', 0], +Infinity],
    // NonNegativeNumber: ['Interval', 0, +Infinity],
    // NegativeNumber: ['Interval', -Infinity, ['Open', 0]],
    // NonPositiveNumber: ['Interval', -Infinity, 0],
};
// export const NUMERIC_DOMAIN_INFO: { [name: string]: NumericDomainInfo } = {
//   Number: { domain: 'ExtendedComplexNumber' },
//   ExtendedComplexNumber: { domain: 'ExtendedComplexNumber' },
//   ExtendedRealNumber: {
//     domain: 'ExtendedRealNumber',
//     min: -Infinity,
//     max: +Infinity,
//   },
//   ComplexNumber: { domain: 'ComplexNumber' },
//   ImaginaryNumber: {
//     domain: 'ImaginaryNumber',
//     min: -Infinity,
//     max: +Infinity,
//   },
//   RealNumber: { domain: 'RealNumber', min: -Infinity, max: +Infinity },
//   TranscendentalNumber: {
//     domain: 'TranscendentalNumber',
//     min: -Infinity,
//     max: +Infinity,
//   },
//   AlgebraicNumber: {
//     domain: 'AlgebraicNumber',
//     min: -Infinity,
//     max: +Infinity,
//   },
//   RationalNumber: { domain: 'RationalNumber', min: -Infinity, max: +Infinity },
//   Integer: { domain: 'Integer', min: -Infinity, max: +Infinity },
//   NegativeInteger: { domain: 'Integer', min: -Infinity, max: -1 },
//   NegativeNumber: {
//     domain: 'RealNumber',
//     min: -Infinity,
//     max: 0,
//     open: 'right',
//   },
//   NonNegativeNumber: { domain: 'RealNumber', min: 0, max: +Infinity },
//   NonNegativeInteger: { domain: 'Integer', min: 0, max: +Infinity },
//   NonPositiveNumber: {
//     domain: 'RealNumber',
//     min: -Infinity,
//     max: 0,
//   },
//   NonPositiveInteger: { domain: 'Integer', min: -Infinity, max: 0 },
//   PositiveInteger: { domain: 'Integer', min: 1, max: +Infinity },
//   PositiveNumber: {
//     domain: 'RealNumber',
//     min: 0,
//     max: +Infinity,
//     open: 'left',
//   },
// };
// See also sympy 'assumptions'
// https://docs.sympy.org/latest/modules/core.html#module-sympy.core.assumptions
/**
 * The set of domains form a lattice with 'Anything' at the top and 'Void'
 * at the bottom.
 *
 * This table represents this lattice by indicating the immediate parents of
 * each domain literal.
 */
const DOMAIN_LITERAL = {
    Anything: [],
    Value: 'Anything',
    Domain: 'Anything',
    DomainExpression: 'Domain',
    Void: 'Nothing',
    Nothing: [
        'DomainExpression',
        'Boolean',
        'String',
        'Symbol',
        'Tuple',
        'List',
        'Dictionary',
        'InfiniteSet',
        'FiniteSet',
        'ImaginaryNumber',
        'TranscendentalNumber',
        'PositiveInteger',
        'NegativeInteger',
        'NonPositiveInteger',
        'NonNegativeInteger',
        'PositiveNumber',
        'NegativeNumber',
        'NonPositiveNumber',
        'NonNegativeNumber',
        'Scalar',
        'TrigonometricFunction',
        'LogicOperator',
        'RelationalOperator',
    ],
    MaybeBoolean: 'Value',
    Boolean: 'MaybeBoolean',
    String: 'Boolean',
    Symbol: 'Boolean',
    Collection: 'Value',
    List: 'Collection',
    Dictionary: 'Collection',
    Sequence: 'Collection',
    Tuple: 'Sequence',
    Set: 'Collection',
    InfiniteSet: 'Set',
    FiniteSet: 'Set',
    //
    // Functional Domains
    //
    Function: 'Anything',
    Predicate: 'Function',
    LogicOperator: 'Predicate',
    RelationalOperator: 'Predicate',
    // https://en.wikipedia.org/wiki/List_of_mathematical_functions
    NumericFunction: 'Function',
    RealFunction: 'NumericFunction',
    TrigonometricFunction: 'RealFunction',
    //
    // Numeric Domains
    //
    // https://en.wikipedia.org/wiki/Category_of_sets
    Number: 'Value',
    ExtendedComplexNumber: 'Number',
    ComplexNumber: 'ExtendedComplexNumber',
    ImaginaryNumber: 'ComplexNumber',
    ExtendedRealNumber: 'ExtendedComplexNumber',
    RealNumber: ['ComplexNumber', 'ExtendedRealNumber'],
    PositiveNumber: 'NonNegativeNumber',
    NonNegativeNumber: 'RealNumber',
    NonPositiveNumber: 'NegativeNumber',
    NegativeNumber: 'RealNumber',
    TranscendentalNumber: 'RealNumber',
    AlgebraicNumber: 'RealNumber',
    RationalNumber: 'AlgebraicNumber',
    // NaturalNumber: 'Integer',
    Integer: 'RationalNumber',
    PositiveInteger: 'NonNegativeInteger',
    NonNegativeInteger: 'Integer',
    NonPositiveInteger: 'NegativeInteger',
    NegativeInteger: 'Integer',
    //
    // Tensorial Domains
    //
    Tensor: 'Value',
    Matrix: 'Tensor',
    Scalar: ['Row', 'Column'],
    Row: 'Vector',
    Column: 'Vector',
    Vector: 'Matrix',
    // https://en.wikipedia.org/wiki/List_of_named_matrices
    // ComplexTensor: 'Tensor',
    // RealTensor: 'ComplexTensor',
    // IntegerTensor: 'RealTensor',
    // LogicalTensor: 'IntegerTensor',
    // SquareMatrix: 'Matrix',
    // MonomialMatrix: 'SquareMatrix',
    // TriangularMatrix: 'SquareMatrix',
    // UpperTriangularMatrix: 'TriangularMatrix',
    // LowerTriangularMatrix: 'TriangularMatrix',
    // PermutationMatrix: ['MonomialMatrix', 'LogicalTensor', 'OrthogonalMatrix'],
    // OrthogonalMatrix: ['SquareMatrix', 'RealTensor'],
    // DiagonalMatrix: ['UpperTriangularMatrix', 'LowerTriangularMatrix'],
    // IdentityMatrix: ['DiagonalMatrix', 'SymmetricMatrix', 'PermutationMatrix'],
    // ZeroMatrix: ['DiagonalMatrix', 'SymmetricMatrix', 'PermutationMatrix'],
    // SymmetricMatrix: ['HermitianMatrix', 'SquareMatrix', 'RealTensor'],
    // HermitianMatrix: 'ComplexTensor',
    // Quaternion: ['SquareMatrix', 'ComplexTensor'],
};
let gDomainLiterals;
function isDomainLiteral(s) {
    if (!s)
        return false;
    return DOMAIN_LITERAL[s] !== undefined;
}
/** Return all the domain literals that are an ancestor of `dom`
 */
function ancestors(dom) {
    // Build the domain lattice if necessary, by calculating all the ancestors of
    // `Void` (the bottom domain)
    if (!gDomainLiterals) {
        gDomainLiterals = {};
        ancestors('Void');
    }
    if (gDomainLiterals[dom])
        return Array.from(gDomainLiterals[dom]);
    let result = [];
    if (typeof dom !== 'string' || !DOMAIN_LITERAL[dom]) {
        // Not a domain literal, it should be a constructor
        if (!Array.isArray(dom))
            throw Error(`Unknown domain literal ${dom}`);
        if (!DOMAIN_CONSTRUCTORS.includes(dom[0]))
            throw Error(`Unknown domain constructor ${dom[0]}`);
        if (dom[0] === 'Function' || dom[0] === 'Head')
            return ancestors('Function');
        if (dom[0] === 'Symbol')
            return ancestors('Symbol');
        if (dom[0] === 'Tuple')
            return ancestors('Tuple');
        if (dom[0] === 'List')
            return ancestors('List');
        if (dom[0] === 'Dictionary')
            return ancestors('Dictionary');
        if (dom[0] === 'Range')
            return ancestors('Integer');
        if (dom[0] === 'Interval')
            return ancestors('RealNumberExtended');
        if (dom[0] === 'Maybe' || dom[0] === 'Sequence')
            return ancestors(dom[1]);
        if (dom[0] === 'Literal')
            return ['Anything']; // @todo could do better
        if (dom[0] === 'Union')
            return ['Anything']; // @todo could do better
        if (dom[0] === 'Intersection')
            return ['Anything']; // @todo could do better
        return ['Anything'];
    }
    if (typeof DOMAIN_LITERAL[dom] === 'string')
        result = [DOMAIN_LITERAL[dom], ...ancestors(DOMAIN_LITERAL[dom])];
    else if (Array.isArray(DOMAIN_LITERAL[dom]))
        for (const parent of DOMAIN_LITERAL[dom]) {
            result.push(parent);
            result.push(...ancestors(parent));
        }
    gDomainLiterals[dom] = new Set(result);
    return result;
}

/**
 * A `_BoxedDomain` is a wrapper around a boxed, canonical, domain expression.
 *
 * If could also be an error, in which case, `isValid` is `false`.
 *
 */
class _BoxedDomain extends AbstractBoxedExpression {
    constructor(ce, dom, metadata) {
        super(ce, metadata);
        this._value = makeCanonical(ce, dom);
    }
    get isCanonical() {
        return true;
    }
    /** Boxed domains are always canonical. */
    get canonical() {
        return this;
    }
    get isValid() {
        return this.ctor !== 'Error';
    }
    get json() {
        const s = serialize(this.engine, this._value);
        if (head(s) === 'Error')
            return s;
        return ['Domain', s];
    }
    get literal() {
        if (typeof this._value === 'string')
            return this._value;
        return null;
    }
    get ctor() {
        if (typeof this._value === 'string')
            return null;
        return this._value[0];
    }
    get domainArgs() {
        if (typeof this._value === 'string')
            return null;
        return this._value.slice(1);
    }
    get domainArg1() {
        if (typeof this._value === 'string')
            return null;
        return this._value[1];
    }
    get codomain() {
        if (typeof this._value === 'string')
            return null;
        //  The codomain is the last argument of the `['Function']` expression
        return this.engine.domain(this._value[this._value.length - 1]);
    }
    get hash() {
        if (this._hash === undefined)
            this._hash = hashCode(hash(this._value));
        return this._hash;
    }
    isEqual(rhs) {
        return isEqual(this._value, rhs);
    }
    isSame(rhs) {
        return isEqual(this._value, rhs);
    }
    is(rhs) {
        return isEqual(this._value, rhs);
    }
    isCompatible(dom, compatibility = 'covariant') {
        const lhs = this._value;
        const rhs = dom instanceof _BoxedDomain ? dom._value : dom;
        const rhsCtor = Array.isArray(rhs) ? rhs[0] : null;
        if (rhsCtor) {
            const rhsParam = rhs[1];
            if (rhsCtor === 'Covariant')
                return isSubdomainOf1(lhs, rhsParam);
            if (rhsCtor === 'Contravariant')
                return isSubdomainOf1(rhsParam, lhs);
            if (rhsCtor === 'Invariant')
                return !isSubdomainOf1(rhsParam, lhs) && !isSubdomainOf1(lhs, rhsParam);
            if (rhsCtor === 'Bivariant')
                return isSubdomainOf1(lhs, rhsParam) && isSubdomainOf1(rhsParam, lhs);
        }
        if (compatibility === 'covariant')
            return isSubdomainOf1(lhs, rhs);
        if (compatibility === 'contravariant')
            return isSubdomainOf1(rhs, lhs);
        if (compatibility === 'bivariant')
            return isSubdomainOf1(rhs, lhs) && isSubdomainOf1(lhs, rhs);
        // Invariant
        return !isSubdomainOf1(rhs, lhs) && !isSubdomainOf1(lhs, rhs);
    }
    match(rhs, _options) {
        if (!(rhs instanceof _BoxedDomain))
            return null;
        if (this.isSame(rhs))
            return {};
        return null;
    }
    get head() {
        return 'Domain';
    }
    get domain() {
        return this.engine.domain('Domain');
    }
    get isNothing() {
        // The Nothing domain is the domain of the `Nothing` symbol
        return this._value === 'Nothing';
    }
    get isFunction() {
        return this.ctor === 'Function' || this._value === 'Function';
    }
    // get isPredicate(): boolean {
    //   if (this.domainLiteral === 'Predicate') return true;
    //   if (this.domainConstructor !== 'Function') return false;
    //   const resultDomain = this._value[this._value.length];
    //   if (!(resultDomain instanceof _Domain)) return false;
    //   return resultDomain.isBoolean;
    // }
    // get isNumericFunction(): boolean {
    //   if (this.domainLiteral === 'NumericFunction') return true;
    //   if (this.domainConstructor !== 'Function') return false;
    //   for (const arg of this.domainParams!)
    //     if (!isNumericSubdomain(arg, 'Number')) return false;
    //   return true;
    // }
    // get isBoolean(): boolean {
    //   const dom = this.domainLiteral;
    //   return dom === 'Boolean' || dom === 'MaybeBoolean';
    // }
    // get isRealFunction(): boolean {
    //   if (this.domainLiteral === 'RealFunction') return true;
    //   if (this.domainConstructor !== 'Function') return false;
    //   for (const arg of this.domainParams!)
    //     if (!isNumericSubdomain(arg, 'ExtendedRealNumber')) return false;
    //   return true;
    // }
    get isNumeric() {
        return this.isCompatible(this.engine.domain('Number'));
    }
    // get isLogicOperator(): boolean {
    //   if (this.domainLiteral === 'LogicOperator') return true;
    //   if (!this.codomain?.isBoolean) return false;
    //   const params = this.domainParams!;
    //   if (params.length < 1 || params.length > 2) return false;
    //   if (!params[0].isBoolean) return false;
    //   if (params.length === 1) return true;
    //   if (!params[1].isBoolean) return false;
    //   return true;
    // }
    get isRelationalOperator() {
        if (this._value === 'RelationalOperator')
            return true;
        if (this.ctor !== 'Function')
            return false;
        if (this.domainArgs.length !== 2)
            return false;
        if (!this.codomain.isCompatible('MaybeBoolean'))
            return false;
        return true;
    }
}
/**
 * Note that `boxDomain()` should only be called from `ComputeEngine`.
 * This gives a chance for `ComputeEngine` to substitute cached objects.
 */
function boxDomain(ce, dom, metadata) {
    if (dom instanceof _BoxedDomain)
        return dom;
    if (dom instanceof AbstractBoxedExpression)
        dom = dom.json;
    if (typeof dom === 'string') {
        const expr = DOMAIN_ALIAS[dom];
        if (expr)
            return boxDomain(ce, expr);
        if (!isDomainLiteral(dom))
            throw Error('Expected a domain literal, got ' + dom);
        return new _BoxedDomain(ce, dom, metadata);
    }
    if (!Array.isArray(dom) || dom.length === 0)
        throw Error('Expected a valid domain');
    const constructor = dom[0];
    if (!DOMAIN_CONSTRUCTORS.includes(constructor))
        throw Error('Expected domain constructor, got ' + constructor);
    return new _BoxedDomain(ce, dom, metadata);
}
/** Turn a valid domain expression into a canonical domain expression */
function makeCanonical(ce, dom) {
    if (typeof dom === 'string') {
        if (!isDomainLiteral(dom))
            throw Error('Unknown domain literal');
        return dom;
    }
    if (dom instanceof _BoxedDomain)
        return dom._value;
    const ctor = dom[0];
    if (!ctor)
        debugger;
    //
    // Range
    //
    if (ctor === 'Range') {
        if (dom.length === 1)
            return 'Integer';
        let first = 1;
        let last = +Infinity;
        if (dom.length === 2) {
            last = dom[1];
        }
        else if (dom.length === 3) {
            first = dom[1];
            last = dom[2];
        }
        const firstNum = asRangeBound(ce, first);
        const lastNum = asRangeBound(ce, last);
        if (firstNum === null || lastNum === null)
            throw Error(`Invalid range [${firstNum}, ${lastNum}] `);
        if (lastNum < firstNum)
            [first, last] = [last, first];
        if (firstNum === -Infinity && lastNum === Infinity)
            return 'Integer';
        if (firstNum === 1 && lastNum === Infinity)
            return 'PositiveInteger';
        if (firstNum === 0 && lastNum === Infinity)
            return 'NonNegativeInteger';
        if (firstNum === -Infinity && lastNum === -1)
            return 'NegativeInteger';
        if (firstNum === -Infinity && lastNum === 0)
            return 'NonPositiveInteger';
        return ['Range', ce.number(firstNum), ce.number(lastNum)];
    }
    //
    // Interval
    //
    if (ctor === 'Interval') {
        if (dom.length !== 3)
            throw Error('Invalid range ' + dom);
        let [isLeftOpen, first] = maybeOpen(ce, dom[1]);
        let [isRightOpen, last] = maybeOpen(ce, dom[2]);
        if (first === null || last === null)
            throw Error('Invalid range ' + dom);
        if (last < first) {
            [first, last] = [last, first];
            [isLeftOpen, isRightOpen] = [isRightOpen, isLeftOpen];
        }
        if (first === 0 && last === Infinity)
            return isLeftOpen ? 'PositiveNumber' : 'NonNegativeNumber';
        if (first === -Infinity && last === 0)
            return isRightOpen ? 'NegativeNumber' : 'NonPositiveNumber';
        return [
            'Interval',
            isLeftOpen ? ['Open', ce.number(first)] : ce.number(first),
            isRightOpen ? ['Open', ce.number(last)] : ce.number(last),
        ];
    }
    //
    // Function
    //
    if (ctor === 'Function') {
        // @todo:
        // Multiple `Maybe`, `Sequence` in arguments
        // Multiple Invariant, Covariant, Contravariant in argument
        // Normalize attributes: Open, Maybe, Invariant, Sequence, etc...
        // A rest argument (Sequence) must be the last one
        return [
            'Function',
            ...dom.slice(1).map((x) => makeCanonical(ce, x)),
        ];
    }
    if (ctor === 'Dictionary') {
        return ['Dictionary', makeCanonical(ce, dom[1])];
    }
    if (ctor === 'List') {
        return ['List', makeCanonical(ce, dom[1])];
    }
    if (ctor === 'Tuple') {
        return [
            'Tuple',
            ...dom.slice(1).map((x) => makeCanonical(ce, x)),
        ];
    }
    if (ctor === 'Union') {
        return [
            'Union',
            ...dom.slice(1).map((x) => makeCanonical(ce, x)),
        ];
    }
    if (ctor === 'Intersection') {
        return [
            'Intersection',
            ...dom.slice(1).map((x) => makeCanonical(ce, x)),
        ];
    }
    if (ctor === 'Covariant' ||
        ctor === 'Contravariant' ||
        ctor === 'Invariant') {
        return [ctor, makeCanonical(ce, dom[1])];
    }
    if (ctor === 'Maybe') {
        return ['Maybe', makeCanonical(ce, dom[1])];
    }
    if (ctor === 'Sequence') {
        return ['Sequence', makeCanonical(ce, dom[1])];
    }
    if (ctor === 'Head') {
        return ['Head', dom[1]];
    }
    if (ctor === 'Symbol') {
        return ['Symbol', dom[1]];
    }
    if (ctor === 'Value') {
        return ['Value', ce.box(dom[1])];
    }
    if (ctor === 'Error') {
        return ['Error', ...dom.slice(1).map((x) => ce.box(x))];
    }
    throw Error('Unexpected domain constructor ' + ctor);
}
function asRangeBound(ce, expr) {
    if (typeof expr === 'number')
        return expr;
    const x = ce.box(expr).evaluate();
    return x.isInfinity
        ? x.isPositive
            ? +Infinity
            : -Infinity
        : asSmallInteger(x);
}
// function asIntervalBound(ce: IComputeEngine, expr: Expression): number | null {
//   const val = ce.box(open(expr) ?? expr).evaluate();
//   return (
//     val.asSmallInteger ??
//     (val.isInfinity ? (val.isPositive ? +Infinity : -Infinity) : null)
//   );
// }
function maybeOpen(ce, expr) {
    // @todo: Multiple Open
    if (Array.isArray(expr) && expr[0] === 'Open')
        return [true, asRangeBound(ce, expr[1])];
    return [false, asRangeBound(ce, expr)];
}
/** Validate that `expr` is a Domain */
function isDomain(expr) {
    if (expr instanceof _BoxedDomain)
        return true;
    if (expr instanceof AbstractBoxedExpression)
        expr = expr.json;
    if (typeof expr === 'string')
        return isDomainLiteral(expr);
    if (Array.isArray(expr)) {
        if (expr.length <= 1)
            return false;
        // Could be a domain expression
        const ctor = expr[0];
        if (typeof ctor !== 'string' || !DOMAIN_CONSTRUCTORS.includes(ctor))
            return false;
        if (ctor === 'List')
            return expr.length === 2 && isDomain(expr[1]);
        if (ctor === 'Tuple' ||
            ctor === 'Function' ||
            ctor === 'Maybe' ||
            ctor === 'Sequence' ||
            ctor === 'Intersection' ||
            ctor === 'Union')
            return expr.slice(1, -1).every((x) => isDomain(x));
        return expr.every((x) => x !== null);
    }
    return false;
}
function isSubdomainOf1(lhs, rhs) {
    const [result, rest] = isSubdomainOf([lhs], rhs);
    if (result && rest.length === 0)
        return true;
    return false;
}
// Return `true` if `lhs` is a sub domain of, or equal to, `rhs`
// `lhs` is the "template" that `rhs` is checked against
function isSubdomainOf(xlhs, rhs) {
    let lhs = xlhs.shift();
    const rhsLiteral = typeof rhs === 'string' ? rhs : null;
    if (rhsLiteral === 'Anything')
        return [true, xlhs];
    const lhsLiteral = typeof lhs === 'string' ? lhs : null;
    //
    // 1/ Compare two domain literals
    //
    if (lhsLiteral && rhsLiteral) {
        if (lhsLiteral === rhsLiteral)
            return [true, xlhs];
        return [ancestors(lhsLiteral).includes(rhsLiteral), xlhs];
    }
    //
    // 2/ Is the lhs domain constructor a subdomain of the rhs domain literal?
    //
    if (rhsLiteral) {
        if (!lhs)
            debugger;
        const lhsConstructor = lhs[0];
        if (lhsConstructor === 'Function')
            return [rhsLiteral === 'Function', xlhs];
        if (lhsConstructor === 'Dictionary')
            return [rhsLiteral === 'Dictionary', xlhs];
        if (lhsConstructor === 'List')
            return [rhsLiteral === 'List', xlhs];
        if (lhsConstructor === 'Tuple')
            return [rhsLiteral === 'Tuple', xlhs];
        // @todo handle domain constructors
        // 'Intersection',
        // 'Union',
        // 'Maybe',
        // 'Sequence',
        if (lhsConstructor === 'Interval')
            return [isSubdomainOf1('ExtendedRealNumber', rhsLiteral), xlhs];
        if (lhsConstructor === 'Range')
            return [isSubdomainOf1('Integer', rhsLiteral), xlhs];
        // 'Head',
        // 'Symbol',
        // 'Value',
        return [true, xlhs];
    }
    //
    // 3/ Compare a rhs domain expression with a domain literal or expression
    //
    const rhsConstructor = rhs[0];
    if (rhsConstructor === 'Function') {
        // See https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance
        if (lhsLiteral === 'Function')
            return [true, xlhs];
        if (lhsLiteral)
            return [false, xlhs];
        // Only a `Function` ctor can be a subdomain of a `Function`
        if (lhs[0] !== 'Function')
            return [false, xlhs];
        // Both constructors are 'Function':
        if (lhs.length === 1 && rhs.length === 1)
            return [true, xlhs];
        // Check that the values are compatible (covariant)
        if (!isSubdomainOf1(lhs[lhs.length - 1], rhs[rhs.length - 1]))
            return [false, xlhs];
        // Check that parameters are contravariant
        const lhsParams = lhs.slice(1, -1);
        let rhsParams = rhs.slice(1, -1);
        // let j = 0;
        for (let i = 0; i <= lhsParams.length - 1; i++) {
            // `rhs` is not expected to include a `Sequence`, `Contravariant`, etc... ctor, but `lhs` might
            if (rhsParams.length === 0) {
                // We have run out of rhs parameters
                const lhsCtor = Array.isArray(lhsParams[i]) ? lhsParams[i][0] : null;
                if (lhsCtor !== 'Maybe')
                    return [false, xlhs];
                // Any remaining lhs parameters should be optional
                return [true, xlhs];
            }
            else {
                let match = false;
                [match, rhsParams] = isSubdomainOf(rhsParams, lhsParams[i]);
                if (!match)
                    return [false, xlhs];
            }
        }
        // There should be no `rhs` parameters left to check
        return [rhsParams.length === 0, xlhs];
    }
    // @todo handle domain constructors
    // 'Dictionary',
    // 'List',
    // 'Tuple',
    if (rhsConstructor === 'Intersection') {
        return [
            rhs
                .slice(1, -1)
                .every((x) => isSubdomainOf1(lhs, x)),
            xlhs,
        ];
    }
    if (rhsConstructor === 'Union') {
        return [
            rhs
                .slice(1, -1)
                .some((x) => isSubdomainOf1(lhs, x)),
            xlhs,
        ];
    }
    if (rhsConstructor === 'Maybe') {
        if (lhsLiteral === 'Nothing')
            return [true, xlhs];
        return isSubdomainOf([lhs, ...xlhs], rhs[1]);
    }
    if (rhsConstructor === 'Sequence') {
        const seq = rhs[1];
        if (!isSubdomainOf1(lhs, seq))
            return [false, xlhs];
        lhs = xlhs.shift();
        // Skip over all other parameters of domain `seq`
        let match = true;
        while (xlhs.length > 0 && match) {
            [match, xlhs] = isSubdomainOf(xlhs, seq);
            lhs = xlhs.shift();
        }
        return [true, xlhs];
    }
    if (rhsConstructor === 'Tuple') {
        if (!Array.isArray(lhs) || lhs[0] !== 'Tuple')
            return [false, xlhs];
        if (lhs.length > rhs.length)
            return [false, xlhs];
        for (let i = 1; i <= rhs.length - 1; i++) {
            if (!lhs[i] ||
                !isSubdomainOf1(lhs[i], rhs[i]))
                return [false, xlhs];
        }
        return [true, xlhs];
    }
    // 'Head',
    // 'Symbol',
    // 'Value',
    if (rhsConstructor === 'Range') {
        if (!Array.isArray(lhs) || lhs[0] !== 'Range')
            return [false, xlhs];
        const lhsMin = asFloat(lhs[1]);
        const lhsMax = asFloat(lhs[2]);
        const rhsMin = asFloat(rhs[1]);
        const rhsMax = asFloat(rhs[2]);
        return [
            lhsMin !== null &&
                lhsMax !== null &&
                rhsMin !== null &&
                rhsMax !== null &&
                lhsMin >= rhsMin &&
                lhsMax <= rhsMax,
            xlhs,
        ];
    }
    if (rhsConstructor === 'Interval') {
        if (!Array.isArray(lhs) || lhs[0] !== 'Interval')
            return [false, xlhs];
        const lhsMin = asFloat(lhs[1]);
        const lhsMax = asFloat(lhs[2]);
        const rhsMin = asFloat(rhs[1]);
        const rhsMax = asFloat(rhs[2]);
        return [
            lhsMin !== null &&
                lhsMax !== null &&
                rhsMin !== null &&
                rhsMax !== null &&
                lhsMin >= rhsMin &&
                lhsMax <= rhsMax,
            xlhs,
        ];
    }
    console.error('Unexpected domain constructor ' + rhsConstructor);
    return [false, xlhs];
}
/** Return the ancestor domain that is shared by both `a` and `b` */
function sharedAncestorDomain(a, b) {
    const aLiteral = domainLiteralAncestor(a);
    const bLiteral = domainLiteralAncestor(b);
    const aAncestors = [aLiteral, ...ancestors(aLiteral)];
    const bAncestors = [bLiteral, ...ancestors(bLiteral)];
    while (!bAncestors.includes(aAncestors[0]))
        aAncestors.shift();
    return a.engine.domain(aAncestors[0]);
}
// Return the domain literal that is the closest ancestor to `dom`
function domainLiteralAncestor(dom) {
    let result = dom.literal;
    if (result)
        return result;
    result = dom.ctor;
    if (result === 'Maybe')
        return 'Anything';
    if (result === 'Interval')
        return 'RealNumber';
    if (result === 'Range')
        return 'Integer';
    if (result === 'Head')
        return 'Function';
    if (result === 'Union')
        return 'Anything'; // @todo could be more narrow
    if (result === 'Intersection')
        return 'Anything'; // @todo could be more narrow
    return result;
}
function serialize(ce, dom) {
    if (dom instanceof AbstractBoxedExpression)
        return dom.json;
    if (typeof dom === 'string')
        return dom;
    if (dom[0] === 'Error') {
        if (dom[2])
            return [
                'Error',
                serialize(ce, dom[1]),
                serialize(ce, dom[2]),
            ];
        return [
            'Error',
            serialize(ce, dom[1]),
        ];
    }
    const result = [serializeJsonSymbol(ce, dom[0])];
    if (dom.length > 1)
        for (let i = 1; i <= dom.length - 1; i++)
            result.push(serialize(ce, dom[i]));
    return result;
}
function hash(dom) {
    if (typeof dom === 'string')
        return 'domain:' + dom;
    let s = 'domain:' + this.ctor;
    for (const arg of this.domainArgs)
        s += ':' + hash(arg);
    return s;
}
function isEqual(lhs, rhs) {
    if (typeof rhs === 'string')
        return this._value === rhs;
    if (rhs instanceof _BoxedDomain)
        return isEqual(lhs, rhs._value);
    // Is it a domain literal?
    if (typeof lhs === 'string')
        return lhs === rhs;
    console.assert(Array.isArray(lhs));
    if (!Array.isArray(rhs))
        return false;
    // It's not a domain literal
    if (lhs[0] !== rhs[0])
        return false;
    if (rhs.length !== lhs.length)
        return false;
    for (let i = 1; i <= lhs.length - 1; i++) {
        if (lhs[i] instanceof AbstractBoxedExpression) {
            if (!(rhs[i] instanceof AbstractBoxedExpression))
                return false;
            if (!rhs[i].isEqual(rhs[i]))
                return false;
        }
        else if (typeof lhs[i] === 'string') {
            if (typeof rhs[i] !== 'string')
                return false;
            if (lhs[i] !== rhs[i])
                return false;
        }
        else if (!isEqual(lhs[i], rhs[i]))
            return false;
    }
    return true;
}

/** The canonical form of `Add`:
 * - removes `0`
 * - capture complex numbers (a + ib or ai +b)
 * */
function canonicalAdd(ce, ops) {
    console.assert(ops.every((x) => x.isCanonical));
    // Remove literal 0
    ops = ops.filter((x) => x.numericValue === null || !x.isZero);
    if (ops.length === 0)
        return ce.number(0);
    if (ops.length === 1)
        return ops[0];
    //
    // Is this a  complex number, i.e. `a + ib` or `ai + b`?
    //
    if (ops.length === 2) {
        let im = 0;
        let re = 0;
        re = asFloat(ops[0]);
        if (re !== null && re !== 0)
            im = getImaginaryCoef(ops[1]);
        else {
            im = getImaginaryCoef(ops[0]);
            if (im !== 0 && ops[1].numericValue !== null)
                re = asFloat(ops[1]);
        }
        if (re !== null && im !== null && im !== 0)
            return ce.number(ce.complex(re, im));
    }
    // Commutative, sort
    if (ops.length > 1)
        ops = sortAdd(ce, ops);
    return ce._fn('Add', ops);
}
function domainAdd(_ce, args) {
    let dom = null;
    for (const arg of args) {
        if (!arg.isNumeric)
            return null;
        if (!dom)
            dom = arg;
        else
            dom = sharedAncestorDomain(dom, arg);
    }
    return dom;
}
function simplifyAdd(ce, args) {
    console.assert(args.length > 1, `simplifyAdd: not enough args`);
    const sum = new Sum(ce);
    for (let arg of args) {
        arg = arg.simplify();
        if (arg.isImaginary && arg.isInfinity)
            return ce.symbol('ComplexInfinity');
        if (arg.isNaN || arg.symbol === 'Undefined')
            return ce._NAN;
        if (!arg.isZero)
            sum.addTerm(arg);
    }
    return sum.asExpression('expression');
}
function evalAddNum(ops) {
    let sum = 0;
    for (const op of ops) {
        const v = op.numericValue;
        if (typeof v === 'number')
            sum += v;
        else
            return null;
    }
    return sum;
}
function evalAdd(ce, ops, mode = 'evaluate') {
    // @fastpath
    if (mode === 'N' && ce.numericMode === 'machine') {
        ops = ops.map((x) => x.N());
        const sum = evalAddNum(ops);
        if (sum !== null)
            return ce.number(sum);
    }
    //
    // First pass: looking for early exits
    //
    for (const arg of ops) {
        if (arg.isImaginary && arg.isInfinity)
            return ce.symbol('ComplexInfinity');
        if (arg.isNaN || arg.symbol === 'Undefined')
            return ce._NAN;
        if (!arg.isExact)
            mode = 'N';
    }
    if (mode === 'N')
        ops = ops.map((x) => x.N());
    else
        ops = ops.map((x) => x.evaluate());
    return new Sum(ce, ops).asExpression(mode === 'N' ? 'numeric' : 'expression');
}
function canonicalSummation(ce, body, range) {
    body ?? (body = ce.error(['missing', 'Function'])); // @todo not exactly a function, more like a 'NumericExpression'
    let index = null;
    let lower = null;
    let upper = null;
    if (range &&
        range.head !== 'Tuple' &&
        range.head !== 'Triple' &&
        range.head !== 'Pair' &&
        range.head !== 'Single') {
        index = range;
    }
    else if (range) {
        index = range.ops?.[0] ?? null;
        lower = range.ops?.[1]?.canonical ?? null;
        upper = range.ops?.[2]?.canonical ?? null;
    }
    if (index?.head === 'Hold')
        index = index.op1;
    if (index?.head === 'ReleaseHold')
        index = index.op1?.evaluate();
    index ?? (index = ce.symbol('Nothing'));
    if (!index.symbol)
        index = ce.error(['incompatible-domain', 'Symbol', index.domain]);
    if (index.symbol)
        ce.pushScope({ [index.symbol]: { domain: 'Integer' } });
    const fn = body.canonical;
    if (index.symbol) {
        ce.popScope();
        index = index = ce.hold(index);
    }
    if (lower && upper)
        range = ce.tuple([index, lower, upper]);
    else if (upper)
        range = ce.tuple([index, lower ?? ce._NEGATIVE_INFINITY, upper]);
    else if (lower)
        range = ce.tuple([index, lower]);
    else
        range = index;
    return ce._fn('Sum', [fn, range]);
}
function evalSummation(ce, expr, range, mode) {
    const fn = expr;
    let lower = 1;
    let upper = MAX_ITERATION;
    let index = 'Nothing';
    if (range.head === 'Tuple' ||
        range.head === 'Triple' ||
        range.head === 'Pair' ||
        range.head === 'Single') {
        index =
            (range.op1.head === 'Hold' ? range.op1.op1.symbol : range.op1.symbol) ??
                'Nothing';
        lower = asSmallInteger(range.op2) ?? 1;
        upper = asSmallInteger(range.op3) ?? MAX_ITERATION;
    }
    if (mode !== 'N' && (lower >= upper || upper - lower >= MAX_SYMBOLIC_TERMS))
        return undefined;
    const savedContext = ce.context;
    ce.context = fn.scope ?? ce.context;
    if (mode === 'simplify') {
        const terms = [];
        if (!fn.scope)
            for (let i = lower; i <= upper; i++)
                terms.push(fn.simplify());
        else
            for (let i = lower; i <= upper; i++) {
                ce.set({ [index]: i });
                terms.push(fn.simplify());
            }
        ce.context = savedContext;
        return ce.add(terms).simplify();
    }
    if (mode === 'evaluate') {
        const terms = [];
        if (!fn.scope)
            for (let i = lower; i <= upper; i++)
                terms.push(fn.evaluate());
        else
            for (let i = lower; i <= upper; i++) {
                ce.set({ [index]: i });
                terms.push(fn.evaluate());
            }
        ce.context = savedContext;
        return ce.add(terms).evaluate();
    }
    let sum = bignumPreferred(ce) ? [BigInt(1), BigInt(1)] : [0, 1];
    if (!fn.scope)
        for (let i = lower; i <= upper; i++) {
            const term = fn.N();
            if (term.numericValue === null)
                return undefined;
            sum = add(sum, term);
        }
    else
        for (let i = lower; i <= upper; i++) {
            ce.set({ [index]: i });
            const term = fn.N();
            if (term.numericValue === null) {
                ce.context = savedContext;
                return undefined;
            }
            sum = add(sum, term);
        }
    ce.context = savedContext;
    if (isMachineRational(sum))
        return ce.number(sum[0] / sum[1]);
    return ce.number(ce.bignum(sum[0]).div(ce.bignum(sum[1])));
}

// @todo: replace usage with asCoefficient():
// it does the same thing, but also extracts any literal coefficient
function makePositive(expr) {
    if (expr.head === 'Negate')
        return [-1, expr.op1];
    const n = expr.numericValue;
    if (n === null)
        return [1, expr];
    const ce = expr.engine;
    if (typeof n === 'number' && n < 0)
        return [-1, ce.number(-n)];
    if (n instanceof Decimal && n.isNegative())
        return [-1, ce.number(n.neg())];
    // Make the part positive if the real part is negative
    if (n instanceof Complex && n.re < 0)
        return [-1, ce.number(ce.complex(-n.re, -n.im))];
    if (isMachineRational(n) && n[0] < 0)
        return [-1, ce.number([-n[0], n[1]])];
    if (isBigRational(n) && n[0] < 0)
        return [-1, ce.number([-n[0], n[1]])];
    return [1, expr];
}
function apply(expr, fn, bigFn, complexFn) {
    const n = expr.numericValue;
    const ce = expr.engine;
    console.assert(n !== null);
    if (typeof n === 'number') {
        if (bignumPreferred(ce) && bigFn)
            return ce.chop(bigFn(ce.bignum(n)));
        return ce.chop(fn(n));
    }
    if (n instanceof Decimal)
        return ce.chop(bigFn?.(n) ?? fn(n.toNumber()));
    if (isMachineRational(n)) {
        if (!bignumPreferred(ce) || !bigFn)
            return ce.chop(fn(n[0] / n[1]));
        return ce.chop(bigFn(ce.bignum(n[0]).div(n[1])));
    }
    if (isBigRational(n)) {
        if (bigFn)
            return ce.chop(bigFn(ce.bignum(n[0]).div(ce.bignum(n[1]))));
        return ce.chop(fn(Number(n[0]) / Number(n[1])));
    }
    if (n instanceof Complex) {
        if (!complexFn || !complexAllowed(ce))
            return NaN;
        return ce.chop(complexFn(n));
    }
    debugger;
    return NaN;
}
function applyN(expr, fn, bigFn, complexFn) {
    if (expr.numericValue === null)
        return undefined;
    return expr.engine.number(apply(expr, fn, bigFn, complexFn));
}
function apply2(expr1, expr2, fn, bigFn, complexFn) {
    console.assert(expr1.numericValue !== null && expr2.numericValue !== null);
    const ce = expr1.engine;
    let m1 = expr1.numericValue;
    if (isMachineRational(m1))
        m1 = m1[0] / m1[1];
    let m2 = expr2.numericValue;
    if (isMachineRational(m2))
        m2 = m2[0] / m2[1];
    if (!bignumPreferred(ce) && typeof m1 === 'number' && typeof m2 === 'number')
        return fn(m1, m2);
    let b1 = undefined;
    if (m1 instanceof Decimal)
        b1 = m1;
    else if (isBigRational(m1))
        b1 = ce.bignum(m1[0]).div(ce.bignum(m1[1]));
    else if (m1 !== null && typeof m1 === 'number')
        b1 = ce.bignum(m1);
    let b2 = undefined;
    if (m2 instanceof Decimal)
        b2 = m2;
    else if (isBigRational(m2))
        b1 = ce.bignum(m2[0]).div(ce.bignum(m2[1]));
    else if (m2 !== null && typeof m2 === 'number')
        b2 = ce.bignum(m2);
    if (b1 && b2)
        return bigFn?.(b1, b2) ?? fn(b1.toNumber(), b2.toNumber());
    if (m1 instanceof Complex || m2 instanceof Complex) {
        if (!complexFn || !complexAllowed(ce))
            return NaN;
        return complexFn(ce.complex(m1 ?? b1?.toNumber() ?? NaN), ce.complex(m2 ?? b2?.toNumber() ?? NaN));
    }
    debugger;
    return NaN;
}
function apply2N(expr1, expr2, fn, bigFn, complexFn) {
    if (expr1.numericValue === null || expr2.numericValue === null)
        return undefined;
    return expr1.engine.number(apply2(expr1, expr2, fn, bigFn, complexFn));
}

/**
 *
 */
function canonicalPower(ce, base, exponent, metadata) {
    if (exponent.symbol === 'ComplexInfinity')
        return ce._NAN;
    if (exponent.isZero)
        return ce._ONE;
    if (exponent.isOne)
        return base;
    if (exponent.isNegativeOne)
        return ce.inv(base);
    if (exponent.numericValue !== null) {
        if (base.numericValue !== null) {
            const numBase = asFloat(base);
            //
            // Special cases
            //
            // Implement same results as sympy.
            // See https://docs.sympy.org/1.6/modules/core.html#pow
            //
            // if (base.isOne) return ce._ONE;
            if (numBase === 1)
                return ce._ONE;
            // if (base.isZero) {
            if (numBase === 0) {
                if (exponent.isPositive)
                    return ce._ZERO;
                if (exponent.isNegative)
                    return ce._COMPLEX_INFINITY; //  Unsigned Infinity...
            }
            //  x^(-1)
            if (exponent.isNegativeOne)
                return ce.inv(base);
            // x^{0.5}, x^{1/2} -> Square Root
            const e = asFloat(exponent);
            if (e === 0.5 || e === -0.5) {
                const b = asSmallInteger(base);
                if (b !== null && b > 0) {
                    // Factor out small integers
                    // √(12) -> 2√3
                    const [coef, radicand] = factorPower$1(b, 2);
                    if (radicand === 1 && coef === 1)
                        return ce._ONE;
                    if (coef !== 1) {
                        if (radicand === 1)
                            return ce.number(e >= 0 ? coef : [1, coef]);
                        return ce.mul([
                            ce.number(coef),
                            ce._fn('Sqrt', [ce.number(radicand)]),
                        ]);
                    }
                    if (e > 0)
                        return ce._fn('Sqrt', [base], metadata);
                    return ce.inv(ce._fn('Sqrt', [base]), metadata);
                }
                if (e > 0)
                    return ce._fn('Power', [base, ce._HALF], metadata);
                return ce._fn('Power', [base, ce.number([-1, 2])], metadata);
            }
            if (base.isInfinity) {
                if (exponent.numericValue instanceof Complex) {
                    const re = exponent.numericValue.re;
                    if (re === 0)
                        return ce._NAN;
                    if (re < 0)
                        return ce._ZERO;
                    if (re > 0)
                        return ce._COMPLEX_INFINITY;
                }
                if (base.isNegative) {
                    // base = -∞
                    if (exponent.isInfinity)
                        return ce._NAN;
                }
                else if (base.isPositive) {
                    // base = +∞
                    if (exponent.isNegativeOne)
                        return ce._ZERO;
                    if (exponent.isInfinity)
                        return exponent.isNegative ? ce._ZERO : ce._POSITIVE_INFINITY;
                }
            }
            if (exponent.isInfinity && (base.isOne || base.isNegativeOne))
                return ce._NAN;
        }
    }
    //
    // Power rule
    //
    if (base.head === 'Power' && base.op1.isReal) {
        const a = asSmallInteger(exponent);
        if (a !== null) {
            const b = asSmallInteger(base.op2);
            if (b !== null) {
                return ce.pow(base.op1, ce.number(a * b));
            }
        }
        if (base.op1.isNonNegative) {
            const ar = asRational(exponent);
            if (ar) {
                const br = asRational(base.op2);
                if (br)
                    return ce.pow(base.op1, ce.number(mul(ar, br)));
            }
        }
    }
    // Distribute over multiplication
    // (abc)^n -> a^n b^n c^n
    if (base.head === 'Multiply') {
        const e = asSmallInteger(exponent);
        if (e !== null)
            return ce._fn('Multiply', base.ops.map((x) => ce.pow(x, exponent))); // Don't call ce.mul() to avoid infinite loops
    }
    return ce._fn('Power', [base, exponent], metadata);
}
function square(ce, base) {
    const num = base.numericValue;
    if (typeof num === 'number')
        return ce.number(num * num);
    if (num instanceof Decimal)
        return ce.number(num.pow(2));
    if (num instanceof Complex)
        return ce.number(num.pow(2));
    if (isMachineRational(num))
        return ce.number([num[1] * num[1], num[0] * num[0]]);
    if (isBigRational(num))
        return ce.number([num[1] * num[1], num[0] * num[0]]);
    if (base.head === 'Multiply')
        return ce._fn('Multiply', base.ops.map((x) => square(ce, x))); // Don't call ce.mul() to avoid infinite loops
    if (base.head === 'Power') {
        const exp = asSmallInteger(base.op2);
        if (exp !== null)
            return ce.pow(base.op1, ce.number(exp * 2));
        return ce.pow(base.op1, ce.mul([ce.number(2), base.op2]));
    }
    return ce.pow(base, ce.number(2));
}
function numEvalPower(ce, base, exponent) {
    if (base.numericValue === null || exponent.numericValue === null)
        return undefined;
    //
    // Complex base or exponent
    //
    if (base.numericValue instanceof Complex) {
        if (exponent.numericValue instanceof Complex)
            return ce.number(base.numericValue.pow(exponent.numericValue));
        return ce.number(base.numericValue.pow(asFloat(exponent) ?? NaN));
    }
    if (exponent.numericValue instanceof Complex) {
        const b = asFloat(base) ?? null;
        if (b !== null)
            return ce.number(ce.complex(b).pow(exponent.numericValue));
        return undefined;
    }
    //
    // Bignum
    //
    const invExp = rootExp(exponent);
    if (bignumPreferred(ce) ||
        base.numericValue instanceof Decimal ||
        exponent.numericValue instanceof Decimal) {
        const bigBase = asBignum(base);
        const bigExp = asBignum(exponent);
        if (!bigBase || !bigExp)
            return undefined;
        if (invExp === 2) {
            if (bigBase.isNeg())
                return complexAllowed(ce)
                    ? ce.number(ce.complex(0, bigBase.neg().sqrt().toNumber()))
                    : ce._NAN;
            return ce.number(bigBase.sqrt());
        }
        if (!bigExp.isInteger() && bigBase.isNeg()) {
            // Complex, if allowed
            if (!complexAllowed(ce))
                return ce._NAN;
            const zBase = ce.complex(bigBase.toNumber());
            const zExp = ce.complex(bigExp.toNumber());
            return ce.number(zBase.pow(zExp));
        }
        return ce.number(bigBase.pow(bigExp));
    }
    //
    // Machine
    //
    const floatExp = asFloat(exponent) ?? NaN;
    const floatBase = asFloat(base) ?? NaN;
    if (invExp === 2) {
        if (floatBase < 0) {
            return complexAllowed(ce)
                ? ce.mul([ce._I, ce.number(Math.sqrt(-floatBase))])
                : ce._NAN;
        }
        return ce.number(Math.sqrt(floatBase));
    }
    if (!Number.isInteger(floatExp) && floatBase < 0) {
        if (!complexAllowed(ce))
            return ce._NAN;
        const zBase = ce.complex(floatBase);
        const zExp = ce.complex(floatExp);
        return ce.number(zBase.pow(zExp));
    }
    return ce.number(Math.pow(floatBase, floatExp));
}
function processPower(ce, base, exponent, mode) {
    if (base.head === 'Multiply') {
        let c = bignumPreferred(ce) ? [BigInt(1), BigInt(1)] : [1, 1];
        const xs = [];
        for (const op of base.ops) {
            const r = asRational(op);
            if (r)
                c = mul(c, r);
            else
                xs.push(op);
        }
        if (!isRationalOne(c))
            return ce.mul([
                processSqrt(ce, ce.number(c), mode) ?? ce._ONE,
                ce.pow(processPower(ce, ce.mul(xs), exponent, mode) ?? ce.mul(xs), exponent),
            ]);
    }
    if (base.head === 'Power') {
        // a^-1^-1 -> a
        if (asSmallInteger(base.op2) === -1 && asSmallInteger(exponent) === -1)
            return base.op1;
        const e1 = asRational(base.op2);
        const e2 = asRational(exponent);
        if (e1 && e2) {
            const e = mul(e1, e2);
            if (isRationalZero(e))
                return ce._ONE;
            if (isRationalOne(e))
                return base.op1;
            return ce.pow(base.op1, e);
        }
        if (mode === 'N') {
            const ef1 = asFloat(base.op2);
            const ef2 = asFloat(exponent);
            if (ef1 !== null && ef2 !== null) {
                const ef = ef1 * ef2;
                if (ef === 0)
                    return ce._ONE;
                if (ef === 1)
                    return base.op1;
                return ce.pow(base.op1, ef);
            }
        }
    }
    //
    // If square root or cube root, attempt to factor out the perfect
    // factors: sqrt(75) -> 5^2 * 3
    //
    if (mode !== 'N' && base.numericValue !== null && base.isInteger) {
        const smallExpr = asSmallInteger(exponent);
        if (smallExpr)
            return numEvalPower(ce, base, exponent);
        const r = asRational(exponent);
        if (r) {
            const [n, d] = [machineNumerator(r), machineDenominator(r)];
            if ((n === 1 || n === -1) && (d === 2 || d === 3)) {
                if (bignumPreferred(ce) || base.numericValue instanceof Decimal) {
                    const bigBase = asBigint(base);
                    if (d % 2 === 0 && bigBase < 0 && !complexAllowed(ce))
                        return ce._NAN;
                    const sign = bigBase < 0 ? (d % 2 === 0 ? ce._I : ce._NEGATIVE_ONE) : ce._ONE;
                    const [factor, root] = factorPower(bigBase > 0 ? bigBase : -bigBase, d);
                    if (root === BigInt(1) && factor === BigInt(1))
                        return sign;
                    // If factor === 1, nothing special to do, fall through
                    if (factor !== BigInt(1)) {
                        if (root === BigInt(1))
                            return ce.mul([
                                sign,
                                ce.number(n >= 0 ? factor : [BigInt(1), factor]),
                            ]);
                        return ce.mul([
                            sign,
                            ce.number(factor),
                            ce.pow(ce.number(root), exponent),
                        ]);
                    }
                }
                else if (typeof base.numericValue === 'number') {
                    // Square root of a negative number, and no complex allowed
                    if (base.numericValue < 0 && d % 2 === 0 && !complexAllowed(ce))
                        return ce._NAN;
                    const [factor, root] = factorPower$1(Math.abs(base.numericValue), d);
                    const sign = base.numericValue < 0
                        ? d % 2 === 0
                            ? ce._I
                            : ce._NEGATIVE_ONE
                        : ce._ONE;
                    if (root === 1 && factor === 1)
                        return sign;
                    if (factor !== 1) {
                        if (root === 1)
                            return ce.mul([sign, ce.number(n >= 0 ? factor : [1, factor])]);
                        return ce.mul([
                            sign,
                            ce.number(factor),
                            ce.pow(ce.number(root), exponent),
                        ]);
                    }
                }
                else ;
            }
            if (base.isNegative) {
                if (!complexAllowed)
                    return ce._NAN;
                return ce.mul([ce._I, ce.fn('Sqrt', [ce.neg(base)])]);
            }
            return undefined;
        }
    }
    if (mode !== 'simplify' &&
        base.numericValue !== null &&
        exponent.numericValue !== null)
        return numEvalPower(ce, base, exponent);
    return undefined;
}
function processSqrt(ce, base, mode) {
    if (base.isOne)
        return ce._ONE;
    if (base.isZero)
        return ce._ZERO;
    if (base.isNegativeOne)
        return complexAllowed(ce) ? ce._I : ce._NAN;
    if (base.isNegative && !complexAllowed(ce))
        return ce._NAN;
    const r = asRational(base);
    if (mode === 'N' || (mode === 'evaluate' && !r))
        return applyN(base, (x) => (x < 0 ? ce.complex(x).sqrt() : Math.sqrt(x)), (x) => (x.isNeg() ? ce.complex(x.toNumber()).sqrt() : x.sqrt()), (x) => x.sqrt());
    const n = asSmallInteger(base);
    if (n !== null) {
        const [factor, root] = factorPower$1(Math.abs(n), 2);
        if (n < 0) {
            if (root === 1)
                ce.mul([ce.number(ce.complex(0, factor))]);
            return ce.mul([
                ce.number(ce.complex(0, factor)),
                ce.sqrt(ce.number(root)),
            ]);
        }
        if (root === 1)
            return ce.number(factor);
        return ce.mul([ce.number(factor), ce.sqrt(ce.number(root))]);
    }
    if (r) {
        if (isMachineRational(r) && !bignumPreferred(ce)) {
            const [n, d] = r;
            if (Math.abs(n) < Number.MAX_SAFE_INTEGER &&
                d < Number.MAX_SAFE_INTEGER) {
                const [nFactor, nRoot] = factorPower$1(Math.abs(n), 2);
                const [dFactor, dRoot] = factorPower$1(d, 2);
                if (n < 0)
                    return ce.mul([
                        ce.number([nFactor, dFactor]),
                        ce.sqrt(ce.number([nRoot, dRoot])),
                        ce._I,
                    ]);
                return ce.mul([
                    ce.number([nFactor, dFactor]),
                    ce.sqrt(ce.number([nRoot, dRoot])),
                ]);
            }
        }
        if (isBigRational(r) || bignumPreferred(ce)) {
            const n = bigint(r[0]);
            const [nFactor, nRoot] = factorPower(n > 0 ? n : -n, 2);
            const [dFactor, dRoot] = factorPower(bigint(r[1]), 2);
            if (n < 0)
                return ce.mul([
                    ce.number([nFactor, dFactor]),
                    ce.sqrt(ce.number([nRoot, dRoot])),
                    ce._I,
                ]);
            return ce.mul([
                ce.number([nFactor, dFactor]),
                ce.sqrt(ce.number([nRoot, dRoot])),
            ]);
        }
    }
    return undefined;
}
function rootExp(exponent) {
    if (typeof exponent.numericValue === 'number') {
        const inv = 1 / exponent.numericValue;
        if (Number.isInteger(inv))
            return inv;
        return null;
    }
    if (exponent.numericValue instanceof Decimal) {
        const inv = exponent.engine._BIGNUM_ONE.div(exponent.numericValue);
        if (inv.isInt())
            return inv.toNumber();
        return null;
    }
    if (!isRational(exponent.numericValue))
        return null;
    const [n, d] = [
        machineNumerator(exponent.numericValue),
        machineDenominator(exponent.numericValue),
    ];
    if (n !== 1 && n !== -1)
        return null;
    return n * d;
}

/** The canonical form of `Multiply`:
 * - remove `1`
 * - combine literal integers and rationals
 * - any arg is literal 0 -> return 0
 * - combine terms with same base
 *    `a a^3` -> `a^4`
 * - simplify the signs:
 *    - i.e. `-y \times -x` -> `x \times y`
 *    - `2 \times -x` -> `-2 \times x`
 *
 * The ops must be canonical, the result is canonical.
 */
function canonicalMultiply(ce, ops) {
    console.assert(ops.every((x) => x.isCanonical));
    if (ops.length === 0)
        return ce.number(1);
    if (ops.length === 1)
        return ops[0];
    if (ops.length === 2)
        return multiply2(ops[0], ops[1]);
    const product = new Product(ce);
    for (const op of ops) {
        if (op.isNaN || op.symbol === 'Undefined')
            return ce._NAN;
        product.addTerm(op);
    }
    return product.asExpression();
}
function simplifyMultiply(ce, ops) {
    console.assert(ops.every((x) => x.head !== 'Multiply'));
    const product = new Product(ce);
    for (let op of ops) {
        op = op.simplify();
        if (op.isNaN || op.symbol === 'Undefined')
            return ce._NAN;
        product.addTerm(op);
    }
    return product.asExpression();
}
function evalMultiply(ce, ops, mode = 'evaluate') {
    console.assert(ops.length > 1, 'evalMultiply(): no arguments');
    //
    // @fastpath
    //
    if (mode === 'N') {
        ops = ops.map((x) => x.N());
        if (ce.numericMode === 'machine' &&
            ops.every((x) => typeof x.numericValue === 'number')) {
            let prod = 1;
            for (const op of ops)
                prod *= op.numericValue;
            return ce.number(prod);
        }
    }
    //
    // First pass: looking for early exits
    //
    for (const op of ops) {
        if (op.isNaN || op.symbol === 'Undefined')
            return ce._NAN;
        if (!op.isExact)
            mode = 'N';
    }
    console.assert(ops.every((x) => x.head !== 'Multiply'));
    if (mode === 'N')
        ops = ops.map((x) => x.N());
    else
        ops = ops.map((x) => x.evaluate());
    //
    // Second pass
    //
    return new Product(ce, ops).asExpression(mode);
}
/**
 * Multiply op1 by op2. Distribute if one of the argument is a small integer
 * and the other is an addition.
 *
 * The result is canonical
 *
 * @todo: check if op1 or op2 (or both) are 'Divide' or `Power(_, -1)`
 *
 */
function multiply2(op1, op2, metadata) {
    console.assert(op1.isCanonical);
    console.assert(op2.isCanonical);
    const ce = op1.engine;
    if (op1.numericValue !== null &&
        op2.numericValue !== null &&
        op1.isInteger &&
        op2.isInteger) {
        return (apply2N(op1, op2, (a, b) => a * b, (a, b) => a.mul(b)) ?? ce._NAN);
    }
    if (op1.isNaN ||
        op2.isNaN ||
        op1.symbol === 'Undefined' ||
        op2.symbol === 'Undefined')
        return ce._NAN;
    if (op1.isNothing)
        return op2;
    if (op2.isNothing)
        return op1;
    if (op1.numericValue !== null) {
        if (op1.isOne)
            return op2;
        if (op1.isNegativeOne)
            return canonicalNegate(op2);
    }
    if (op2.numericValue !== null) {
        if (op2.isOne)
            return op1;
        if (op2.isNegativeOne)
            return canonicalNegate(op1);
    }
    let sign = 1;
    let [t, c] = op1.numericValue !== null ? [op1, op2] : [op2, op1];
    console.assert(t.head !== 'Subtract');
    if (t.head === 'Negate') {
        t = t.op1;
        sign = -sign;
    }
    if (c.numericValue !== null) {
        const r = asRational(c);
        if (r) {
            if (isRationalOne(r))
                return t;
            if (isRationalZero(r))
                return ce._ZERO;
            if (t.head === 'Add') {
                if (sign < 0)
                    c = canonicalNegate(c);
                return ce.add(t.ops.map((x) => multiply2(c, x)), metadata);
            }
            const tr = asRational(t);
            if (tr) {
                const p = mul(r, tr);
                return ce.number(sign < 0 ? neg(p) : p, { metadata });
            }
            if (sign < 0)
                return ce._fn('Multiply', [canonicalNegate(c), t], metadata);
            return ce._fn('Multiply', [c, t], metadata);
        }
    }
    if (c.hash === t.hash && c.isSame(t))
        return square(ce, c);
    const product = new Product(ce, [c, t]);
    if (sign > 0)
        return product.asExpression();
    return canonicalNegate(product.asExpression(), metadata);
}
// Canonical form of `["Product"]` (`\prod`) expressions.
function canonicalMultiplication(ce, body, range) {
    body ?? (body = ce.error(['missing', 'Function'])); // @todo not exactly a function, more like a 'NumericExpression'
    let index = null;
    let lower = null;
    let upper = null;
    if (range &&
        range.head !== 'Tuple' &&
        range.head !== 'Triple' &&
        range.head !== 'Pair' &&
        range.head !== 'Single') {
        index = range;
    }
    else if (range) {
        // Don't canonicalize the index. Canonicalization as the
        // side effect of declaring the symbol, here we're using
        // it to do a local declaration
        index = range.ops?.[0] ?? null;
        lower = range.ops?.[1]?.canonical ?? null;
        upper = range.ops?.[2]?.canonical ?? null;
    }
    // The index, if present, should be a symbol
    if (index && index.head === 'Hold')
        index = index.op1;
    if (index && index.head === 'ReleaseHold')
        index = index.op1.evaluate();
    index ?? (index = ce.symbol('Nothing'));
    if (!index.symbol)
        index = ce.error(['incompatible-domain', 'Symbol', index.domain]);
    else
        index = ce.hold(index);
    // The range bounds, if present, should be Real numbers
    if (lower)
        lower = validateArgument(ce, lower, 'ExtendedRealNumber');
    if (upper)
        lower = validateArgument(ce, upper, 'ExtendedRealNumber');
    if (lower && upper)
        range = ce.tuple([index, lower, upper]);
    else if (upper)
        range = ce.tuple([index, lower ?? ce._NEGATIVE_INFINITY, upper]);
    else if (lower)
        range = ce.tuple([index, lower]);
    else
        range = index;
    return ce._fn('Product', [body, range]);
}
function evalMultiplication(ce, expr, range, mode) {
    if (expr.head !== 'Lambda')
        return undefined;
    const fn = expr.op1;
    let lower = 1;
    let upper = MAX_ITERATION;
    if (range.head === 'Tuple' ||
        range.head === 'Triple' ||
        range.head === 'Pair' ||
        range.head === 'Single') {
        lower = asSmallInteger(range.op2) ?? 1;
        upper = asSmallInteger(range.op3) ?? MAX_ITERATION;
    }
    if (lower >= upper || upper - lower >= MAX_SYMBOLIC_TERMS)
        return undefined;
    if (mode === 'evaluate' || mode === 'simplify') {
        const terms = [];
        for (let i = lower; i <= upper; i++) {
            const n = ce.number(i);
            terms.push(fn.subs({ _1: n, _: n }));
        }
        const product = ce.mul(terms);
        return mode === 'simplify' ? product.simplify() : product.evaluate();
    }
    let product = bignumPreferred(ce) ? [BigInt(1), BigInt(1)] : [1, 1];
    for (let i = lower; i <= upper; i++) {
        const n = ce.number(i);
        const r = fn.subs({ _1: n, _: n });
        const term = r.N();
        if (term.numericValue === null)
            return undefined;
        product = mul(product, term);
    }
    if (isMachineRational(product))
        return ce.number(product[0] / product[1]);
    return ce.number(ce.bignum(product[0]).div(ce.bignum(product[1])));
}

/**
 * Canonical form of 'Divide' (and 'Rational')
 * - remove denominator of 1
 * - simplify the signs
 * - factor out negate (make the numerator and denominator positive)
 * - if numerator and denominator are integer literals, return a rational number
 *   or Rational experssion
 * - if Divide, transform into Multiply/Power
 */
function canonicalDivide(ce, op1, op2) {
    if (!op1.isValid || !op2.isValid)
        return ce._fn('Divide', [op1, op2]);
    if (op1.head === 'Negate' && op2.head === 'Negate') {
        op1 = op1.op1;
        op2 = op2.op1;
    }
    if (op1.numericValue !== null && op2.numericValue !== null) {
        if (op2.isOne)
            return op1;
        if (op2.isNegativeOne)
            return ce.neg(op1);
        if (op1.isOne)
            return ce.inv(op2);
        if (op1.isNegativeOne)
            return ce.neg(ce.inv(op2));
        const r1 = asRational(op1);
        const r2 = asRational(op2);
        if (r1 && r2 && !isRationalZero(r2))
            return ce.number(mul(r1, inverse(r2)));
    }
    if ((op1.head === 'Divide' || op1.head === 'Rational') &&
        (op2.head === 'Divide' || op2.head === 'Rational')) {
        return canonicalDivide(ce, ce.mul([op1.op1, op2.op2]), ce.mul([op1.op2, op2.op1]));
    }
    const num1 = op1.numericValue;
    if (num1 !== null) {
        if (isMachineRational(num1)) {
            const [a, b] = num1;
            return canonicalDivide(ce, ce.mul([ce.number(a), op2]), ce.number(b));
        }
        if (isBigRational(num1)) {
            const [a, b] = num1;
            return canonicalDivide(ce, ce.mul([ce.number(a), op2]), ce.number(b));
        }
    }
    const num2 = op2.numericValue;
    if (num2 !== null) {
        if (isMachineRational(num2)) {
            const [a, b] = num2;
            return canonicalDivide(ce, ce.mul([op1, ce.number(b)]), ce.number(a));
        }
        if (isBigRational(num2)) {
            const [a, b] = num2;
            return canonicalDivide(ce, ce.mul([op1, ce.number(b)]), ce.number(a));
        }
    }
    if (op1.head === 'Divide' || op1.head === 'Rational')
        return canonicalDivide(ce, ce.mul([op1.op1, op2]), op1.op2);
    if (op2.head === 'Divide' || op2.head === 'Rational')
        return canonicalDivide(ce, ce.mul([op1, op2.op2]), op2.op1);
    const [c1, t1] = asCoefficient(op1);
    const [c2, t2] = asCoefficient(op2);
    if (!isRationalOne(c1) || !isRationalOne(c2))
        return ce.mul([ce.number(mul(c1, inverse(c2))), ce.div(t1, t2)]);
    // eslint-disable-next-line prefer-const
    let [nSign, n] = makePositive(op1);
    // eslint-disable-next-line prefer-const
    let [dSign, d] = makePositive(op2);
    n = n.canonical;
    d = d.canonical;
    if (d.numericValue !== null && d.isOne)
        return nSign * dSign < 0 ? canonicalNegate(n) : n;
    if (nSign * dSign > 0)
        return ce._fn('Divide', [n, d]);
    if (n.numericValue)
        return ce._fn('Divide', [canonicalNegate(n), d]);
    return canonicalNegate(ce._fn('Divide', [n, d]));
}
/**
 * Simplify form of 'Divide' (and 'Rational')
 */
function simplifyDivide(ce, op1, op2) {
    if (op1.numericValue !== null && op2.numericValue !== null) {
        const r1 = asRational(op1);
        const r2 = asRational(op2);
        if (r1 && r2 && !isRationalZero(r2))
            return ce.number(mul(r1, inverse(r2)));
    }
    const [c1, t1] = asCoefficient(op1);
    const [c2, t2] = asCoefficient(op2);
    if (!isRationalOne(c1) || !isRationalOne(c2))
        return ce.mul([ce.number(mul(c1, inverse(c2))), ce.div(t1, t2)]);
    return new Product(ce, [op1, ce.inv(op2)]).asExpression();
}

// @todo Future additions to the dictionary
// Re: real part
// Im: imaginary part
// Arg: argument (phase angle in radians)
// Conjugate: complex conjugate
// complex-cartesian (constructor)
// complex-polar
// LogOnePlus: { domain: 'Number' },
// mod (modulo). See https://numerics.diploid.ca/floating-point-part-4.html,
// regarding 'remainder' and 'truncatingRemainder'
// Lcm
// Gcd
// Sum
// Product
// Numerator
// Denominator
// Rationalize: convert an approximate number to a nearby rational
// Mod: modulo
// Boole
// # Prime Numbers:
// Prime: gives the nth prime number
// NextPrime: the smallest prime larger than `n`
// PrimeFactors
// Divisors
// # Combinatorials
// Binomial
// Fibonacci
const ARITHMETIC_LIBRARY = [
    {
        //
        // Functions
        //
        Abs: {
            wikidata: 'Q3317982',
            threadable: true,
            idempotent: true,
            complexity: 1200,
            signature: {
                domain: ['Function', 'Number', 'NonNegativeNumber'],
                simplify: (ce, ops) => processAbs(ce, ops[0], 'simplify'),
                evaluate: (ce, ops) => processAbs(ce, ops[0], 'evaluate'),
                N: (ce, ops) => processAbs(ce, ops[0], 'N'),
            },
        },
        Add: {
            wikidata: 'Q32043',
            associative: true,
            commutative: true,
            threadable: true,
            idempotent: true,
            complexity: 1300,
            hold: 'all',
            signature: {
                domain: 'NumericFunction',
                codomain: (ce, args) => domainAdd(ce, args.map((x) => x.domain)),
                // canonical: (ce, args) => canonicalAdd(ce, args), // never called: shortpath
                simplify: (ce, ops) => simplifyAdd(ce, ops),
                evaluate: (ce, ops) => evalAdd(ce, ops),
                N: (ce, ops) => evalAdd(ce, ops, 'N'),
            },
        },
        Ceil: {
            description: 'Rounds a number up to the next largest integer',
            complexity: 1250,
            signature: {
                domain: ['Function', 'Number', 'Integer'],
                evaluate: (_ce, ops) => applyN(ops[0], Math.ceil, (x) => x.ceil(), (z) => z.ceil(0)),
            },
        },
        Chop: {
            associative: true,
            threadable: true,
            idempotent: true,
            complexity: 1200,
            signature: {
                domain: ['Function', 'Number', 'Number'],
                evaluate: (ce, ops) => applyN(ops[0], (x) => ce.chop(x), (x) => ce.chop(x), (x) => ce.chop(x)),
            },
        },
        Complex: {
            // This function is converted during boxing, so unlikely to encounter
            wikidata: 'Q11567',
            complexity: 500,
        },
        Divide: {
            wikidata: 'Q1226939',
            complexity: 2500,
            // - if numer product of numbers, or denom product of numbers,
            // i.e. √2x/2 -> 0.707x, 2/√2x -> 1.4142x
            signature: {
                domain: ['Function', 'Number', 'Number', 'Number'],
                canonical: (ce, args) => {
                    args = validateArguments(ce, canonical(flattenSequence(args)), [
                        'Number',
                        'Number',
                    ]);
                    if (args.length !== 2)
                        return ce._fn('Divide', args);
                    return ce.div(args[0], args[1]);
                },
                simplify: (ce, args) => simplifyDivide(ce, args[0], args[1]),
                evaluate: (ce, ops) => apply2N(ops[0], ops[1], (n, d) => n / d, (n, d) => n.div(d), (n, d) => n.div(d)),
            },
        },
        Exp: {
            wikidata: 'Q168698',
            threadable: true,
            complexity: 3500,
            // Exp(x) -> e^x
            signature: {
                domain: ['Function', 'Number', 'Number'],
                canonical: (ce, args) => {
                    args = validateArguments(ce, canonical(flattenSequence(args)), [
                        'Number',
                    ]);
                    if (args.length !== 1)
                        return ce._fn('Power', args);
                    return ce.pow(ce.symbol('ExponentialE'), args[0]);
                },
            },
        },
        Erf: {
            description: 'Complementary Error Function',
            complexity: 7500,
        },
        Erfc: {
            description: 'Complementary Error Function',
            complexity: 7500,
        },
        Factorial: {
            description: 'The factorial function',
            wikidata: 'Q120976',
            complexity: 9000,
            signature: {
                domain: ['Function', 'Number', 'Number'],
                evaluate: (ce, ops) => {
                    const n = asSmallInteger(ops[0]);
                    if (n !== null && n >= 0) {
                        if (!bignumPreferred(ce))
                            return ce.number(factorial$1(n));
                        return ce.number(factorial(ce, ce.bignum(n)));
                    }
                    const num = ops[0].numericValue;
                    if (num !== null && num instanceof Complex)
                        return ce.number(gamma(num.add(1)));
                    const f = asFloat(ops[0]);
                    if (f !== null)
                        return ce.number(gamma$2(1 + f));
                    return undefined;
                },
            },
        },
        Floor: {
            wikidata: 'Q56860783',
            complexity: 1250,
            signature: {
                domain: ['Function', 'Number', 'ExtendedRealNumber'],
                evaluate: (ce, ops) => applyN(ops[0], Math.floor, (x) => x.floor(), (z) => z.floor(0)),
            },
        },
        Gamma: {
            wikidata: 'Q190573',
            complexity: 8000,
            signature: {
                domain: ['Function', 'Number', 'Number', 'Number'],
                N: (ce, ops) => applyN(ops[0], (x) => gamma$2(x), (x) => gamma$1(ce, x), (x) => gamma(x)),
            },
        },
        LogGamma: {
            complexity: 8000,
            signature: {
                domain: ['Function', 'Number', 'Number', 'Number'],
                N: (ce, ops) => applyN(ops[0], (x) => lngamma$2(x), (x) => lngamma$1(ce, x), (x) => lngamma(x)),
            },
        },
        Ln: {
            description: 'Natural Logarithm',
            wikidata: 'Q204037',
            complexity: 4000,
            signature: {
                domain: ['Function', 'Number', 'Number'],
                N: (ce, ops) => applyN(ops[0], (x) => (x >= 0 ? Math.log(x) : ce.complex(x).log()), (x) => (!x.isNeg() ? x.ln() : ce.complex(x.toNumber()).log()), (z) => z.log()),
            },
        },
        Log: {
            description: 'Log(z, b = 10) = Logarithm of base b',
            wikidata: 'Q11197',
            complexity: 4100,
            signature: {
                domain: ['Function', 'Number', ['Maybe', 'Number'], 'Number'],
                canonical: (ce, ops) => {
                    ops = canonical(flattenSequence(ops));
                    if (ops.length === 1)
                        return ce._fn('Log', [validateArgument(ce, ops[0], 'Number')]);
                    if (ops.length === 2) {
                        const arg = validateArgument(ce, ops[0], 'Number');
                        const base = validateArgument(ce, ops[1], 'Number');
                        if (base.numericValue === 10)
                            return ce._fn('Log', [arg]);
                        return ce._fn('Log', [arg, base]);
                    }
                    return ce._fn('Log', validateArgumentCount(ce, ops, 2));
                },
                N: (ce, ops) => {
                    if (ops[1] === undefined)
                        return applyN(ops[0], (x) => x >= 0 ? Math.log10(x) : ce.complex(x).log().div(Math.LN10), (x) => !x.isNeg()
                            ? Decimal.log10(x)
                            : ce.complex(x.toNumber()).log().div(Math.LN10), (z) => z.log().div(Math.LN10));
                    return apply2N(ops[0], ops[1], (a, b) => Math.log(a) / Math.log(b), (a, b) => a.log(b), (a, b) => a.log().div(typeof b === 'number' ? Math.log(b) : b.log()));
                },
            },
        },
        Lb: {
            description: 'Base-2 Logarithm',
            wikidata: 'Q581168',
            complexity: 4100,
            signature: {
                domain: ['Function', 'Number', 'Number'],
                N: (ce, ops) => applyN(ops[0], (x) => (x >= 0 ? Math.log2(x) : ce.complex(x).log().div(Math.LN2)), (x) => x.isNeg()
                    ? Decimal.log10(x)
                    : ce.complex(x.toNumber()).log().div(Math.LN2), (z) => z.log().div(Math.LN2)),
            },
        },
        Lg: {
            description: 'Base-10 Logarithm',
            wikidata: 'Q966582',
            complexity: 4100,
            signature: {
                domain: ['Function', 'Number', 'Number'],
                N: (ce, ops) => applyN(ops[0], (x) => x >= 0 ? Math.log10(x) : ce.complex(x).log().div(Math.LN10), (x) => !x.isNeg()
                    ? Decimal.log10(x)
                    : ce.complex(x.toNumber()).log().div(Math.LN10), (z) => z.log().div(Math.LN10)),
            },
        },
        Max: {
            description: 'Maximum of two or more numbers',
            complexity: 1200,
            signature: {
                domain: ['Function', ['Sequence', 'Number'], 'Number'],
                simplify: (ce, ops) => {
                    if (ops.length === 0)
                        return ce._NEGATIVE_INFINITY;
                    if (ops.length === 1)
                        return ops[0];
                    return ce.box(['Max', ...ops]);
                },
                evaluate: (ce, ops) => {
                    if (ops.length === 0)
                        return ce._NEGATIVE_INFINITY;
                    let result = undefined;
                    const rest = [];
                    for (const op of ops) {
                        if (!op.isNumber || op.numericValue === undefined)
                            rest.push(op);
                        else if (!result || op.isGreater(result))
                            result = op;
                    }
                    if (rest.length > 0)
                        return ce.box(result ? ['Max', result, ...rest] : ['Max', ...rest]);
                    return result ?? ce._NAN;
                },
            },
        },
        Min: {
            description: 'Minimum of two or more numbers',
            complexity: 1200,
            signature: {
                domain: ['Function', ['Sequence', 'Number'], 'Number'],
                simplify: (ce, ops) => {
                    if (ops.length === 0)
                        return ce._NEGATIVE_INFINITY;
                    if (ops.length === 1)
                        return ops[0];
                    return ce.box(['Min', ...ops]);
                },
                evaluate: (ce, ops) => {
                    if (ops.length === 0)
                        return ce._NEGATIVE_INFINITY;
                    let result = undefined;
                    const rest = [];
                    for (const op of ops) {
                        if (!op.isNumber || op.numericValue === undefined)
                            rest.push(op);
                        else if (!result || op.isLess(result))
                            result = op;
                    }
                    if (rest.length > 0)
                        return ce.box(result ? ['Min', result, ...rest] : ['Min', ...rest]);
                    return result ?? ce._NAN;
                },
            },
        },
        Multiply: {
            wikidata: 'Q40276',
            associative: true,
            commutative: true,
            idempotent: true,
            complexity: 2100,
            hold: 'all',
            signature: {
                domain: 'NumericFunction',
                // Never called: fastpath
                // canonical: (ce, args) => {
                //   return canonicalMultiply(ce, args);
                // },
                simplify: (ce, ops) => simplifyMultiply(ce, ops),
                evaluate: (ce, ops) => evalMultiply(ce, ops),
                N: (ce, ops) => evalMultiply(ce, ops, 'N'),
            },
        },
        Negate: {
            description: 'Additive Inverse',
            wikidata: 'Q715358',
            complexity: 2000,
            signature: {
                domain: ['Function', 'Number', 'Number'],
                codomain: (ce, args) => {
                    const arg = args[0].domain;
                    if (!arg.literal)
                        return arg;
                    const negDomain = {
                        PositiveNumber: 'NegativeNumber',
                        NonNegativeNumber: 'NonPositiveNumber',
                        NonPositiveNumber: 'NonNegativeNumber',
                        NegativeNumber: 'PositiveNumber',
                        PositiveInteger: 'NegativeInteger',
                        NonNegativeInteger: 'NonPositiveInteger',
                        NonPositiveInteger: 'NonNegativeInteger',
                        NegativeInteger: 'PositiveInteger',
                    }[arg.literal];
                    if (negDomain)
                        return ce.domain(negDomain);
                    return arg;
                },
                canonical: (ce, args) => {
                    args = validateArguments(ce, canonical(flattenSequence(args)), [
                        'Number',
                    ]);
                    if (args.length !== 1)
                        return ce._fn('Negate', args);
                    return canonicalNegate(args[0]);
                },
                simplify: (ce, ops) => processNegate(ce, ops[0], 'simplify'),
                evaluate: (ce, ops) => processNegate(ce, ops[0], 'evaluate'),
                N: (ce, ops) => processNegate(ce, ops[0], 'N'),
                sgn: (_ce, args) => {
                    const s = args[0].sgn;
                    if (s === undefined || s === null)
                        return undefined;
                    if (s === 0)
                        return 0;
                    if (s > 0)
                        return -1;
                    if (s < 0)
                        return +1;
                    return undefined;
                },
            },
        },
        Power: {
            wikidata: 'Q33456',
            commutative: false,
            complexity: 3500,
            signature: {
                domain: ['Function', 'Number', 'Number', 'Number'],
                canonical: (ce, args) => {
                    args = validateArguments(ce, canonical(flattenSequence(args)), [
                        'Number',
                        'Number',
                    ]);
                    if (args.length !== 2)
                        return ce._fn('Power', args);
                    return ce.pow(args[0], args[1]);
                },
                simplify: (ce, ops) => processPower(ce, ops[0], ops[1], 'simplify'),
                evaluate: (ce, ops) => processPower(ce, ops[0], ops[1], 'evaluate'),
                N: (ce, ops) => {
                    // @fastpath
                    if (ce.numericMode === 'machine' &&
                        typeof ops[0].numericValue === 'number' &&
                        typeof ops[1].numericValue === 'number')
                        return ce.number(Math.pow(ops[0].numericValue, ops[1].numericValue));
                    return processPower(ce, ops[0], ops[1], 'N');
                },
                // Defined as RealNumber for all power in RealNumber when base > 0;
                // when x < 0, only defined if n is an integer
                // if x is a non-zero complex, defined as ComplexNumber
                // Square root of a prime is irrational (AlgebraicNumber)
                // https://proofwiki.org/wiki/Square_Root_of_Prime_is_Irrational
                // evalDomain: (ce, base: BoxedExpression, power: BoxedExpression) ;
            },
        },
        Product: {
            wikidata: 'Q901718',
            complexity: 1000,
            hold: 'first',
            signature: {
                domain: [
                    'Function',
                    'Anything',
                    // [
                    //   'Maybe',
                    'Tuple',
                    // ['Tuple', 'Symbol', ['Maybe', 'Integer'], ['Maybe', 'Integer']],
                    // ],
                    'Number',
                ],
                // codomain: (ce, args) => domainAdd(ce, args),
                // The 'body' and 'range' need to be interpreted by canonicalMultiplication(). Don't canonicalize them yet.
                canonical: (ce, ops) => canonicalMultiplication(ce, ops[0], ops[1]),
                simplify: (ce, ops) => evalMultiplication(ce, ops[0], ops[1], 'simplify'),
                evaluate: (ce, ops) => evalMultiplication(ce, ops[0], ops[1], 'evaluate'),
                N: (ce, ops) => evalMultiplication(ce, ops[0], ops[1], 'N'),
            },
        },
        Rational: {
            complexity: 2400,
            signature: {
                domain: ['Function', 'Number', ['Maybe', 'Number'], 'RationalNumber'],
                canonical: (ce, args) => {
                    args = canonical(flattenSequence(args));
                    if (args.length === 0)
                        return ce._fn('Rational', [ce.error(['missing', 'Number'])]);
                    if (args.length === 1)
                        return ce._fn('Rational', [
                            validateArgument(ce, args[0], 'ExtendedRealNumber'),
                        ]);
                    args = validateArguments(ce, args, ['Integer', 'Integer']);
                    if (args.length !== 2)
                        return ce._fn('Rational', args);
                    return ce.div(args[0], args[1]);
                },
                simplify: (ce, ops) => {
                    if (ops.length !== 2)
                        return undefined;
                    return simplifyDivide(ce, ops[0], ops[1]);
                },
                evaluate: (ce, ops) => {
                    if (ops.length === 2) {
                        const [n, d] = [asSmallInteger(ops[0]), asSmallInteger(ops[1])];
                        if (n !== null && d !== null)
                            return ce.number([n, d]);
                        return undefined;
                    }
                    //
                    // If there is a single argument, i.e. `['Rational', 'Pi']`
                    // the function evaluates to a rational expression of the argument
                    //
                    const f = asFloat(ops[0].N());
                    if (f === null)
                        return undefined;
                    return ce.number(rationalize(f));
                },
                N: (ce, ops) => {
                    if (ops.length === 1)
                        return ops[0];
                    return apply2N(ops[0], ops[1], (a, b) => a / b, (a, b) => a.div(b), (a, b) => a.div(b));
                },
            },
        },
        Root: {
            complexity: 3200,
            signature: {
                domain: ['Function', 'Number', 'Number', 'Number'],
                canonical: (ce, args) => {
                    args = canonical(flattenSequence(args));
                    if (args.length > 2)
                        return ce._fn('Root', validateArgumentCount(ce, args, 2));
                    const [base, exp] = [
                        validateArgument(ce, args[0], 'Number'),
                        validateArgument(ce, args[1], 'Number'),
                    ];
                    if (!exp.isValid || !base.isValid)
                        return ce._fn('Root', [base, exp]);
                    return ce.pow(base, ce.inv(exp));
                },
            },
        },
        Round: {
            complexity: 1250,
            signature: {
                domain: ['Function', 'Number', 'Number'],
                evaluate: (ce, ops) => applyN(ops[0], Math.round, (x) => x.round(), (x) => x.round(0)),
            },
        },
        Sign: {
            complexity: 1200,
            signature: {
                domain: ['Function', 'Number', ['Range', -1, 1]],
                simplify: (ce, ops) => {
                    const s = ops[0].sgn;
                    if (s === 0)
                        return ce._ZERO;
                    if (s === 1)
                        return ce._ONE;
                    if (s === -1)
                        return ce._NEGATIVE_ONE;
                    return undefined;
                },
                evaluate: (ce, ops) => {
                    const s = ops[0].sgn;
                    if (s === 0)
                        return ce._ZERO;
                    if (s === 1)
                        return ce._ONE;
                    if (s === -1)
                        return ce._NEGATIVE_ONE;
                    return undefined;
                },
                N: (ce, ops) => {
                    const s = ops[0].sgn;
                    if (s === 0)
                        return ce._ZERO;
                    if (s === 1)
                        return ce._ONE;
                    if (s === -1)
                        return ce._NEGATIVE_ONE;
                    return undefined;
                },
            },
        },
        SignGamma: {
            description: 'The sign of the gamma function: -1 or +1',
            complexity: 7900,
            // @todo
        },
        Sqrt: {
            description: 'Square Root',
            wikidata: 'Q134237',
            complexity: 3000,
            signature: {
                domain: ['Function', 'Number', 'Number'],
                canonical: (ce, args) => {
                    args = canonical(flattenSequence(args));
                    if (args.length !== 1)
                        return ce._fn('Sqrt', args);
                    return ce.pow(args[0], ce._HALF);
                },
                simplify: (ce, ops) => processSqrt(ce, ops[0], 'simplify'),
                evaluate: (ce, ops) => processSqrt(ce, ops[0], 'evaluate'),
                N: (ce, ops) => processSqrt(ce, ops[0], 'N'),
                // evalDomain: Square root of a prime is irrational
                // https://proofwiki.org/wiki/Square_Root_of_Prime_is_Irrational
            },
        },
        Square: {
            wikidata: 'Q3075175',
            complexity: 3100,
            signature: {
                domain: ['Function', 'Number', 'Number'],
                canonical: (ce, args) => {
                    args = canonical(flattenSequence(args));
                    if (args.length !== 1)
                        return ce._fn('Square', args);
                    return ce.pow(args[0], ce.number(2));
                },
            },
        },
        Subtract: {
            wikidata: 'Q40754',
            complexity: 1350,
            signature: {
                domain: ['Function', 'Number', ['Maybe', 'Number'], 'Number'],
                canonical: (ce, args) => {
                    // Not necessarily legal, but probably what was intended:
                    // ['Subtract', 'x'] -> ['Negate', 'x']
                    args = canonical(flattenSequence(args));
                    if (args.length === 1)
                        return canonicalNegate(args[0]);
                    args = validateArgumentCount(ce, args, 2);
                    if (args.length !== 2)
                        return ce._fn('Subtract', args);
                    if (!args.every((x) => x.isValid))
                        return ce._fn('Subtract', args);
                    return ce.add([args[0], canonicalNegate(args[1])]);
                },
            },
        },
        Sum: {
            wikidata: 'Q218005',
            complexity: 1000,
            hold: 'all',
            signature: {
                domain: [
                    'Function',
                    'Anything',
                    // [
                    //   'Maybe',
                    'Tuple',
                    // ['Tuple', 'Symbol', ['Maybe', 'Integer'], ['Maybe', 'Integer']],
                    // ],
                    'Number',
                ],
                canonical: (ce, ops) => canonicalSummation(ce, ops[0], ops[1]),
                simplify: (ce, ops) => evalSummation(ce, ops[0], ops[1], 'simplify'),
                evaluate: (ce, ops) => evalSummation(ce, ops[0], ops[1], 'evaluate'),
                N: (ce, ops) => evalSummation(ce, ops[0], ops[1], 'N'),
            },
        },
    },
    {
        //
        // Constants
        // Note: constants are put in a separate, subsequent, dictionary because
        // some of the values (CatalanConstant) reference some function names (Add...)
        // that are defined above. This avoid circular references.
        //
        e: {
            domain: 'TranscendentalNumber',
            constant: true,
            holdUntil: 'never',
            value: 'ExponentialE',
        },
        i: {
            domain: 'ImaginaryNumber',
            constant: true,
            holdUntil: 'never',
            flags: { imaginary: true },
            value: 'ImaginaryUnit',
        },
        MachineEpsilon: {
            /**
             * The difference between 1 and the next larger floating point number
             *
             *    2^{−52}
             *
             * See https://en.wikipedia.org/wiki/Machine_epsilon
             */
            domain: 'RealNumber',
            holdUntil: 'N',
            constant: true,
            flags: { real: true },
            value: { num: Number.EPSILON.toString() },
        },
        Half: {
            constant: true,
            holdUntil: 'never',
            value: ['Rational', 1, 2],
        },
        ImaginaryUnit: {
            domain: 'ImaginaryNumber',
            constant: true,
            holdUntil: 'evaluate',
            wikidata: 'Q193796',
            flags: { imaginary: true },
            value: ['Complex', 0, 1],
        },
        ExponentialE: {
            domain: 'TranscendentalNumber',
            flags: { algebraic: false, real: true },
            wikidata: 'Q82435',
            constant: true,
            holdUntil: 'N',
            value: (engine) => bignumPreferred(engine) ? engine._BIGNUM_ONE.exp() : Math.exp(1),
        },
        GoldenRatio: {
            domain: 'AlgebraicNumber',
            wikidata: 'Q41690',
            constant: true,
            flags: { algebraic: true },
            holdUntil: 'simplify',
            value: ['Divide', ['Add', 1, ['Sqrt', 5]], 2],
        },
        CatalanConstant: {
            domain: 'RealNumber',
            flags: { algebraic: undefined },
            wikidata: 'Q855282',
            constant: true,
            holdUntil: 'N',
            value: {
                // From http://www.fullbooks.com/Miscellaneous-Mathematical-Constants1.html
                num: `0.91596559417721901505460351493238411077414937428167
                  21342664981196217630197762547694793565129261151062
                  48574422619196199579035898803325859059431594737481
                  15840699533202877331946051903872747816408786590902
                  47064841521630002287276409423882599577415088163974
                  70252482011560707644883807873370489900864775113225
                  99713434074854075532307685653357680958352602193823
                  23950800720680355761048235733942319149829836189977
                  06903640418086217941101917532743149978233976105512
                  24779530324875371878665828082360570225594194818097
                  53509711315712615804242723636439850017382875977976
                  53068370092980873887495610893659771940968726844441
                  66804621624339864838916280448281506273022742073884
                  31172218272190472255870531908685735423498539498309
                  91911596738846450861515249962423704374517773723517
                  75440708538464401321748392999947572446199754961975
                  87064007474870701490937678873045869979860644874974
                  64387206238513712392736304998503539223928787979063
                  36440323547845358519277777872709060830319943013323
                  16712476158709792455479119092126201854803963934243
                  `,
            },
        },
        EulerGamma: {
            // From http://www.fullbooks.com/Miscellaneous-Mathematical-Constants2.html
            domain: 'RealNumber',
            flags: { algebraic: undefined },
            wikidata: 'Q273023',
            holdUntil: 'N',
            constant: true,
            value: {
                num: `0.57721566490153286060651209008240243104215933593992359880576723488486772677766
          467093694706329174674951463144724980708248096050401448654283622417399764492353
          625350033374293733773767394279259525824709491600873520394816567085323315177661
          152862119950150798479374508570574002992135478614669402960432542151905877553526
          733139925401296742051375413954911168510280798423487758720503843109399736137255
          306088933126760017247953783675927135157722610273492913940798430103417771778088
          154957066107501016191663340152278935867965497252036212879226555953669628176388
          792726801324310104765059637039473949576389065729679296010090151251959509222435
          014093498712282479497471956469763185066761290638110518241974448678363808617494
          551698927923018773910729457815543160050021828440960537724342032854783670151773
          943987003023703395183286900015581939880427074115422278197165230110735658339673`,
            },
        },
    },
    {
        PreIncrement: {
            signature: { domain: ['Function', 'Number', 'Number'] },
        },
        PreDecrement: {
            signature: { domain: ['Function', 'Number', 'Number'] },
        },
    },
];
function processAbs(ce, arg, mode) {
    if (mode !== 'simplify') {
        const num = arg.numericValue;
        if (num !== null) {
            if (typeof num === 'number')
                return ce.number(Math.abs(num));
            if (num instanceof Decimal)
                return ce.number(num.abs());
            if (num instanceof Complex)
                return ce.number(num.abs());
            if (isMachineRational(num))
                return ce.number(mode === 'N' ? Math.abs(num[0] / num[1]) : [Math.abs(num[0]), num[1]]);
            if (isBigRational(num)) {
                const [n, d] = num;
                return ce.number(mode === 'N'
                    ? ce.bignum(n).div(ce.bignum(d)).abs()
                    : [n > 0 ? n : -n, d]);
            }
        }
    }
    if (arg.isNonNegative)
        return arg;
    if (arg.isNegative)
        return ce.neg(arg);
    return undefined;
}

const CALCULUS_LIBRARY = [
    {
        //
        // Functions
        //
        Integrate: {
            wikidata: 'Q80091',
            hold: 'all',
            signature: {
                domain: [
                    'Function',
                    'Anything',
                    ['Union', 'Nothing', 'Tuple', 'Symbol'],
                    // ['Tuple', 'Symbol', ['Maybe', 'Integer'], ['Maybe', 'Integer']],
                    'Number',
                ],
                canonical: (ce, ops) => {
                    const body = ops[0] ?? ce.error(['missing', 'Function']); // @todo not exactly a function, more like a 'NumericExpression'
                    let range = ops[1];
                    let index = null;
                    let lower = null;
                    let upper = null;
                    if (range &&
                        range.head !== 'Tuple' &&
                        range.head !== 'Triple' &&
                        range.head !== 'Pair' &&
                        range.head !== 'Single') {
                        index = range;
                    }
                    else if (range) {
                        // Don't canonicalize the index. Canonicalization as the
                        // side effect of declaring the symbol, here we're using
                        // it to do a local declaration
                        index = range.ops?.[0] ?? null;
                        lower = range.ops?.[1]?.canonical ?? null;
                        upper = range.ops?.[2]?.canonical ?? null;
                    }
                    // The index, if present, should be a symbol
                    if (index && index.head === 'Hold')
                        index = index.op1;
                    if (index && index.head === 'ReleaseHold')
                        index = index.op1.evaluate();
                    index ?? (index = ce.symbol('Nothing'));
                    if (!index.symbol)
                        index = ce.error(['incompatible-domain', 'Symbol', index.domain]);
                    // The range bounds, if present, should be numbers
                    if (lower)
                        lower = validateArgument(ce, lower, 'Number');
                    if (upper)
                        upper = validateArgument(ce, upper, 'Number');
                    if (lower && upper)
                        range = ce.tuple([index, lower, upper]);
                    else if (upper)
                        range = ce.tuple([index, ce._NEGATIVE_INFINITY, upper]);
                    else if (lower)
                        range = ce.tuple([index, lower]);
                    else
                        range = index;
                    return ce._fn('Integrate', [body, range]);
                },
            },
        },
    },
];

const COLLECTIONS_LIBRARY = {
    Sequence: {
        signature: {
            domain: 'Function',
        },
    },
};
// Keys: { domain: 'Function' },
// Entries: { domain: 'Function' },
// Dictionary: { domain: 'Collection' },
// Dictionary: {
//   domain: 'Function',
//   range: 'Dictionary',
// },
// List: { domain: 'Collection' },
// Tuple: { domain: 'Collection' },
// Sequence: { domain: 'Collection' },
// Reverse
// ForEach / Apply
// Map
// ReduceRight
// ReduceLeft
// first    or head
// rest     or tail
// cons -> cons(first (element), rest (list)) = list
// append -> append(list, list) -> list
// reverse
// rotate
// in
// map   ⁡ map(2x, x, list) ( 2 ⁢ x | x ∈ [ 0 , 10 ] )
// such-that {x ∈ Z | x ≥ 0 ∧ x < 100 ∧ x 2 ∈ Z}
// select : picks out all elements ei of list for which crit[ei] is True.
// sort
// contains / find

function oneOf(xs) {
    return xs[Math.floor(Math.random() * xs.length)];
}
function randomExpressionWithHead(head, level) {
    if (head === 'Add' || head === 'Multiply') {
        const ops = [];
        let count = 1 + Math.floor(Math.random() * 12);
        while (count > 0) {
            ops.push(randomExpression(level + 1));
            count -= 1;
        }
        return [head, ...ops];
    }
    if (head === 'Divide' || head === 'Power') {
        return [head, randomExpression(level + 1), randomExpression(level + 1)];
    }
    if (head === 'Root') {
        return [head, randomExpression(level + 1), randomExpression(10)];
    }
    if (head === 'trig')
        return randomTrig();
    return [head, randomExpression(level + 1)];
}
function randomTrig() {
    return [
        oneOf([
            'Cos',
            'Sin',
            'Tan',
            'Sinh',
            'Arccos',
            'Arsinh',
            ['InverseFunction', 'Cos'],
        ]),
        oneOf([
            'Pi',
            '-1',
            '0',
            '1',
            ['Divide', 'Pi', -5],
            ['Multiply', -2, ['Divide', 'Pi', 11]],
            ['Multiply', 'Half', 'Pi'],
            ['Multiply', 5, 'Pi'],
            ['Multiply', 12, 'Pi'],
            ['Divide', 'Pi', 5],
            ['Divide', 'Pi', 9],
            ['Multiply', 5, ['Divide', 'Pi', 9]],
            ['Multiply', 2, ['Divide', 'Pi', 11]],
            ['Multiply', 2, ['Divide', 'Pi', 3]],
        ]),
    ];
}
function randomExpression(level) {
    level ?? (level = 1);
    if (level === 1) {
        const h = oneOf([
            'Add',
            'Add',
            'Add',
            'Add',
            'Add',
            'Multiply',
            'Multiply',
            'Multiply',
            'Multiply',
            'Divide',
            'Divide',
            'Divide',
            'Root',
            'Sqrt',
            'Subtract',
            'Negate',
            'trig',
        ]);
        return randomExpressionWithHead(h, 1);
    }
    if (level === 2) {
        if (Math.random() > 0.5)
            return randomExpression(3);
        if (Math.random() > 0.75)
            return randomExpression(1);
        const h = oneOf([
            'Multiply',
            'Multiply',
            'Add',
            'Power',
            'trig',
            'Ln',
            'Exp',
        ]);
        return randomExpressionWithHead(h, 2);
    }
    return oneOf([
        -0.000012345,
        -2,
        -2,
        -2,
        -3,
        -5,
        -6,
        -12,
        -1.654e-57,
        0,
        0,
        0.00012345,
        1.654e-57,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        5,
        5,
        6,
        6,
        1234.5678,
        5678.1234,
        10,
        15,
        18,
        30,
        60,
        1.234e57,
        '123456789.12345678912345e200',
        '987654321.12345678912345',
        ['Rational', -6, 10],
        ['Rational', -12, 15],
        ['Rational', -15, 12],
        ['Rational', 3, 5],
        ['Rational', 12, 15],
        ['Rational', 15, 12],
        'ExponentialE',
        'ImaginaryUnit',
        ['Sqrt', 3],
        ['Sqrt', 5],
        ['Sqrt', 15],
        ['Sqrt', 25],
        ['Complex', -1.1, 1.1],
        ['Complex', 4, 5],
        'x',
        'x',
        'x',
        'x',
        ['Add', 'x', 1],
        ['Divide', 'x', 3],
        ['Square', 'x'],
        ['Power', 'x', 3],
        ['Power', 'x', 4],
        ['Subtract', 'x', 1],
        ['Add', 'x', 1],
        'a',
        'b',
        'Pi',
    ]);
}

//   // := assign 80 // @todo
const CORE_LIBRARY = [
    {
        Nothing: { domain: 'Nothing' },
    },
    //
    // Data Structures
    //
    {
        List: {
            complexity: 8200,
            signature: {
                domain: ['Function', ['Maybe', ['Sequence', 'Anything']], 'List'],
            },
        },
        KeyValuePair: {
            description: 'A key/value pair',
            complexity: 8200,
            signature: {
                domain: [
                    'Function',
                    'String',
                    'Anything',
                    ['Tuple', 'String', 'Anything'],
                ],
                codomain: (ce, args) => ce.domain(['Tuple', 'String', args[1].domain]),
                canonical: (ce, args) => {
                    const key = validateArgument(ce, args[0]?.canonical, 'String');
                    const value = validateArgument(ce, args[1]?.canonical, 'Value');
                    return ce.tuple([key, value]);
                },
            },
        },
        Single: {
            description: 'A tuple with a single element',
            complexity: 8200,
            signature: {
                domain: ['Function', 'Anything', ['Tuple', 'Anything']],
                codomain: (ce, args) => ce.domain(['Tuple', args[0].domain]),
                canonical: (ce, ops) => ce.tuple(validateArgumentCount(ce, canonical(ops), 1)),
            },
        },
        Pair: {
            description: 'A tuple of two elements',
            complexity: 8200,
            signature: {
                domain: [
                    'Function',
                    'Anything',
                    'Anything',
                    ['Tuple', 'Anything', 'Anything'],
                ],
                codomain: (ce, args) => ce.domain(['Tuple', args[0].domain, args[1].domain]),
                canonical: (ce, ops) => ce.tuple(validateArgumentCount(ce, canonical(ops), 2)),
            },
        },
        Triple: {
            description: 'A tuple of three elements',
            complexity: 8200,
            signature: {
                domain: [
                    'Function',
                    'Anything',
                    'Anything',
                    'Anything',
                    ['Tuple', 'Anything', 'Anything', 'Anything'],
                ],
                codomain: (ce, args) => ce.domain(['Tuple', args[0].domain, args[1].domain, args[2].domain]),
                canonical: (ce, ops) => ce.tuple(validateArgumentCount(ce, canonical(ops), 3)),
            },
        },
        Tuple: {
            description: 'A fixed number of heterogeneous elements',
            complexity: 8200,
            signature: {
                domain: [
                    'Function',
                    ['Sequence', 'Anything'],
                    ['Tuple', ['Sequence', 'Anything']],
                ],
                canonical: (ce, ops) => ce.tuple(canonical(ops)),
                codomain: (ce, args) => ce.domain(['Tuple', ...args.map((x) => x.domain)]),
            },
        },
    },
    //
    // Inert functions
    //
    {
        BaseForm: {
            description: '`BaseForm(expr, base=10)`',
            complexity: 9000,
            inert: true,
            signature: {
                domain: ['Function', 'Value', ['Maybe', 'Integer'], 'Value'],
                codomain: (_ce, args) => args[0].domain,
            },
        },
        Delimiter: {
            // Use to represent groups of expressions. Named after https://en.wikipedia.org/wiki/Delimiter
            complexity: 9000,
            hold: 'first',
            signature: {
                domain: [
                    'Function',
                    'Anything',
                    ['Maybe', 'String'],
                    ['Maybe', 'String'],
                    'Anything',
                ],
                codomain: (_ce, args) => args[0].domain,
                canonical: (ce, args) => args[0]?.canonical ?? ce.box(['Sequence']),
            },
        },
        Error: {
            /**
             * - The first argument is either a string or an `["ErrorCode"]`
             * expression indicating the nature of the error.
             * - The second argument, if present, indicates the context/location
             * of the error. If the error occur while parsing a LaTeX string,
             * for example, the argument will be a `Latex` expression.
             */
            complexity: 500,
            signature: {
                domain: ['Function', 'Anything', ['Maybe', 'Anything'], 'Void'],
                // To make a canonical expression, don't canonicalize the args
                canonical: (ce, args) => ce._fn('Error', args),
            },
        },
        ErrorCode: {
            complexity: 500,
            hold: 'all',
            signature: {
                domain: [
                    'Function',
                    'String',
                    ['Maybe', ['Sequence', 'Anything']],
                    'Anything',
                ],
                canonical: (ce, args) => {
                    const code = validateArgument(ce, args[0], 'String').string;
                    if (code === 'incompatible-domain') {
                        return ce._fn('ErrorCode', [
                            ce.string(code),
                            ce.domain(args[1] ?? 'Anything'),
                            ce.domain(args[2] ?? 'Anything'),
                        ]);
                    }
                    return ce._fn('ErrorCode', args);
                },
            },
        },
        Hold: {
            hold: 'all',
            signature: {
                domain: 'Function',
                codomain: (ce, args) => args[0].symbol ? ce.domain('Symbol') : ce.domain('Anything'),
                // To make a canonical expression, don't canonicalize the args
                canonical: (ce, args) => args.length !== 1
                    ? ce._fn('Hold', validateArgumentCount(ce, args, 1))
                    : ce._fn('Hold', [validateArgument(ce, args[0], 'Anything')]),
            },
        },
        HorizontalSpacing: {
            signature: {
                domain: 'Function',
                canonical: (ce, args) => {
                    if (args.length === 2)
                        return args[0].canonical;
                    // Returning an empty `["Sequence"]` will make the expression be ignored
                    return ce.box(['Sequence']);
                },
            },
        },
        Style: {
            complexity: 9000,
            inert: true,
            signature: {
                domain: [
                    'Function',
                    'Anything',
                    ['Maybe', 'Dictionary'],
                    'Anything',
                ],
            },
            // @todo: simplify: merge Style(Style(x, s1), s2),  Style(x) -> x
        },
    },
    {
        Apply: {
            signature: {
                domain: 'Function',
                evaluate: (ce, ops) => apply$1(ops[0], ops.slice(1)),
            },
        },
        About: { signature: { domain: 'Function' } },
        Block: {
            /** Create a local scope. First argument is a dictionary of local variables.
             * They are evaluated in the context of the parent scope. The second argument
             * is an expression to be evaluated in the context of the new scope.
             * ["Block", ["List", ["Equal", "x", 1]], [...]]
             */
            signature: { domain: 'Function' },
        },
        Domain: {
            /** Return the domain of an expression */
            signature: {
                domain: ['Function', 'Anything', 'Domain'],
                canonical: (ce, ops) => ce.domain(validateArgumentCount(ce, canonical(ops), 1)[0]),
            },
        },
        Evaluate: {
            hold: 'all',
            signature: {
                domain: ['Function', 'Anything', 'Anything'],
                codomain: (_ce, args) => args[0].domain,
                canonical: (ce, ops) => ce._fn('Evaluate', validateArgumentCount(ce, canonical(ops), 1)),
                evaluate: (_ce, ops) => ops[0].evaluate(),
            },
        },
        Head: {
            signature: {
                domain: 'Function',
                evaluate: (ce, ops) => {
                    const op1 = ops[0];
                    if (typeof op1?.head === 'string')
                        return ce.symbol(op1.head);
                    return op1?.head ?? ce.symbol('Nothing');
                },
            },
        },
        Html: {
            signature: {
                domain: ['Function', 'Value', 'String'],
                evaluate: (ce, ops) => {
                    if (ops.length === 0)
                        return ce.string('');
                    // @todo if head(arg[0]) === 'LatexString', call MathLive renderToMarkup()
                    return ce.string('');
                },
            },
        },
        Lambda: {
            wikidata: 'Q567612',
            hold: 'all',
            signature: {
                domain: ['Function', 'Anything', 'Function'],
                codomain: (_ce, ops) => ops[0].domain,
                canonical: (ce, ops) => ce._fn('Lambda', validateArgumentCount(ce, ops, 1)),
            },
        },
        Signatures: {
            signature: {
                domain: ['Function', 'Symbol', ['Maybe', ['List', 'Domain']]],
                canonical: (ce, ops) => {
                    ops = validateArgumentCount(ce, ops, 1);
                    if (!ops[0].symbol)
                        return ce._fn('Signatures', [
                            ce.error(['incompatible-domain', 'Symbol', ops[0].domain], ops[0]),
                        ]);
                    return ce._fn('Signatures', ops);
                },
                evaluate: (ce, ops) => {
                    const name = ops[0].symbol;
                    if (!name)
                        return ce.symbol('Nothing');
                    const result = ce.lookupFunction(name);
                    if (!result)
                        return ce.symbol('Nothing');
                    return ce.fn('List', [result.signature.domain]);
                },
            },
        },
        Subscript: {
            /**
             * The `Subscript` function can take several forms:
             *
             * If `op1` is a string, the string is interpreted as a number in
             * base `op2` (2 to 36).
             *
             * If `op1` is an indexable collection, `x`:
             * - `x_*` -> `At(x, *)`
             *
             * Otherwise:
             * - `x_0` -> Symbol "x_0"
             * - `x_n` -> Symbol "x_n"
             * - `x_{\text{max}}` -> Symbol `x_max`
             * - `x_{(n+1)}` -> `At(x, n+1)`
             * - `x_{n+1}` ->  `Subscript(x, n+1)`
             */
            // The last (subscript) argument can include a delimiter that
            // needs to be interpreted. Without the hold, it would get
            // removed during canonicalization.
            hold: 'last',
            signature: {
                domain: ['Function', 'Anything', 'Anything', 'Anything'],
                codomain: (_ce, args) => {
                    if (args[0].isFunction)
                        return args[0].domain;
                    return args[0].domain;
                },
                canonical: (ce, args) => {
                    const op1 = args[0];
                    const op2 = args[1];
                    // Is it a string in a base form:
                    // `"deadbeef"_{16}` `"0101010"_2?
                    if (op1.string) {
                        const base = asSmallInteger(op2);
                        if (base !== null) {
                            if (base > 1 && base <= 36) {
                                const [value, rest] = fromDigits(op1.string, base);
                                if (rest) {
                                    return ce.error(['unexpected-digit', rest[0]], ['Latex', ce.string(op1.string)]);
                                }
                                return ce.number(value);
                            }
                        }
                    }
                    // Is it a compound symbol `x_\mathrm{max}`, `\mu_0`
                    // or an indexable collection?
                    if (op1.symbol) {
                        // Indexable collection?
                        if (op1.symbolDefinition?.at)
                            return ce._fn('At', [op1, op2.canonical]);
                        // Maybe a compound symbol
                        const sub = op2.string ?? op2.symbol ?? asSmallInteger(op2)?.toString();
                        if (sub)
                            return ce.symbol(op1.symbol + '_' + sub);
                    }
                    if (op2.head === 'Sequence')
                        ce._fn('Subscript', [op1, ce._fn('List', op2.ops)]);
                    return ce._fn('Subscript', args);
                },
            },
        },
        Symbol: {
            complexity: 500,
            description: 'Construct a new symbol with a name formed by concatenating the arguments',
            threadable: true,
            hold: 'all',
            signature: {
                domain: ['Function', ['Sequence', 'Anything'], 'Anything'],
                canonical: (ce, ops) => {
                    if (ops.length === 0)
                        return ce.symbol('Nothing');
                    const arg = ops
                        .map((x) => x.symbol ?? x.string ?? asSmallInteger(x)?.toString() ?? '')
                        .join('');
                    if (arg.length > 0)
                        return ce.symbol(arg);
                    return ce.symbol('Nothing');
                },
                // Note: a `["Symbol"]` expression is never evaluated, it gets
                // transformed into something else (a symbol) during canonicalization
            },
        },
        Tail: {
            signature: {
                domain: ['Function', 'Value', ['List', 'Value']],
                evaluate: (ce, ops) => ops[0] ? ce._fn('List', ops[0].ops ?? []) : ce._fn('List', []),
            },
        },
        Timing: {
            description: '`Timing(expr)` evaluates `expr` and return a `Pair` of the number of second elapsed for the evaluation, and the value of the evaluation',
            signature: {
                domain: [
                    'Function',
                    'Value',
                    ['Maybe', 'Integer'],
                    ['Tuple', 'Value', 'Number'],
                ],
                evaluate: (ce, ops) => {
                    if (ops[1].symbol === 'Nothing') {
                        // Evaluate once
                        const start = globalThis.performance.now();
                        const result = ops[0].evaluate();
                        const timing = 1000 * (globalThis.performance.now() - start);
                        return ce.pair(ce.number(timing), result);
                    }
                    // Evaluate multiple times
                    let n = Math.max(3, Math.round(asSmallInteger(ops[1]) ?? 3));
                    let timings = [];
                    let result;
                    while (n > 0) {
                        const start = globalThis.performance.now();
                        result = ops[0].evaluate();
                        timings.push(1000 * (globalThis.performance.now() - start));
                        n -= 1;
                    }
                    const max = Math.max(...timings);
                    const min = Math.min(...timings);
                    timings = timings.filter((x) => x > min && x < max);
                    const sum = timings.reduce((acc, v) => acc + v, 0);
                    if (sum === 0)
                        return ce.pair(ce.number(max), result);
                    return ce.pair(ce.number(sum / timings.length), result);
                },
            },
        },
        // {name: 'Pattern',},
    },
    //
    // String-related
    //
    {
        FromDigits: {
            description: `\`FromDigits(s, base=10)\` \
      return an integer representation of the string \`s\` in base \`base\`.`,
            // @todo could accept `0xcafe`, `0b01010` or `(deadbeef)_16` as string formats
            // @todo could accept "roman"... as base
            // @todo could accept optional third parameter as the (padded) length of the output
            signature: {
                domain: ['Function', 'String', ['Maybe', ['Range', 1, 36]], 'Integer'],
                evaluate: (ce, ops) => {
                    const op1 = ops[0];
                    if (!op1.string)
                        return ce.error(['incompatible-domain', 'String', op1.domain], op1);
                    const op2 = ops[1];
                    if (op2.isNothing)
                        return ce.number(Number.parseInt(op1.string, 10));
                    if (op2.numericValue === null) {
                        return ce.error(['unexpected-base', op2.latex], op2);
                    }
                    const base = asFloat(op2);
                    if (!Number.isInteger(base) || base < 2 || base > 36)
                        return ce.error(['unexpected-base', base], op2);
                    const [value, rest] = fromDigits(op1.string, base);
                    if (rest)
                        return ce.error(['unexpected-digit', rest[0]], { str: rest });
                    return ce.number(value);
                },
            },
        },
        IntegerString: {
            description: `\`IntegerString(n, base=10)\` \
      return a string representation of the integer \`n\` in base \`base\`.`,
            // @todo could accept `0xcafe`, `0b01010` or `(deadbeef)_16` as string formats
            // @todo could accept "roman"... as base
            // @todo could accept optional third parameter as the (padded) length of the output
            signature: {
                domain: ['Function', 'Integer', ['Maybe', 'Integer'], 'String'],
                evaluate: (ce, ops) => {
                    const op1 = ops[0];
                    const val = asFloat(op1) ?? NaN;
                    if (Number.isNaN(val) || !Number.isInteger(val)) {
                        return ce.error(['incompatible-domain', 'Integer', op1.domain], op1);
                    }
                    const op2 = ops[1];
                    if (op2.isNothing) {
                        const op1Num = op1.numericValue;
                        if (typeof op1Num === 'number')
                            return ce.string(Math.abs(op1Num).toString());
                        if (op1Num instanceof Decimal)
                            return ce.string(op1Num.abs().toString());
                        return ce.string(Math.abs(Math.round(asFloat(op1) ?? NaN)).toString());
                    }
                    if (asSmallInteger(op2) === null) {
                        return ce.error(['incompatible-domain', 'Integer', op2.domain], op2);
                    }
                    const base = asSmallInteger(op2);
                    if (base < 2 || base > 36)
                        return ce.error(['out-of-range', 2, 36, base], op2);
                    return ce.string(Math.abs(val).toString(base));
                },
            },
        },
        String: {
            threadable: true,
            signature: {
                domain: ['Function', ['Maybe', 'Anything'], 'String'],
                evaluate: (ce, ops) => {
                    if (ops.length === 0)
                        return ce.string('');
                    return ce.string(ops.map((x) => x.string ?? x.toString()).join(''));
                },
            },
        },
    },
    //
    // LaTeX-related
    //
    {
        // Join or more LatexTokens into a LaTeX string
        JoinLatexTokens: {
            signature: {
                domain: ['Function', ['Maybe', ['Sequence', 'Anything']], 'String'],
                evaluate: (ce, ops) => {
                    return ce.box([
                        'Latex',
                        ce.string(tokensToString(ops.map((x) => x.string ?? x.latex))),
                    ]);
                },
            },
        },
        // Value preserving type conversion/tag indicating the string
        // is a LaTeX string
        Latex: {
            signature: {
                domain: ['Function', ['Maybe', ['Sequence', 'Anything']], 'String'],
                evaluate: (ce, ops) => {
                    if (ops.length === 0)
                        return ce.string('');
                    return ce.string(joinLatex(ops.map((x) => x.string ?? x.toString())));
                },
            },
        },
        // Serialize one or more expressions to LaTeX
        SerializeLatex: {
            hold: 'all',
            signature: {
                domain: ['Function', ['Maybe', ['Sequence', 'Anything']], 'String'],
                evaluate: (ce, ops) => ce.box(['Latex', ce.string(joinLatex(ops.map((x) => x.latex)))]),
            },
        },
        SplitAsLatexTokens: {
            description: 'Split a LaTeX string into a list of LaTeX tokens',
            hold: 'all',
            signature: {
                domain: ['Function', ['Maybe', 'Anything'], ['List', 'String']],
                evaluate: (ce, ops) => {
                    if (ops.length === 0)
                        return ce._fn('List', []);
                    let latex = '';
                    if (ops[0].head === 'Latex')
                        latex = ops[0].op1.string ?? '';
                    else if (ops[0].head === 'LatexString')
                        latex = joinLatex(ops[0].ops.map((op) => op.latex));
                    else
                        latex = ops[0].latex;
                    return ce._fn('List', tokenize(latex, []).map((x) => ce.string(x)));
                },
            },
        },
        ParseLatex: {
            description: 'Parse a LaTeX string and evaluate to a corresponding expression',
            signature: {
                domain: ['Function', ['Maybe', 'String'], 'Anything'],
                evaluate: (ce, ops) => {
                    if (ops.length === 0 || !ops[0].string)
                        return ce.box(['Sequence']);
                    return ce.parse(ops[0].string) ?? ce.box(['Sequence']);
                },
            },
        },
    },
    {
        RandomExpression: {
            signature: {
                domain: 'Function',
                evaluate: (ce, _ops) => ce.box(randomExpression()),
            },
        },
    },
];
// xcas/gias https://www-fourier.ujf-grenoble.fr/~parisse/giac/doc/en/cascmd_en/cascmd_en.html
// https://www.haskell.org/onlinereport/haskell2010/haskellch9.html#x16-1720009.1
// length(expr, depth:integer) (for a list, an expression, etc..)
// shape
// length
// depth
/*
 DICTIONARY
 aka Association in Wolfram, Dictionary in Python and Swift, Record in Maple,
 Map Containers in mathlab, Map in JavaScript
 Dictionary("field1", "value1", "field2", "value2"...)
 Need a new atomic 'dict' MathJSON type?
  {{name: 'dict',"field1": "value1", "field2": "value2"}}
*/
// LISTS
// take(n, list) -> n first elements of the list
// https://www.mathworks.com/help/referencelist.html?type=function&listtype=cat&category=&blocktype=&capability=&s_tid=CRUX_lftnav        // list
// repeat(x) -> infinite list with "x" as argument
// cycle(list) -> infinitely repeating list, i.e. cycle({1, 2, 3}) -> {1, 2, 3, 1, 2, 3, 1...}
// iterate(f, acc) -> {f(acc), f(f(acc)), f(f(f(acc)))...}
// == NestList ??
// Append (python) / Push
// Insert(i, x)
// Pop(): remove last, Pop(i): remove item at [i]
// Range
// index
// Evaluate
// Bind // replace  ( x-> 1)
// Domain
// min, max
// None -- constant for some options
// rule ->
// delayed-rule: :> (value of replacement is recalculated each time)
// set, set delayed
// join
// convert(expr, CONVERT_TO, OPTIONS) -- See Maple
// convert(expr, options), with options such as 'cos', 'sin, 'trig, 'exp', 'ln', 'latex', 'string', etc...)
// N
// set, delayed-set
// spread -> expand the elements of a list. If inside a list, insert the list into its parent
// compose (compose(f, g) -> a new function such that compose(f, g)(x) -> f(g(x))
// Symbol(x) -> x as a symbol, e.g. symbol('x' + 'y') -> `xy` (and registers it)
// Symbols() -> return list of all known symbols
// variables() -> return list of all free variables

const LOGIC_LIBRARY = {
    True: { wikidata: 'Q16751793', domain: 'Boolean', constant: true },
    False: {
        wikidata: 'Q5432619',
        domain: 'Boolean',
        constant: true,
    },
    Maybe: {
        wikidata: 'Q781546',
        domain: 'MaybeBoolean',
        constant: true,
    },
    // @todo: specify a `canonical` function that converts boolean
    // expressions into CNF (Conjunctive Normal Form)
    // https://en.wikipedia.org/wiki/Conjunctive_normal_form
    // using rules (with a rule set that's kinda the inverse of the
    // logic rules for simplify
    And: {
        wikidata: 'Q191081',
        threadable: true,
        associative: true,
        commutative: true,
        idempotent: true,
        complexity: 10000,
        signature: {
            domain: 'LogicOperator',
            simplify: processAnd,
            evaluate: processAnd,
        },
    },
    Or: {
        wikidata: 'Q1651704',
        threadable: true,
        associative: true,
        commutative: true,
        idempotent: true,
        complexity: 10000,
        signature: {
            domain: 'LogicOperator',
            simplify: processOr,
            evaluate: processOr,
        },
    },
    Not: {
        wikidata: 'Q190558',
        involution: true,
        complexity: 10100,
        // @todo: this may not be needed, since we also have rules.
        signature: {
            domain: 'LogicOperator',
            simplify: processNot,
            evaluate: processNot,
        },
    },
    Equivalent: {
        wikidata: 'Q220433',
        complexity: 10200,
        signature: {
            domain: 'LogicOperator',
            simplify: processEquivalent,
            evaluate: processEquivalent,
        },
    },
    Implies: {
        wikidata: 'Q7881229',
        complexity: 10200,
        signature: {
            domain: 'LogicOperator',
            simplify: processImplies,
            evaluate: processImplies,
        },
    },
    Exists: { signature: { domain: 'MaybeBoolean' } },
    If: {
        hold: 'rest',
        signature: {
            domain: 'Function',
            codomain: (ce, ops) => ce.domain(['Union', ops[0], ops[1]]),
            simplify: (ce, ops) => {
                const cond = ops[0];
                if (cond && cond.symbol === 'True')
                    return ops[1] ? ops[1].simplify() : ce.box('Nothing');
                return ops[2] ? ops[2].simplify() : ce.box('Nothing');
            },
            evaluate: (ce, ops) => {
                const cond = ops[0];
                if (cond && cond.symbol === 'True')
                    return ops[1] ? ops[1].evaluate() : ce.box('Nothing');
                return ops[2] ? ops[2].evaluate() : ce.box('Nothing');
            },
            N: (ce, ops) => {
                const cond = ops[0];
                if (cond && cond.symbol === 'True')
                    return ops[1] ? ops[1].N() : ce.box('Nothing');
                return ops[2] ? ops[2].N() : ce.box('Nothing');
            },
        },
    },
    Loop: {
        hold: 'all',
        signature: {
            domain: 'Function',
            simplify: (ce, ops) => ops[0]?.simplify() ?? ce.box('Nothing'),
            evaluate: (ce, ops) => {
                const body = ops[0] ?? ce.box('Nothing');
                if (body.isNothing)
                    return body;
                let result;
                let i = 0;
                do {
                    result = body.evaluate();
                    i += 1;
                } while (result.head !== 'Return' && i < ce.iterationLimit);
                if (result.head === 'Return')
                    return result.op1;
                return ce.error('iteration-limit-exceeded');
            },
            N: (ce, ops) => {
                const cond = ops[0];
                if (cond && cond.symbol === 'True')
                    return ops[1] ? ops[1].N() : ce.box('Nothing');
                return ops[2] ? ops[2].N() : ce.box('Nothing');
            },
        },
    },
    Which: {
        hold: 'all',
        signature: {
            domain: 'Function',
            codomain: (ce, ops) => domainWhich(ce, ops),
            evaluate: (ce, ops) => whichEvaluate(ce, ops, 'evaluate'),
            N: (ce, ops) => whichEvaluate(ce, ops, 'N'),
        },
    },
};
function processAnd(ce, args) {
    if (args.length === 0)
        return ce.symbol('True');
    const ops = [];
    for (const arg of args) {
        // ['And', ... , 'False', ...] -> 'False'
        if (arg.symbol === 'False')
            return ce.symbol('False');
        if (arg.symbol !== 'True') {
            //Check if arg matches one of the tail elements
            let duplicate = false;
            for (const x of ops) {
                if (x.isSame(arg)) {
                    // ['And', a, ..., a]
                    // Duplicate element, ignore it
                    duplicate = true;
                }
                else if ((arg.head === 'Not' && arg.op1.isSame(x)) ||
                    (x.head === 'Not' && x.op1.isSame(arg))) {
                    // ['And', ['Not', a],... a]
                    // Contradition
                    return ce.symbol('False');
                }
            }
            if (!duplicate)
                ops.push(arg);
        }
    }
    if (ops.length === 0)
        return ce.symbol('True');
    if (ops.length === 1)
        return ops[0];
    return ce._fn('And', ops);
}
function processOr(ce, args) {
    if (args.length === 0)
        return ce.symbol('True');
    const ops = [];
    for (const arg of args) {
        // ['Or', ... , 'True', ...] -> 'True'
        if (arg.symbol === 'True')
            return ce.symbol('True');
        if (arg.symbol !== 'False') {
            //Check if arg matches one of the tail elements
            let duplicate = false;
            for (const x of ops) {
                if (x.isSame(arg)) {
                    // ['Or', a, ..., a]
                    // Duplicate element, ignore it
                    duplicate = true;
                }
                else if ((arg.head === 'Not' && arg.op1.isSame(x)) ||
                    (x.head === 'Not' && x.op1.isSame(arg))) {
                    // ['Or', ['Not', a],... a]
                    // Tautology
                    return ce.symbol('True');
                }
            }
            if (!duplicate)
                ops.push(arg);
        }
    }
    if (ops.length === 0)
        return ce.symbol('True');
    if (ops.length === 1)
        return ops[0];
    return ce._fn('Or', ops);
}
function processNot(ce, args) {
    const op1 = args[0].symbol;
    if (op1 === 'True')
        return ce.symbol('False');
    if (op1 === 'False')
        return ce.symbol('True');
    if (op1 === 'Maybe')
        return ce.symbol('Maybe');
    return undefined;
}
function processEquivalent(ce, args) {
    const lhs = args[0].symbol;
    const rhs = args[1].symbol;
    if ((lhs === 'True' && rhs === 'True') ||
        (lhs === 'False' && rhs === 'False'))
        return ce.symbol('True');
    if ((lhs === 'True' && rhs === 'False') ||
        (lhs === 'False' && rhs === 'True'))
        return ce.symbol('False');
    if (lhs === 'Maybe' || rhs === 'Maybe')
        return ce.symbol('Maybe');
    return undefined;
}
function processImplies(ce, args) {
    const lhs = args[0].symbol;
    const rhs = args[1].symbol;
    if ((lhs === 'True' && rhs === 'True') ||
        (lhs === 'False' && rhs === 'False') ||
        (lhs === 'False' && rhs === 'True'))
        return ce.symbol('True');
    if (lhs === 'True' && rhs === 'False')
        return ce.symbol('False');
    if (lhs === 'Maybe' || rhs === 'Maybe')
        return ce.symbol('Maybe');
    return undefined;
}
function domainWhich(ce, args) {
    let dom = null;
    for (let i = 1; i <= args.length - 1; i += 2) {
        if (!dom)
            dom = args[i].domain;
        else
            dom = sharedAncestorDomain(dom, args[i].domain);
    }
    return dom ?? ce.domain('Nothing');
}
function whichEvaluate(ce, args, mode) {
    let i = 0;
    while (i < args.length - 1) {
        if (args[i].evaluate().symbol === 'True') {
            if (!args[i + 1])
                return ce.symbol('Undefined');
            return mode === 'N' ? args[i + 1].N() : args[i + 1].evaluate();
        }
        i += 2;
    }
    return ce.symbol('Undefined');
}

const POLYNOMIALS_LIBRARY = [
    {
        Expand: {
            description: 'Expand out products and positive integer powers',
            signature: {
                domain: ['Function', 'Value', 'Value'],
                evaluate: (_ce, ops) => expand(ops[0]),
            },
        },
    },
];
//@todo
//   // degree
//   // factors
//   // roots

//   // eq, lt, leq, gt, geq, neq, approx
//   //     shortLogicalImplies: 52, // ➔
//   // shortImplies => 51
//   // implies ==> 49
//   //    impliedBy: 45, // <==
//   // less-than-or-equal-to: Q55935272 241
//   // greater-than-or-equal: Q55935291 242
//   // greater-than: Q47035128  243
//   // less-than: Q52834024 245
const RELOP_LIBRARY = {
    Equal: {
        commutative: true,
        complexity: 11000,
        signature: {
            domain: 'RelationalOperator',
            canonical: (ce, ops) => {
                return ce._fn('Equal', flattenOps(canonical(flattenSequence(ops)), 'Equal'));
            },
            evaluate: (ce, ops) => {
                if (ops.length < 2)
                    return ce.symbol('True');
                let lhs = undefined;
                for (const arg of ops) {
                    if (!lhs)
                        lhs = arg;
                    else {
                        const test = lhs.isEqual(arg);
                        if (test !== true)
                            return ce.symbol('False');
                    }
                }
                return ce.symbol('True');
            },
        },
    },
    NotEqual: {
        wikidata: 'Q28113351',
        commutative: true,
        complexity: 11000,
        signature: {
            domain: 'RelationalOperator',
            evaluate: (ce, ops) => {
                if (ops.length < 2)
                    return ce.symbol('False');
                let lhs = undefined;
                for (const arg of ops) {
                    if (!lhs)
                        lhs = arg;
                    else {
                        const test = lhs.isEqual(arg);
                        if (test === true)
                            return ce.symbol('False');
                    }
                }
                return ce.symbol('True');
            },
        },
    },
    Less: {
        complexity: 11000,
        signature: {
            domain: 'RelationalOperator',
            canonical: (ce, ops) => ce._fn('Less', flattenOps(canonical(flattenSequence(ops)), 'Less')),
            evaluate: (ce, ops) => {
                if (ops.length < 2)
                    return ce.symbol('True');
                let lhs = undefined;
                for (const arg of ops) {
                    if (!arg.isNumber)
                        return undefined;
                    if (!lhs)
                        lhs = arg;
                    else {
                        const test = ce.fn('Subtract', [arg, lhs]).N().sgn;
                        if (test === null || test === undefined)
                            return undefined;
                        if (test <= 0)
                            return ce.symbol('False');
                        lhs = arg;
                    }
                }
                return ce.symbol('True');
            },
        },
    },
    NotLess: {
        complexity: 11000,
        signature: {
            domain: 'RelationalOperator',
            canonical: (ce, args) => ce._fn('Not', [ce._fn('Less', args)]),
        },
    },
    Greater: {
        complexity: 11000,
        signature: {
            domain: 'RelationalOperator',
            canonical: (ce, args) => ce._fn('Less', args.reverse()),
            evaluate: (ce, ops) => {
                if (ops.length < 2)
                    return ce.symbol('True');
                let lhs = undefined;
                for (const arg of ops) {
                    if (!arg.isNumber)
                        return undefined;
                    if (!lhs)
                        lhs = arg;
                    else {
                        const test = ce.fn('Subtract', [arg, lhs]).N().sgn;
                        if (test === null || test === undefined)
                            return undefined;
                        if (test >= 0)
                            return ce.symbol('False');
                        lhs = arg;
                    }
                }
                return ce.symbol('True');
            },
        },
    },
    NotGreater: {
        complexity: 11000,
        signature: {
            domain: 'RelationalOperator',
            canonical: (ce, args) => ce._fn('Not', [ce._fn('Greater', args)]),
        },
    },
    LessEqual: {
        complexity: 11000,
        signature: {
            domain: 'RelationalOperator',
            evaluate: (ce, ops) => {
                if (ops.length < 2)
                    return ce.symbol('True');
                let lhs = undefined;
                for (const arg of ops) {
                    if (!arg.isNumber)
                        return undefined;
                    if (!lhs)
                        lhs = arg;
                    else {
                        const test = ce.fn('Subtract', [arg, lhs]).N().sgn;
                        if (test === null || test === undefined)
                            return undefined;
                        if (test < 0)
                            return ce.symbol('False');
                        lhs = arg;
                    }
                }
                return ce.symbol('True');
            },
        },
    },
    NotLessNotEqual: {
        complexity: 11000,
        signature: {
            domain: 'RelationalOperator',
            canonical: (ce, args) => ce._fn('Not', [ce._fn('LessEqual', args)]),
        },
    },
    GreaterEqual: {
        complexity: 11000,
        signature: {
            domain: 'RelationalOperator',
            canonical: (ce, args) => ce._fn('LessEqual', args.reverse()),
            evaluate: (ce, ops) => {
                if (ops.length < 2)
                    return ce.symbol('True');
                let lhs = undefined;
                for (const arg of ops) {
                    if (!arg.isNumber)
                        return undefined;
                    if (!lhs)
                        lhs = arg;
                    else {
                        const test = ce.fn('Subtract', [arg, lhs]).N().sgn;
                        if (test === null || test === undefined)
                            return undefined;
                        if (test > 0)
                            return ce.symbol('False');
                        lhs = arg;
                    }
                }
                return ce.symbol('True');
            },
        },
    },
    NotGreaterNotEqual: {
        complexity: 11000,
        signature: {
            domain: 'RelationalOperator',
            canonical: (ce, args) => ce._fn('Not', [ce._fn('GreaterEqual', args)]),
        },
    },
    TildeFullEqual: {
        description: 'Indicate isomorphism, congruence and homotopic equivalence',
        signature: { domain: 'RelationalOperator' },
        // @todo evaluate: (ce, ...args: BoxedExpression[]) => SemiBoxedExpression {}
    },
    NotTildeFullEqual: {
        complexity: 11100,
        signature: {
            domain: 'RelationalOperator',
            canonical: (ce, args) => ce._fn('Not', [ce._fn('TildeFullEqual', args)]),
        },
    },
    TildeEqual: {
        description: 'Approximately or asymptotically equal',
        complexity: 11000,
        signature: { domain: 'RelationalOperator' },
        // @todo evaluate: (ce, ...args: BoxedExpression[]) => SemiBoxedExpression {}
    },
    NotTildeEqual: {
        complexity: 11100,
        signature: {
            domain: 'RelationalOperator',
            canonical: (ce, args) => ce._fn('Not', [ce._fn('TildeEqual', args)]),
        },
    },
    Approx: {
        complexity: 11100,
        signature: { domain: 'RelationalOperator' },
        // @todo evaluate: (ce, ...args: BoxedExpression[]) => SemiBoxedExpression {}
    },
    NotApprox: {
        complexity: 11100,
        signature: {
            domain: 'RelationalOperator',
            canonical: (ce, args) => ce._fn('Not', [ce._fn('Approx', args)]),
        },
    },
    ApproxEqual: {
        complexity: 11100,
        signature: { domain: 'RelationalOperator' },
        // @todo evaluate: (ce, ...args: BoxedExpression[]) => SemiBoxedExpression {}
    },
    NotApproxEqual: {
        complexity: 11100,
        signature: {
            domain: 'RelationalOperator',
            canonical: (ce, args) => ce._fn('Not', [ce._fn('ApproxEqual', args)]),
        },
    },
    ApproxNotEqual: {
        complexity: 11100,
        signature: { domain: 'RelationalOperator' },
        // @todo evaluate: (ce, ...args: BoxedExpression[]) => SemiBoxedExpression {}
    },
    NotApproxNotEqual: {
        complexity: 11100,
        signature: {
            domain: 'RelationalOperator',
            canonical: (ce, args) => ce._fn('Not', [ce._fn('ApproxNotEqual', args)]),
        },
    },
    Precedes: {
        complexity: 11100,
        signature: { domain: 'RelationalOperator' },
        // @todo evaluate: (ce, ...args: BoxedExpression[]) => SemiBoxedExpression {}
    },
    NotPrecedes: {
        complexity: 11100,
        signature: {
            domain: 'RelationalOperator',
            canonical: (ce, args) => ce._fn('Not', [ce._fn('Precedes', args)]),
        },
    },
    Succeeds: {
        signature: { domain: 'RelationalOperator' },
        // @todo evaluate: (ce, ...args: BoxedExpression[]) => SemiBoxedExpression {}
    },
    NotSucceeds: {
        complexity: 11100,
        signature: {
            domain: 'RelationalOperator',
            canonical: (ce, args) => ce._fn('Not', [ce._fn('Succeeds', args)]),
        },
    },
};

// Set operations:
const SETS_LIBRARY = {
    //
    // Constants
    //
    EmptySet: {
        domain: 'Set',
        constant: true,
        wikidata: 'Q226183',
        // contains: () => false, // @todo not quite true...
        // includes: () => true, // The empty set is a subset of every set
    },
    //
    // Predicates
    //
    Element: {
        complexity: 11200,
        hold: 'all',
        signature: {
            domain: 'Predicate',
            canonical: (ce, args) => {
                args = validateArgumentCount(ce, flattenSequence(canonical(args)), 2);
                if (args.length === 2 && isDomain(args[1]))
                    return ce._fn('Element', [args[0], ce.domain(args[1])]);
                return ce._fn('Element', args);
            },
            evaluate: (ce, args) => evaluateElement(ce, args),
        },
    },
    NotElement: {
        complexity: 11200,
        hold: 'all',
        signature: {
            domain: 'Predicate',
            canonical: (ce, args) => ce.fn('Not', [ce.fn('Element', args)]),
        },
    },
    Subset: {
        complexity: 11200,
        signature: { domain: 'Predicate' },
    },
    NotSubset: {
        complexity: 11200,
        signature: {
            domain: 'Predicate',
            canonical: (ce, args) => ce.fn('Not', [ce.fn('Subset', args)]),
        },
    },
    Superset: {
        complexity: 11200,
        signature: { domain: 'Predicate' },
    },
    SupersetEqual: {
        complexity: 11200,
        signature: { domain: 'Predicate' },
    },
    NotSuperset: {
        complexity: 11200,
        signature: {
            domain: 'Predicate',
            canonical: (ce, args) => ce.fn('Not', [ce.fn('Superset', args)]),
        },
    },
    NotSupersetEqual: {
        complexity: 11200,
        signature: {
            domain: 'Predicate',
            canonical: (ce, args) => ce.fn('Not', [ce.fn('SupersetEqual', args)]),
        },
    },
    SubsetEqual: {
        complexity: 11200,
        signature: { domain: 'Predicate' },
        // evaluate: subsetEqual,
    },
    NotSubsetNotEqual: {
        complexity: 11200,
        signature: {
            domain: 'Predicate',
            canonical: (ce, args) => ce.fn('Not', [ce.fn('SubsetEqual', args)]),
        },
    },
    //
    // Functions
    //
    CartesianProduct: {
        // Aka the product set, the set direct product or cross product
        // Notation: \times
        wikidata: 'Q173740',
        signature: { domain: ['Function', 'Set', ['Sequence', 'Set'], 'Set'] },
        // evaluate: cartesianProduct,
    },
    Complement: {
        // Return the elements of the first argument that are not in any of
        // the subsequent lists
        wikidata: 'Q242767',
        signature: { domain: ['Function', 'Set', 'Set'] },
    },
    Intersection: {
        // notation: \cap
        wikidata: 'Q185837',
        threadable: true,
        associative: true,
        commutative: true,
        involution: true,
        signature: {
            domain: ['Function', 'Set', ['Sequence', 'Set'], 'Set'],
            evaluate: intersection,
        },
    },
    Union: {
        // Works on set, but can also work on lists
        wikidata: 'Q185359',
        threadable: true,
        associative: true,
        commutative: true,
        involution: true,
        signature: {
            domain: ['Function', 'Set', ['Sequence', 'Set'], 'Set'],
            evaluate: union,
        },
    },
    // {
    //   name: 'Set',
    //   domain: ['Function', ['Sequence', 'Anything'], 'Set'],
    //   // @todo! set has multiple forms
    //   // Set(Sequence)
    //   // Set(Sequence, Condition)
    //   // Set(Set, Condition)
    // }, // disjoint union Q842620 ⊔
    SetMinus: {
        wikidata: 'Q18192442',
        signature: {
            domain: ['Function', 'Set', 'Value', 'Set'],
            evaluate: setMinus,
        },
    },
    SymmetricDifference: {
        // symmetric difference = disjunctive union  (circled minus)
        /* = Union(Complement(a, b), Complement(b, a) */
        /* Corresponds to XOR in boolean logic */
        wikidata: 'Q1147242',
        signature: { domain: ['Function', 'Set', ['Sequence', 'Set'], 'Set'] },
    },
};
function union(ce, _ops) {
    return ce.symbol('False');
}
function intersection(ce, _ops) {
    return ce.symbol('EmptySet');
}
function setMinus(ce, _ops) {
    return ce.symbol('EmptySet');
}
function evaluateElement(ce, ops) {
    console.assert(ops.length === 2);
    const [lhs, rhs] = ops;
    if (rhs.string) {
        if (lhs.string && rhs.string.includes(lhs.string))
            return ce.symbol('True');
        return ce.symbol('False');
    }
    // Is the key `lhs` in the dictionary `rhs`?
    if (rhs.keys) {
        if (lhs.string)
            for (const key of rhs.keys)
                if (key === lhs.string)
                    return ce.symbol('True');
        return ce.symbol('False');
    }
    // Is the element `lhs` or the sublist `lhs` inside `rhs`?
    if (rhs.head === 'List') {
        if (lhs.head === 'List') {
            let found = false;
            for (let i = 0; i < 1 + (rhs.nops - lhs.nops); ++i) {
                found = true;
                for (let j = 0; j < lhs.nops; ++j) {
                    if (!rhs.ops[i + j].isEqual(lhs.ops[j])) {
                        found = false;
                        break;
                    }
                }
                if (found)
                    return ce.symbol('True');
            }
            return ce.symbol('False');
        }
        // Is the `lhs` element inside the list?
        const val = lhs.head === 'Hold' ? lhs.op1 : lhs;
        for (const elem of rhs.ops)
            if (val.isEqual(elem))
                return ce.symbol('True');
        return ce.symbol('False');
    }
    if (isDomain(rhs)) {
        if (lhs.domain.isCompatible(ce.domain(rhs)))
            return ce.symbol('True');
        return ce.symbol('False');
    }
    return ce._fn('Element', [lhs, rhs]);
}

//
//Note: Names of trigonometric functions follow ISO 80000 Section 13
//
const domainNumberToRealNumber = (_head) => {
    return ['Function', 'Number', 'ExtendedRealNumber'];
};
const trigFunction = (_head) => {
    return ['Function', 'Number', 'Number'];
};
const hyperbolicFunction = (_head) => {
    return ['Function', 'Number', 'Number'];
};
const TRIGONOMETRY_LIBRARY = [
    {
        //
        // Constants
        //
        Pi: {
            domain: 'TranscendentalNumber',
            flags: { algebraic: false },
            constant: true,
            holdUntil: 'N',
            wikidata: 'Q167',
            value: (engine) => bignumPreferred(engine) ? engine._BIGNUM_PI : Math.PI,
        },
    },
    {
        // sqrt(x*x + y*y)
        Degrees: {
            /* = Pi / 180 */
            signature: {
                domain: ['Function', 'Number', 'Number'],
                canonical: (ce, ops) => {
                    ops = validateArguments(ce, flattenSequence(canonical(ops)), [
                        'Number',
                    ]);
                    if (ops.length !== 1)
                        return ce.box(['Degrees', ops]);
                    const arg = ops[0];
                    if (arg.numericValue === null || !arg.isValid)
                        return ce.box(['Degrees', arg]);
                    return ce.div(ce.mul([arg, ce.symbol('Pi')]), ce.number(180));
                },
                evaluate: (ce, ops) => ce.mul([ops[0], ce.box(['Divide', 'Pi', 180])]),
            },
        },
        Hypot: {
            signature: {
                domain: ['Function', 'Number', 'Number', 'NonNegativeNumber'],
                simplify: (ce, ops) => ce
                    .box(['Sqrt', ['Add', ['Square', ops[0]], ['Square', ops[1]]]])
                    .simplify(),
                evaluate: [
                    'Lambda',
                    ['Sqrt', ['Add', ['Square', '_1'], ['Square', '_2']]],
                ],
            },
        },
        Sin: {
            complexity: 5000,
            signature: {
                domain: ['Function', 'Number', ['Interval', -1, 1]],
                simplify: (ce, ops) => constructibleValues(ce, 'Sin', ops[0])?.simplify() ??
                    (complexAllowed(ce)
                        ? ce
                            .box([
                            'Divide',
                            [
                                'Subtract',
                                ['Exp', ['Multiply', 'ImaginaryUnit', ops[0]]],
                                ['Exp', ['Multiply', 'ImaginaryUnit', ['Negate', ops[0]]]],
                            ],
                            ['Complex', 0, 2],
                        ])
                            .simplify()
                        : undefined),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Sin', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Sin', ops[0]),
            },
        },
    },
    {
        //
        // Basic trigonometric function
        // (may be used in the definition of other functions below)
        //
        Arctan: {
            wikidata: 'Q2257242',
            complexity: 5200,
            signature: {
                domain: domainNumberToRealNumber(),
                simplify: (ce, ops) => constructibleValues(ce, 'Arctan', ops[0])?.simplify(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Arctan', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Arctan', ops[0]),
            },
        },
        Arctan2: {
            wikidata: 'Q776598',
            complexity: 5200,
            signature: {
                domain: ['Function', 'Number', 'Number', 'Number'],
                N: (_ce, ops) => apply2N(ops[0], ops[1], Math.atan2, (a, b) => Decimal.atan2(a, b)),
            },
        },
        Cos: {
            complexity: 5050,
            signature: {
                domain: ['Function', 'Number', ['Interval', -1, 1]],
                simplify: (ce, ops) => constructibleValues(ce, 'Cos', ops[0])?.simplify() ??
                    ce
                        .box(['Sin', ['Add', ops[0], ['Multiply', 'Half', 'Pi']]])
                        .simplify(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Cos', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Cos', ops[0]),
            },
        },
        Tan: {
            // Range: 'RealNumber',
            complexity: 5100,
            signature: {
                domain: trigFunction(),
                simplify: (ce, ops) => constructibleValues(ce, 'Tan', ops[0])?.simplify() ??
                    ce.box(['Divide', ['Sin', ops[0]], ['Cos', ops[0]]]).simplify(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Tan', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Tan', ops[0]),
            },
        },
        /* converts (x, y) -> (radius, angle) */
        // ToPolarCoordinates: {
        //   domain: 'Function',
        //   outputDomain: ['TupleOf', 'RealNumber', 'RealNumber'],
        // }
    },
    //
    // Functions defined using arithmetic functions or basic
    // trigonometric functions above
    //
    {
        Arcosh: {
            complexity: 6200,
            signature: {
                domain: hyperbolicFunction(),
                simplify: (ce, ops) => constructibleValues(ce, 'Arcosh', ops[0])?.simplify() ??
                    ce
                        .box([
                        'Ln',
                        ['Add', ops[0], ['Sqrt', ['Subtract', ['Square', ops[0]], 1]]],
                    ])
                        .simplify(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Arcosh', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Arcosh', ops[0]),
            },
        },
        Arcsin: {
            complexity: 5500,
            signature: {
                domain: hyperbolicFunction(),
                simplify: (ce, ops) => constructibleValues(ce, 'Arcsin', ops[0])?.simplify() ??
                    ce
                        .box([
                        'Multiply',
                        2,
                        [
                            'Arctan2',
                            ops[0],
                            ['Add', 1, ['Sqrt', ['Subtract', 1, ['Square', ops[0]]]]],
                        ],
                    ])
                        .simplify(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Arcsin', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Arcsin', ops[0]),
            },
        },
        //Note: Arsinh, not ArCsinh
        Arsinh: {
            complexity: 6100,
            signature: {
                domain: hyperbolicFunction(),
                simplify: (ce, ops) => constructibleValues(ce, 'Arsinh', ops[0])?.simplify() ??
                    ce
                        .box([
                        'Ln',
                        ['Add', ops[0], ['Sqrt', ['Add', ['Square', ops[0]], 1]]],
                    ])
                        .simplify(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Arsinh', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Arsinh', ops[0]),
            },
        },
        Artanh: {
            complexity: 6300,
            signature: {
                domain: hyperbolicFunction(),
                simplify: (ce, ops) => constructibleValues(ce, 'Artanh', ops[0])?.simplify() ??
                    ce
                        .box([
                        'Multiply',
                        'Half',
                        ['Ln', ['Divide', ['Add', 1, ops[0]], ['Subtract', 1, ops[0]]]],
                    ])
                        .simplify(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Artanh', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Artanh', ops[0]),
            },
        },
        Cosh: {
            complexity: 6050,
            signature: {
                domain: hyperbolicFunction(),
                simplify: (ce, ops) => constructibleValues(ce, 'Cosh', ops[0])?.simplify() ??
                    ce
                        .box([
                        'Multiply',
                        'Half',
                        ['Add', ['Exp', ops[0]], ['Exp', ['Negate', ops[0]]]],
                    ])
                        .simplify(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Cosh', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Cosh', ops[0]),
            },
        },
        Cot: {
            complexity: 5600,
            signature: {
                domain: trigFunction(),
                simplify: (ce, ops) => constructibleValues(ce, 'Cot', ops[0])?.simplify() ??
                    ce.box(['Divide', ['Cos', ops[0]], ['Sin', ops[0]]]).simplify(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Cot', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Cot', ops[0]),
            },
        },
        Csc: {
            description: 'Cosecant',
            complexity: 5600,
            signature: {
                domain: trigFunction(),
                simplify: (ce, ops) => constructibleValues(ce, 'Csc', ops[0])?.simplify() ??
                    ce.box(['Divide', 1, ['Sin', ops[0]]]).simplify(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Csc', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Csc', ops[0]),
            },
        },
        /** = sin(z/2)^2 = (1 - cos z) / 2*/
        Haversine: {
            wikidata: 'Q2528380',
            signature: {
                domain: ['Function', 'ExtendedRealNumber', ['Interval', 0, 1]],
                evaluate: ['Lambda', ['Divide', ['Subtract', 1, ['Cos', '_1']], 2]],
            },
        },
        /** = 2 * Arcsin(Sqrt(z)) */
        InverseHaversine: {
            //  Range ['Interval', [['Negate', 'Pi'], 'Pi'],
            signature: {
                domain: ['Function', 'ExtendedRealNumber', 'RealNumber'],
                evaluate: ['Lambda', ['Multiply', 2, ['Arcsin', ['Sqrt', '_1']]]],
            },
        },
        Sec: {
            description: 'Secant, inverse of cosine',
            complexity: 5500,
            signature: {
                domain: trigFunction(),
                simplify: (ce, ops) => constructibleValues(ce, 'Sec', ops[0])?.simplify() ??
                    ce.box(['Divide', 1, ['Cos', ops[0]]]).simplify(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Sec', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Sec', ops[0]),
            },
        },
        Sinh: {
            // Range: ['Interval', -Infinity, Infinity],
            complexity: 6000,
            signature: {
                domain: hyperbolicFunction(),
                simplify: (ce, ops) => constructibleValues(ce, 'Sinh', ops[0])?.simplify() ??
                    ce
                        .box([
                        'Multiply',
                        'Half',
                        ['Subtract', ['Exp', ops[0]], ['Exp', ['Negate', ops[0]]]],
                    ])
                        .simplify(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Sinh', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Sinh', ops[0]),
            },
        },
    },
    {
        Csch: {
            complexity: 6200,
            signature: {
                domain: domainNumberToRealNumber(),
                simplify: (ce, ops) => constructibleValues(ce, 'Csch', ops[0])?.simplify() ??
                    ce.box(['Divide', 1, ['Sinh', ops[0]]]).simplify(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Csch', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Csch', ops[0]),
            },
        },
        Sech: {
            complexity: 6200,
            signature: {
                domain: ['Function', 'Number', ['Interval', -1, 1]],
                simplify: (ce, ops) => constructibleValues(ce, 'Sech', ops[0])?.simplify() ??
                    ce.box(['Divide', 1, ['Cosh', ops[0]]]).simplify(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Sech', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Sech', ops[0]),
            },
        },
        Tanh: {
            // Range: ['Interval', -Infinity, Infinity],
            complexity: 6200,
            signature: {
                domain: hyperbolicFunction(),
                simplify: (ce, ops) => constructibleValues(ce, 'Tanh', ops[0])?.simplify() ??
                    ce.box(['Divide', ['Sinh', ops[0]], ['Cosh', ops[0]]]).simplify(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Tanh', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Tanh', ops[0]),
            },
        },
    },
    {
        Arccos: {
            complexity: 5550,
            signature: {
                domain: domainNumberToRealNumber(),
                simplify: (ce, ops) => constructibleValues(ce, 'Arccos', ops[0])?.simplify() ??
                    ce
                        .box(['Subtract', ['Divide', 'Pi', 2], ['Arcsin', ops[0]]])
                        .simplify(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Arccos', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Arccos', ops[0]),
            },
        },
        Arccot: {
            numeric: true,
            signature: {
                domain: domainNumberToRealNumber(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Arccot', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Arccot', ops[0]),
            },
        },
        Arcoth: {
            numeric: true,
            signature: {
                domain: domainNumberToRealNumber(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Arcoth', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Arcoth', ops[0]),
            },
        },
        Arcsch: {
            numeric: true,
            signature: {
                domain: domainNumberToRealNumber(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Arcsch', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Arcsch', ops[0]),
            },
        },
        Arcsec: {
            numeric: true,
            signature: {
                domain: domainNumberToRealNumber(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Arcsec', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Arcsec', ops[0]),
            },
        },
        Arsech: {
            numeric: true,
            signature: {
                domain: domainNumberToRealNumber(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Arsech', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Arsech', ops[0]),
            },
        },
        Arccsc: {
            numeric: true,
            signature: {
                domain: domainNumberToRealNumber(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Arccsc', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Arccsc', ops[0]),
            },
        },
        Coth: {
            complexity: 6300,
            signature: {
                domain: hyperbolicFunction(),
                simplify: (ce, ops) => constructibleValues(ce, 'Coth', ops[0])?.simplify() ??
                    ce.box(['Divide', 1, ['Tanh', ops[0]]]).simplify(),
                evaluate: (ce, ops) => evalTrig(ce, 'evaluate', 'Coth', ops[0]),
                N: (ce, ops) => evalTrig(ce, 'N', 'Coth', ops[0]),
            },
        },
        /* converts (radius, angle) -> (x, y) */
        // FromPolarCoordinates: {
        //   domain: 'Function',
        //   outputDomain: ['TupleOf', 'RealNumber', 'RealNumber'],
        // },
        InverseFunction: {
            signature: {
                domain: ['Function', 'Function', 'Function'],
                canonical: (ce, ops) => {
                    ops = validateArgumentCount(ce, flattenSequence(canonical(ops)), 1);
                    return (processInverseFunction(ce, ops) ?? ce._fn('InverseFunction', ops));
                },
                simplify: (ce, ops) => processInverseFunction(ce, ops),
                evaluate: (ce, ops) => processInverseFunction(ce, ops),
            },
        },
    },
];
const S2 = ['Sqrt', 2];
const S3 = ['Sqrt', 3];
const S5 = ['Sqrt', 5];
const S6 = ['Sqrt', 6];
// From https://en.wikipedia.org/wiki/Trigonometric_functions
const CONSTRUCTIBLE_VALUES = [
    [
        [0, 1],
        {
            Sin: 0,
            Cos: 1,
            Tan: 0,
            Cot: NaN,
            Sec: 1,
            Csc: NaN,
        },
    ],
    [
        [1, 12],
        {
            Sin: ['Divide', ['Subtract', S6, S2], 4],
            Cos: ['Divide', ['Add', S6, S2], 4],
            Tan: ['Subtract', 2, S3],
            Cot: ['Add', 2, S3],
            Sec: ['Subtract', S6, S2],
            Csc: ['Add', S6, S2],
        },
    ],
    [
        [1, 10],
        {
            Sin: ['Divide', ['Subtract', S5, 1], 4],
            Cos: ['Divide', ['Sqrt', ['Add', 10, ['Multiply', 2, S5]]], 4],
            Tan: ['Divide', ['Sqrt', ['Subtract', 25, ['Multiply', 10, S5]]], 4],
            Cot: ['Sqrt', ['Add', 5, ['Multiply', 2, S5]]],
            Sec: ['Divide', ['Sqrt', ['Subtract', 50, ['Multiply', 10, S5]]], 5],
            Csc: ['Add', 1, S5],
        },
    ],
    [
        [1, 8],
        {
            Sin: '$\\frac\\sqrt{2-\\sqrt2}{2}$',
            Cos: '$\\frac {\\sqrt {2+{\\sqrt {2}}}}{2}$',
            Tan: '$\\sqrt{2} - 1$',
            Cot: '$\\sqrt{2} + 1$',
            Sec: '$\\sqrt{ 4 - 2\\sqrt{2}}$',
            Csc: '$\\sqrt{ 4 + 2\\sqrt{2}}$',
        },
    ],
    [
        [1, 6],
        {
            Sin: '$\\frac{1}{2}$',
            Cos: '$\\frac{\\sqrt{3}}{2}$',
            Tan: '$\\frac{\\sqrt{3}}{3}$',
            Cot: '$\\frac{2\\sqrt{3}}{3}$',
            Sec: '$\\sqrt{3}$',
            Csc: 2,
        },
    ],
    [
        [1, 5],
        {
            Sin: '$\\frac{\\sqrt{10- 2\\sqrt{5}}} {4}$',
            Cos: '$\\frac{1+ \\sqrt{5}} {4}$',
            Tan: '$\\sqrt{5-2\\sqrt5}$',
            Cot: '$\\frac{\\sqrt{25+10\\sqrt5}} {5}$',
            Sec: '$\\sqrt{5} - 1$',
            Csc: '$\\frac{\\sqrt{50+10\\sqrt{5}}} {5}$',
        },
    ],
    [
        [1, 4],
        {
            Sin: ['Divide', S2, 2],
            Cos: ['Divide', S2, 2],
            Tan: 1,
            Cot: 1,
            Sec: S2,
            Csc: S2,
        },
    ],
    [
        [3, 10],
        {
            Sin: '$\\frac{1+ \\sqrt{5}} {4}$',
            Cos: '$\\frac{\\sqrt{10- 2\\sqrt{5}}} {4}$',
            Tan: '$\\frac{\\sqrt{25+10\\sqrt5}} {5}$',
            Cot: '$\\sqrt{5-2\\sqrt5}$',
            Sec: '$$',
            Csc: '$\\frac{\\sqrt{50+10\\sqrt{5}}} {5}$',
        },
    ],
    [
        [1, 3],
        {
            Sin: ['Divide', S3, 2],
            Cos: 'Half',
            Tan: S3,
            Cot: ['Divide', S3, 3],
            Sec: 2,
            Csc: ['Divide', ['Multiply', 2, S3], 3], // '$\\frac{2\\sqrt{3}}{3}$'
        },
    ],
    [
        [3, 8],
        {
            Sin: '$\\frac{ \\sqrt{2 + \\sqrt{2}} } {2}$',
            Cos: '$\\frac{ \\sqrt{2 - \\sqrt{2}} } {2}$',
            Tan: '$\\sqrt{2} + 1$',
            Cot: '$\\sqrt{2} - 1$',
            Sec: '$\\sqrt{ 4 + 2 \\sqrt{2} }$',
            Csc: '$\\sqrt{ 4 - 2 \\sqrt{2} }$',
        },
    ],
    [
        [2, 5],
        {
            Sin: '$\\frac{\\sqrt{10+ 2\\sqrt{5}}} {4}$',
            Cos: '$\\frac{\\sqrt{5}-1} {4}$',
            Tan: '$\\sqrt{5+2\\sqrt{5}}$',
            Cot: '$\\frac{\\sqrt{25-10\\sqrt{5}}} {5}$',
            Sec: '$1 + \\sqrt{5}$',
            Csc: '$\\frac{\\sqrt{50-10\\sqrt{5}}} {5}$',
        },
    ],
    [
        [5, 12],
        {
            Sin: '$\\frac{\\sqrt{6} + \\sqrt{2}} {4}$',
            Cos: '$\\frac{ \\sqrt{6} - \\sqrt{2}} {4}$',
            Tan: '$2+\\sqrt{3}$',
            Cot: '$2-\\sqrt{3}$',
            Sec: '$\\sqrt{6}+\\sqrt{2}$',
            Csc: '$\\sqrt{6} - \\sqrt{2}$',
        },
    ],
    [
        [1, 2],
        {
            Sin: 1,
            Cos: 0,
            Tan: NaN,
            Cot: 0,
            Sec: NaN,
            Csc: 1,
        },
    ],
];
// For each trig function, by quadrant (0-π/2, π/2-π, π-3π/2, 3π/2-2π),
// what is the corresponding identity (sign and function)
// E.g 'Sin[θ+π/2] = Cos[θ]` -> Quadrant 2, Positive sign, Cos
const TRIG_IDENTITIES = {
    Sin: [
        [+1, 'Sin'],
        [+1, 'Cos'],
        [-1, 'Sin'],
        [-1, 'Cos'],
    ],
    Cos: [
        [+1, 'Cos'],
        [-1, 'Sin'],
        [-1, 'Cos'],
        [+1, 'Sin'],
    ],
    Sec: [
        [+1, 'Sec'],
        [-1, 'Csc'],
        [-1, 'Sec'],
        [+1, 'Csc'],
    ],
    Csc: [
        [+1, 'Csc'],
        [+1, 'Sec'],
        [-1, 'Csc'],
        [-1, 'Sec'],
    ],
    Tan: [
        [+1, 'Tan'],
        [-1, 'Cot'],
        [+1, 'Tan'],
        [-1, 'Cot'],
    ],
    Cot: [
        [+1, 'Cot'],
        [-1, 'Tan'],
        [+1, 'Cot'],
        [-1, 'Tan'],
    ],
};
function constructibleValues(ce, head, x) {
    const specialValues = ce.cache('constructible-trigonometric-values', () => {
        const values = [];
        for (const [val, results] of CONSTRUCTIBLE_VALUES) {
            const boxedResults = {};
            for (const head of Object.keys(results))
                boxedResults[head] =
                    ce.parse(latexString(results[head])) ?? ce.box(results[head]);
            values.push([val, boxedResults]);
        }
        return values;
    }, (cache) => {
        for (const [_k, v] of cache) {
            for (const v2 of Object.values(v))
                v2.unbind();
        }
        return cache;
    });
    x = x.N();
    if (x.numericValue === null)
        return undefined;
    let theta = asFloat(x) ?? null;
    if (theta === null)
        return undefined;
    theta = theta % (2 * Math.PI);
    // Odd-even identities
    const identitySign = head !== 'Cos' && head !== 'Sec' ? Math.sign(theta) : +1;
    theta = Math.abs(theta);
    const quadrant = Math.floor((theta * 2) / Math.PI); // 0-3
    theta = theta % (Math.PI / 2);
    let sign;
    [sign, head] = TRIG_IDENTITIES[head]?.[quadrant] ?? [1, head];
    sign = sign * identitySign;
    for (const [[n, d], result] of specialValues) {
        if (result[head] && ce.chop(theta - (Math.PI * n) / d) === 0) {
            // Cos and Sec are even functions, the others are odd
            return sign < 0 ? canonicalNegate(result[head]) : result[head];
        }
    }
    return undefined;
}
function processInverseFunction(ce, xs) {
    if (xs.length !== 1)
        return undefined;
    const expr = xs[0];
    const head = expr.symbol;
    if (typeof head !== 'string')
        return undefined;
    if (head === 'InverseFunction')
        return expr.op1;
    const newHead = {
        Sin: 'Arcsin',
        Cos: 'Arccos',
        Tan: 'Arctan',
        Sec: 'Arcsec',
        Csc: ' Arccsc',
        Sinh: 'Arsinh',
        Cosh: 'Arcosh',
        Tanh: 'Artanh',
        Sech: 'Arcsech',
        Csch: 'Arcsch',
        Arcosh: 'Cosh',
        Arccos: 'Cos',
        Arccsc: 'Csc',
        Arcsch: 'Csch',
        // '??': 'Cot',
        // '??': 'Coth',
        Arcsec: 'Sec',
        Arcsin: 'Sin',
        Arsinh: 'Sinh',
        Arctan: 'Tan',
        Artanh: 'Tanh',
    }[head];
    return newHead ? ce.symbol(newHead) : undefined;
}
function evalTrig(ce, mode, head, op) {
    if (mode === 'evaluate') {
        const result = constructibleValues(ce, head, op)?.evaluate();
        if (result)
            return result;
        if (op.isExact)
            return undefined;
    }
    switch (head) {
        case 'Arccos':
            return applyN(op, Math.acos, (x) => x.acos(), (x) => x.acos());
        case 'Arccot':
            return applyN(op, (x) => Math.atan2(1, x), (x) => Decimal.atan2(ce._BIGNUM_ONE, x), (x) => x.inverse().atan());
        case 'Arccsc':
            return applyN(op, (x) => Math.asin(1 / x), (x) => ce._BIGNUM_ONE.div(x).asin(), (x) => x.inverse().asin());
        case 'Arcosh':
            return applyN(op, Math.acosh, (x) => x.acosh(), (x) => x.acosh());
        case 'Arcoth':
            // ln[(1 + x) /(x − 1)] /2
            return applyN(op, (x) => x, (x) => x.acosh(), (x) => x.acosh());
        case 'Arcsch':
            // ln[1/x + √(1/x2 + 1)],
            return applyN(op, (x) => Math.log(1 / x + Math.sqrt(1 / (x * x) + 1)), (x) => ce._BIGNUM_ONE
                .div(x.mul(x))
                .add(ce._BIGNUM_ONE)
                .sqrt()
                .add(ce._BIGNUM_ONE.div(x))
                .log(), (x) => x.mul(x).inverse().add(1).sqrt().add(x.inverse()).log());
        case 'Arcsec':
            return applyN(op, (x) => Math.acos(1 / x), (x) => ce._BIGNUM_ONE.div(x).acos(), (x) => x.inverse().acos());
        case 'Arcsin':
            return applyN(op, Math.asin, (x) => x.asin(), (x) => x.asin());
        case 'Arsech':
            return applyN(op, (x) => Math.log((1 + Math.sqrt(1 - x * x)) / x), (x) => ce._BIGNUM_ONE.sub(x.mul(x).add(ce._BIGNUM_ONE).div(x)).log(), (x) => ce.complex(1).sub(x.mul(x)).add(1).div(x).log());
        case 'Arsinh':
            return applyN(op, Math.asinh, (x) => x.asinh(), (x) => x.asinh());
        case 'Arctan':
            return applyN(op, Math.atan, (x) => x.atan(), (x) => x.atan());
        case 'Artanh':
            return applyN(op, Math.atanh, (x) => x.atanh(), (x) => x.atanh());
        case 'Cos':
            return applyN(op, Math.cos, (x) => x
                .toSignificantDigits(ce.precision + 4)
                .cos()
                .toSignificantDigits(ce.precision), (x) => x.cos());
        case 'Cosh':
            return applyN(op, Math.cosh, (x) => x.cosh(), (x) => x.cosh());
        case 'Cot':
            return applyN(op, (x) => 1 / Math.tan(x), (x) => ce._BIGNUM_ONE.div(x.tan()), (x) => x.tan().inverse());
        case 'Coth':
            return applyN(op, (x) => 1 / Math.tanh(x), (x) => ce._BIGNUM_ONE.div(x.tanh()), (x) => x.tanh().inverse());
        case 'Csc':
            return applyN(op, (x) => 1 / Math.sin(x), (x) => ce._BIGNUM_ONE.div(x.sin()), (x) => x.sin().inverse());
        case 'Csch':
            return applyN(op, (x) => 1 / Math.sinh(x), (x) => ce._BIGNUM_ONE.div(x.sinh()), (x) => x.sinh().inverse());
        case 'Sec':
            return applyN(op, (x) => 1 / Math.cos(x), (x) => ce._BIGNUM_ONE.div(x.cos()), (x) => x.cos().inverse());
        case 'Sech':
            return applyN(op, (x) => 1 / Math.cosh(x), (x) => ce._BIGNUM_ONE.div(x.cosh()), (x) => x.cosh().inverse());
        case 'Sin':
            return applyN(op, Math.sin, (x) => x
                .toSignificantDigits(ce.precision + 4)
                .sin()
                .toSignificantDigits(ce.precision), (x) => x.sin());
        case 'Sinh':
            return applyN(op, Math.sinh, (x) => x.sinh(), (x) => x.sinh());
        case 'Tan':
            return applyN(op, Math.tan, (x) => x
                .toSignificantDigits(ce.precision + 4)
                .tan()
                .toSignificantDigits(ce.precision), (x) => x.tan());
        case 'Tanh':
            return applyN(op, Math.tanh, (x) => x.tanh(), (x) => x.tanh());
    }
    return undefined;
}

/**
 * THEORY OF OPERATIONS
 *
 * - The value or domain of a constant cannot be changed.
 * - If set explicitly, the value is the source of truth: it overrides any
 *  flags.
 * - Once the domain has been set, it can only be changed from a numeric domain
 * to another numeric domain (some expressions may have been validated with
 * assumptions that the domain was numeric).
 * - When the domain is changed, the value is preserved if it is compatible
 *  with the new domain, otherwise it is reset to no value. Flags are adjusted
 * to match the domain (discarded if not a numeric domain).
 * - When the value is changed, the domain is unaffected. If the value is not
 *  compatible with the domain (setting a def with a numeric domain to a value
 *  of `True` for example), the value is discarded.
 * - When getting a flag, if a value is available, it is the source of truth.
 * Otherwise, the stored flags are (the stored flags are also set when the domain is changed)
 *
 */
class BoxedSymbolDefinitionImpl {
    constructor(ce, name, def) {
        if (!ce.context)
            throw Error('No context available');
        this.name = name;
        this.wikidata = def.wikidata;
        this.description = def.description;
        this.url = def.url;
        this._engine = ce;
        this.scope = ce.context;
        this.name = name;
        this._flags = def.flags ? normalizeFlags(def.flags) : undefined;
        this._domain = def.domain ? ce.domain(def.domain) : undefined;
        this.constant = def.constant ?? false;
        this.holdUntil = def.holdUntil ?? 'simplify';
        if (this.constant) {
            this._defValue = def.value;
            this._value = null;
        }
        else {
            if (def.value) {
                if (isLatexString(def.value))
                    this._value = ce.parse(def.value) ?? ce.symbol('Undefined');
                else if (typeof def.value === 'function')
                    this._value = ce.box(def.value(ce) ?? 'Undefined');
                else if (def.value instanceof AbstractBoxedExpression)
                    this._value = def.value;
                else
                    this._value = ce.box(def.value);
            }
            else
                this._value = undefined;
            if (!this._value && this._domain && !def.flags)
                this._flags = domainToFlags(this._domain);
        }
    }
    reset() {
        // Force the value to be recalculated based on the original definition
        // Useful when the environment (e.g.) precision changes
        if (this.constant)
            this._value = null;
        // this.unbind();
    }
    // unbind() {
    //   this._value = null;
    //   this._domain = null;
    // }
    get value() {
        if (this._value === null) {
            const ce = this._engine;
            if (isLatexString(this._defValue))
                this._value = ce.parse(this._defValue) ?? ce.symbol('Undefined');
            else if (typeof this._defValue === 'function')
                this._value = ce.box(this._defValue(ce) ?? 'Undefined');
            else if (this._defValue)
                this._value = ce.box(this._defValue);
            else
                this._value = undefined;
            if (this._value?.numericValue) {
                const val = this._value.numericValue;
                if (!bignumPreferred(ce) && val instanceof Decimal)
                    this._value = ce.number(val.toNumber());
                else if (!complexAllowed(ce) && val instanceof Complex)
                    this._value = ce._NAN;
            }
        }
        return this._value ?? undefined;
    }
    set value(val) {
        if (this.constant)
            throw new Error(`The value of the constant "${this.name}" cannot be changed`);
        // There should be no _defValue (only constants would have them)
        console.assert(this._defValue === undefined);
        if (typeof val === 'number') {
            // @fastpath: avoid creating a boxed number if changing a machine value
            if (typeof this._value?.numericValue === 'number')
                this._value['_value'] = val;
            else
                this._value = this._engine.number(val);
        }
        else if (val) {
            const newVal = this._engine.box(val);
            // If the new value is not compatible with the domain, discard it
            if (!this._domain || newVal.domain.isCompatible(this._domain))
                this._value = newVal;
            else
                this._value = undefined;
        }
        else
            this._value = undefined;
        // If there were any flags, discard them, the value is the source of truth
        if (this._value !== undefined)
            this._flags = undefined;
        else
            this._flags = domainToFlags(this.domain);
    }
    get domain() {
        // The _domain, if present, has priority over the value
        // So if the domain is more general than the value, say 'Number',
        // that is what will be returned. It is possible to get the
        // expr.value.domain to get the more specific domain if desired.
        return this._domain ?? this._value?.domain ?? undefined;
    }
    set domain(domain) {
        if (this.constant)
            throw new Error(`The domain of the constant "${this.name}" cannot be changed`);
        if (!domain) {
            this._defValue = undefined;
            this._value = undefined;
            this._flags = undefined;
            this._domain = undefined;
            return;
        }
        domain = this._engine.domain(domain);
        // OK to change the domain if still numeric
        if (this._domain?.isNumeric) {
            if (!domain.isNumeric)
                throw Error("Can't change from a numeric domain to a non-numeric one");
            this._domain = domain;
            if (!this._value)
                this._flags = { ...(this._flags ?? {}), ...domainToFlags(domain) };
            return;
        }
        if (this._domain)
            throw Error("Can't change a non-numeric domain");
        this._flags = undefined;
        this._domain = domain;
        if (!this._value && domain.isNumeric)
            this._flags = { ...(this._flags ?? {}), ...domainToFlags(domain) };
    }
    //
    // Flags
    //
    get number() {
        return this.value?.isNumber ?? this._flags?.number;
    }
    set number(val) {
        this.updateFlags({ number: val });
    }
    get integer() {
        return this.value?.isInteger ?? this._flags?.integer;
    }
    set integer(val) {
        this.updateFlags({ integer: val });
    }
    get rational() {
        return this.value?.isRational ?? this._flags?.rational;
    }
    set rational(val) {
        this.updateFlags({ rational: val });
    }
    get algebraic() {
        // Most numbers will return undefined, so the flag will provide the info if
        // present
        return this.value?.isAlgebraic ?? this._flags?.algebraic;
    }
    set algebraic(val) {
        this.updateFlags({ algebraic: val });
    }
    get real() {
        return this.value?.isReal ?? this._flags?.real;
    }
    set real(val) {
        this.updateFlags({ real: val });
    }
    get extendedReal() {
        return this.value?.isExtendedReal ?? this._flags?.extendedReal;
    }
    set extendedReal(val) {
        this.updateFlags({ extendedReal: val });
    }
    get complex() {
        return this.value?.isComplex ?? this._flags?.complex;
    }
    set complex(val) {
        this.updateFlags({ complex: val });
    }
    get extendedComplex() {
        return this.value?.isExtendedComplex ?? this._flags?.extendedComplex;
    }
    set extendedComplex(val) {
        this.updateFlags({ extendedComplex: val });
    }
    get imaginary() {
        return this.value?.isImaginary ?? this._flags?.imaginary;
    }
    set imaginary(val) {
        this.updateFlags({ imaginary: val });
    }
    get positive() {
        return this.value?.isPositive ?? this._flags?.positive;
    }
    set positive(val) {
        this.updateFlags({ positive: val });
    }
    get nonPositive() {
        return this.value?.isNonPositive ?? this._flags?.nonPositive;
    }
    set nonPositive(val) {
        this.updateFlags({ nonPositive: val });
    }
    get negative() {
        return this.value?.isNegative ?? this._flags?.negative;
    }
    set negative(val) {
        this.updateFlags({ negative: val });
    }
    get nonNegative() {
        return this.value?.isNonNegative ?? this._flags?.nonNegative;
    }
    set nonNegative(val) {
        this.updateFlags({ nonNegative: val });
    }
    get zero() {
        return this.value?.isZero ?? this._flags?.zero;
    }
    set zero(val) {
        this.updateFlags({ zero: val });
    }
    get notZero() {
        return this.value?.isNotZero ?? this._flags?.notZero;
    }
    set notZero(val) {
        this.updateFlags({ notZero: val });
    }
    get one() {
        return this.value?.isOne ?? this._flags?.one;
    }
    set one(val) {
        this.updateFlags({ one: val });
    }
    get negativeOne() {
        return this.value?.isNegativeOne ?? this._flags?.negativeOne;
    }
    set negativeOne(val) {
        this.updateFlags({ negativeOne: val });
    }
    get infinity() {
        return this.value?.isInfinity ?? this._flags?.infinity;
    }
    set infinity(val) {
        this.updateFlags({ infinity: val });
    }
    get finite() {
        return this.value?.isFinite ?? this._flags?.finite;
    }
    set finite(val) {
        this.updateFlags({ finite: val });
    }
    get NaN() {
        return this.value?.isNaN ?? this._flags?.NaN;
    }
    set NaN(val) {
        this.updateFlags({ NaN: val });
    }
    get even() {
        return this.value?.isEven ?? this._flags?.even;
    }
    set even(val) {
        this.updateFlags({ even: val });
    }
    get odd() {
        return this.value?.isOdd ?? this._flags?.odd;
    }
    set odd(val) {
        this.updateFlags({ odd: val });
    }
    get prime() {
        const val = this._value;
        if (val) {
            if (!val.isInteger || val.isNonPositive)
                return false;
            return isPrime(asFloat(val) ?? NaN);
        }
        return this._flags?.prime;
    }
    set prime(val) {
        this.updateFlags({ prime: val });
    }
    get composite() {
        const val = this._value;
        if (val) {
            if (!val.isInteger || val.isNonPositive)
                return false;
            return !isPrime(asFloat(val) ?? NaN);
        }
        return this._flags?.composite;
    }
    set composite(val) {
        this.updateFlags({ composite: val });
    }
    updateFlags(flags) {
        // If this is a constant, can set the flags
        if (this.constant)
            throw Error('The flags of constant cannot be changed');
        if (this.domain?.isNumeric === false)
            throw Error('Flags only apply to numeric domains');
        let flagCount = 0;
        let consistent = true;
        for (const flag in Object.keys(flags)) {
            flagCount += 1;
            if (this._value && flags[flag] !== undefined) {
                switch (flag) {
                    case 'number':
                        consistent = this._value.isNumber === flags.number;
                        break;
                    case 'integer':
                        consistent = this._value.isInteger === flags.integer;
                        break;
                    case 'rational':
                        consistent = this._value.isRational === flags.rational;
                        break;
                    case 'algebraic':
                        consistent = this._value.isAlgebraic === flags.algebraic;
                        break;
                    case 'real':
                        consistent = this._value.isReal === flags.real;
                        break;
                    case 'extendedReal':
                        consistent = this._value.isExtendedReal === flags.extendedReal;
                        break;
                    case 'complex':
                        consistent = this._value.isComplex === flags.complex;
                        break;
                    case 'extendedComplex':
                        consistent =
                            this._value.isExtendedComplex === flags.extendedComplex;
                        break;
                    case 'imaginary':
                        consistent = this._value.isImaginary === flags.imaginary;
                        break;
                    case 'positive':
                        consistent = this._value.isPositive === flags.positive;
                        break;
                    case 'nonPositive':
                        consistent = this._value.isNonPositive === flags.nonPositive;
                        break;
                    case 'negative':
                        consistent = this._value.isNegative === flags.negative;
                        break;
                    case 'nonNegative':
                        consistent = this._value.isNonNegative === flags.nonNegative;
                        break;
                    case 'zero':
                        consistent = this._value.isZero === flags.zero;
                        break;
                    case 'notZero':
                        consistent = this._value.isNotZero === flags.notZero;
                        break;
                    case 'one':
                        consistent = this._value.isOne === flags.one;
                        break;
                    case 'negativeOne':
                        consistent = this._value.isNegativeOne === flags.negativeOne;
                        break;
                    case 'infinity':
                        consistent = this._value.isInfinity === flags.infinity;
                        break;
                    case 'NaN':
                        consistent = this._value.isNaN === flags.NaN;
                        break;
                    case 'finite':
                        consistent = this._value.isFinite === flags.finite;
                        break;
                    case 'even':
                        consistent = this._value.isEven === flags.even;
                        break;
                    case 'odd':
                        consistent = this._value.isOdd === flags.odd;
                        break;
                    case 'prime':
                        consistent = this._value.isPrime === flags.prime;
                        break;
                    case 'composite':
                        consistent = this._value.isComposite === flags.composite;
                        break;
                }
            }
        }
        if (flagCount > 0) {
            if (!consistent) {
                this._defValue = undefined;
                this._value = undefined;
            }
            this._domain = this._engine.domain('Number');
            if (!this._flags)
                this._flags = normalizeFlags(flags);
            else
                this._flags = { ...this._flags, ...normalizeFlags(flags) };
        }
    }
}
function definedKeys(xs) {
    return Object.fromEntries(Object.entries(xs).filter(([_k, v]) => v !== undefined));
}
function normalizeFlags(flags) {
    const result = { ...flags };
    if (flags.zero || flags.one || flags.negativeOne) {
        result.zero = flags.zero && !flags.one && !flags.negativeOne;
        result.notZero = !flags.zero || flags.one || flags.negativeOne;
        result.one = flags.one && !flags.zero && !flags.negativeOne;
        result.negativeOne = flags.negativeOne && !flags.zero && !flags.one;
        result.infinity = false;
        result.NaN = false;
        result.finite = true;
        result.integer = true;
        result.finite = true;
        result.infinity = false;
        result.NaN = false;
        result.even = flags.one;
        result.odd = !flags.one;
        // 0, 1 and -1 are neither prime nor composite
        result.prime = false;
        result.composite = false;
    }
    if (result.zero) {
        result.positive = false;
        result.negative = false;
        result.nonPositive = true;
        result.nonNegative = true;
    }
    if (result.notZero === true) {
        if (!result.imaginary)
            result.real = true;
        result.zero = false;
    }
    if (result.one) {
        result.positive = true;
    }
    if (result.negativeOne) {
        result.nonPositive = true;
    }
    if (result.positive || result.nonNegative) {
        result.negativeOne = false;
    }
    if (result.positive) {
        result.nonPositive = false;
        result.negative = false;
        result.nonNegative = true;
    }
    else if (result.nonPositive) {
        result.positive = false;
        result.negative = result.notZero;
        result.nonNegative = !result.zero;
    }
    else if (result.negative) {
        result.positive = false;
        result.nonPositive = result.notZero;
        result.nonNegative = false;
    }
    else if (result.nonNegative) {
        result.positive = result.notZero;
        result.nonPositive = !result.zero;
        result.negative = false;
    }
    // Positive or negative numbers are real (not imaginary)
    if (result.positive ||
        result.negative ||
        result.nonPositive ||
        result.nonNegative) {
        result.number = true;
        if (result.finite)
            result.real = true;
        // All non-imaginary numbers are complex
        else if (!result.finite)
            result.complex = true; // All non-imaginary numbers are complex
        result.imaginary = false;
    }
    if (result.finite) {
        result.number = true;
        result.complex = true;
        result.infinity = false;
        result.NaN = false;
    }
    if (result.infinity) {
        result.finite = false;
        result.NaN = false;
    }
    if (result.infinity === false) {
        result.extendedComplex = false;
        result.extendedReal = false;
    }
    if (flags.even)
        result.odd = false;
    if (flags.odd)
        result.even = false;
    // Adjust domain flags
    if (result.integer)
        result.rational = true;
    if (result.rational)
        result.algebraic = true;
    if (result.algebraic)
        result.real = true;
    if (result.real)
        result.complex = true;
    if (result.imaginary)
        result.complex = true;
    if (result.complex)
        result.number = true;
    if (result.real && result.infinity !== false)
        result.extendedReal = true;
    if (result.complex && result.infinity !== false)
        result.extendedComplex = true;
    // Adjust primality (depends on domain)
    if (result.even ||
        result.infinity ||
        result.NaN ||
        result.negative ||
        result.imaginary ||
        result.integer === false)
        result.prime = false;
    if (result.number && result.prime)
        result.composite = false;
    return result;
}
function domainToFlags(dom) {
    if (!dom)
        return {};
    const result = {};
    if (dom.isNumeric) {
        // @todo: handle `Range`, `Interval`, and other numeric literals
        const domain = dom.literal;
        result.number = true;
        if (domain === 'Integer')
            result.integer = true;
        if (domain === 'RationalNumber')
            result.rational = true;
        if (domain === 'AlgebraicNumber')
            result.algebraic = true;
        if (domain === 'TranscendentalNumber') {
            result.algebraic = false;
            result.real = true;
        }
        if (domain === 'ExtendedRealNumber')
            result.extendedReal = true;
        if (domain === 'RealNumber')
            result.real = true;
        if (domain === 'ImaginaryNumber')
            result.imaginary = true;
        if (domain === 'ExtendedComplexNumber')
            result.extendedComplex = true;
        if (domain === 'ComplexNumber')
            result.complex = true;
        if (domain === 'PositiveNumber') {
            result.notZero = true;
            result.real = true;
            result.positive = true;
        }
        if (domain === 'NegativeNumber') {
            result.notZero = true;
            result.real = true;
            result.negative = true;
        }
        if (domain === 'NonNegativeNumber') {
            result.real = true;
            result.positive = true;
        }
        if (domain === 'NonPositiveNumber') {
            result.real = true;
            result.negative = true;
        }
        if (domain === 'PositiveInteger') {
            result.notZero = true;
            result.integer = true;
            result.positive = true;
        }
        if (domain === 'NegativeNumber') {
            result.notZero = true;
            result.integer = true;
            result.negative = true;
        }
        if (domain === 'NonNegativeNumber') {
            result.integer = true;
            result.positive = true;
        }
        if (domain === 'NonPositiveNumber') {
            result.integer = true;
            result.negative = true;
        }
    }
    else {
        result.number = false;
        result.integer = false;
        result.rational = false;
        result.algebraic = false;
        result.real = false;
        result.extendedReal = false;
        result.complex = false;
        result.extendedComplex = false;
        result.imaginary = false;
        result.positive = false;
        result.nonPositive = false;
        result.negative = false;
        result.nonNegative = false;
        result.zero = false;
        result.notZero = false;
        result.one = false;
        result.negativeOne = false;
        result.infinity = false;
        result.NaN = false;
        result.odd = false;
        result.even = false;
        result.prime = false;
        result.composite = false;
    }
    return definedKeys(normalizeFlags(result));
}

class BoxedFunctionDefinitionImpl {
    constructor(ce, name, def) {
        if (!ce.context)
            throw Error('No context available');
        this.engine = ce;
        this.scope = ce.context;
        const idempotent = def.idempotent ?? false;
        const involution = def.involution ?? false;
        if (idempotent && involution)
            throw new Error(`Function Definition "${name}": the 'idempotent' and 'involution' flags are mutually exclusive`);
        this.name = name;
        this.description = def.description;
        this.wikidata = def.wikidata;
        this.threadable = def.threadable ?? false;
        this.associative = def.associative ?? false;
        this.commutative = def.commutative ?? false;
        this.idempotent = idempotent;
        this.involution = involution;
        this.inert = def.inert ?? false;
        this.numeric = def.numeric ?? false;
        this.pure = def.pure ?? true;
        this.complexity = def.complexity ?? DEFAULT_COMPLEXITY;
        this.hold = def.hold ?? 'none';
        if (this.inert) {
            if (def.hold)
                throw Error(`Function Definition "${name}": an inert function should not have a hold`);
            this.hold = 'rest';
            if (def.signature) {
                const sig = def.signature;
                // `canonical` and `domain` is OK for an inert function, but none of the others
                if ('simplify' in sig ||
                    'evaluate' in sig ||
                    'N' in sig ||
                    'evalDimension' in sig ||
                    'sgn' in sig ||
                    'compile' in sig)
                    throw Error(`Function Definition "${name}": an inert function should only have 'canonical' or 'codomain' handlers`);
            }
            if (this.threadable)
                throw Error(`Function Definition "${name}": an inert function should not be threadable`);
            if (this.associative)
                throw Error(`Function Definition "${name}": an inert function should not be associative`);
            if (this.commutative)
                throw Error(`Function Definition "${name}": an inert function should not be commutative`);
            if (this.idempotent)
                throw Error(`Function Definition "${name}": an inert function should not be idempotent`);
            if (this.involution)
                throw Error(`Function Definition "${name}": an inert function should not be involution`);
            if (!this.pure)
                throw Error(`Function Definition "${name}": an inert function should be pure`);
        }
        if (def.signature) {
            const sig = def.signature;
            const domain = sig.domain
                ? ce.domain(sig.domain)
                : def.numeric
                    ? ce.domain('NumericFunction')
                    : ce.domain('Function');
            if (!domain.isValid)
                throw Error(`Function Definition "${name}": invalid domain ${JSON.stringify(sig.domain)}`);
            const codomain = sig.codomain ??
                domain.codomain ??
                (def.numeric ? ce.domain('Number') : ce.domain('Anything'));
            this.signature = {
                domain,
                codomain,
                canonical: sig.canonical,
                simplify: sig.simplify,
                evaluate: !sig.evaluate
                    ? undefined
                    : typeof sig.evaluate === 'function'
                        ? sig.evaluate
                        : ce.box(sig.evaluate, { canonical: false }),
                N: sig.N,
                evalDimension: sig.evalDimension,
                sgn: sig.sgn,
                compile: sig.compile,
            };
        }
        else if (def.numeric) {
            this.signature = {
                domain: ce.domain('NumericFunction'),
                codomain: ce.domain('Number'),
            };
        }
        else {
            this.signature = {
                domain: ce.domain('Function'),
                codomain: ce.domain('Anything'),
            };
        }
    }
    reset() {
        return;
    }
}
function makeFunctionDefinition(engine, name, def) {
    if (def instanceof BoxedFunctionDefinitionImpl)
        return def;
    return new BoxedFunctionDefinitionImpl(engine, name, def);
}

function isSymbolDefinition$1(def) {
    return (!!def &&
        typeof def === 'object' &&
        ('domain' in def || 'value' in def || 'constant' in def));
}
function isFunctionDefinition$1(def) {
    return (!!def &&
        typeof def === 'object' &&
        ('complexity' in def || 'numeric' in def || 'signature' in def));
}

function getStandardLibrary(categories) {
    if (categories === 'all') {
        // **Note** the order of the libraries matter:
        // earlier libraries cannot reference definitions in later libraries.
        return getStandardLibrary([
            'domains',
            'core',
            'control-structures',
            'logic',
            'collections',
            'relop',
            'numeric',
            'arithmetic',
            'algebra',
            'calculus',
            'combinatorics',
            'linear-algebra',
            'other',
            'physics',
            'polynomials',
            'statistics',
            'trigonometry',
            'dimensions',
            'units',
        ]);
    }
    else if (typeof categories === 'string')
        categories = [categories];
    const result = [];
    for (const category of categories) {
        const dict = LIBRARIES[category];
        if (!dict)
            throw Error(`Unknown library category ${category}`);
        if (Array.isArray(dict))
            result.push(...dict);
        else
            result.push(dict);
    }
    return result;
}
const LIBRARIES = {
    'algebra': [],
    // 'algebra': [
    //   // polynomial([0, 2, 0, 4]:list, x:symbol) -> 2x + 4x^3
    //   // polynomial(2x + 4x^3, x) -> {0, 2, 0, 4}
    //   // rational(2x + 4x^3, {3, 1}, x) -> (2x + 4x^3)/(3+x)
    //   // https://reference.wolfram.com/language/tutorial/AlgebraicCalculations.html
    //   // simplify-trig (macsyma)
    //   //  - trigReduce, trigExpand, trigFactor, trigToExp (mathematica)
    //   // Mathematica:
    //   // - distribute -> (a+b)(c+d) -> ac+ ad+ bc+ bd (doesn't have to be multiply,
    //   // f(a+b, c+d) -> f(a, c) + f(a, d) + f(b, c) + f(b, d)
    //   // -- distribute(expr, over=add, with=multiply)
    //   // https://reference.wolfram.com/language/ref/Distribute.html
    //   // - expand, expand-all
    //   // - factor
    //   // - simplify
    // ],
    'arithmetic': ARITHMETIC_LIBRARY,
    'calculus': CALCULUS_LIBRARY,
    'combinatorics': [],
    'control-structures': [],
    //   // D
    //   // Derivative (mathematica)
    //   // diff (macsyma)
    //   // nth-diff
    //   // int
    //   // - integrate(expression, symbol)  -- indefinite integral
    //   // - integrate(expression, range) <range> = {symbol, min, max} -- definite integral
    //   // - integrate(expression, range1, range2) -- multiple integral
    //   // def-int
    // ],
    'dimensions': [],
    'domains': [],
    'core': CORE_LIBRARY,
    'collections': [SETS_LIBRARY, COLLECTIONS_LIBRARY],
    // 'domains': getDomainsDictionary(),
    'linear-algebra': [],
    //   // matrix
    //   // transpose
    //   // cross-product
    //   // outer-product
    //   // determinant
    //   // vector
    //   // matrix
    //   // rank
    //   // scalar-matrix
    //   // constant-matrix
    //   // identity-matrix
    // ],
    'logic': LOGIC_LIBRARY,
    'numeric': [],
    //   // Gamma function
    //   // Zeta function
    //   // erf function
    //   // numerator(fraction)
    //   // denominator(fraction)
    //   // exactFloatToRational
    //   // N -> eval as a number
    //   // random
    //   // hash
    // ],
    'other': [],
    'relop': RELOP_LIBRARY,
    'polynomials': POLYNOMIALS_LIBRARY,
    'physics': {
        'Mu-0': {
            description: 'Vaccum permeability',
            constant: true,
            wikidata: 'Q1515261',
            domain: 'RealNumber',
            value: 1.25663706212e-6,
            // unit: ['Divide', 'N', ['Square', 'A']],
        },
    },
    'statistics': [],
    //   // average
    //   // mean
    //   // variance = size(l) * stddev(l)^2 / (size(l) - 1)
    //   // stddev
    //   // median
    //   // quantile
    // ],
    'trigonometry': TRIGONOMETRY_LIBRARY,
    'units': [],
};
function validateDefinitionName(name) {
    name = name.normalize();
    if (!isValidIdentifier(name))
        throw Error(`Invalid definition name ${name}`); // @todo cause
    return name;
}
/**
 * Set the symbol table of the current context (`engine.context`) to `table`
 *
 * `table` can be an array of symbol tables, in order to deal with circular
 * dependencies: it is possible to partition a library into multiple
 * symbol tables, to control the order in which they are processed and
 * avoid having expressions in the definition of an entry reference a symbol
 * or function name that has not yet been added to the symbol table.
 *
 */
function setCurrentContextSymbolTable(engine, table) {
    var _a;
    if (!engine.context)
        throw Error('No context available');
    // If this is the first symbol table, setup the context
    (_a = engine.context).idTable ?? (_a.idTable = new Map());
    const idTable = engine.context.idTable;
    //
    // Validate and add the symbols from the symbol table
    //
    for (let name of Object.keys(table)) {
        const entry = table[name];
        name = validateDefinitionName(name);
        if (isFunctionDefinition$1(entry)) {
            const def = makeFunctionDefinition(engine, name, entry);
            if (idTable.has(name))
                throw new Error(`Duplicate function definition ${name}:\n${JSON.stringify(idTable.get(name))}\n${JSON.stringify(entry)}`);
            idTable.set(name, def);
        }
        else if (isSymbolDefinition$1(entry)) {
            const def = new BoxedSymbolDefinitionImpl(engine, name, entry);
            if (engine.strict && entry.wikidata) {
                for (const [_, d] of idTable) {
                    if (d.wikidata === entry.wikidata)
                        throw new Error(`Duplicate entries with wikidata "${entry.wikidata}": "${name}" and "${d.name}"`);
                }
            }
            if (idTable.has(name))
                throw new Error(`Duplicate symbol definition "${name}"`);
            idTable.set(name, def);
        }
        else {
            const def = new BoxedSymbolDefinitionImpl(engine, name, {
                value: engine.box(entry),
            });
            console.assert(def);
            idTable.set(name, def);
        }
    }
}

/**
 * The Cost Function is used to select the simplest between two expressions:
 * the one with the lowest cost function.
 *
 * It is based on the Mathematica cost function.
 *
 *
 * From https://reference.wolfram.com/language/ref/ComplexityFunction.html
 *
 * ```
 * SimplifyCount[p_] :=
 *  Which[
 *
 *   Head[p] === Symbol, 1,
 *
 *   IntegerQ[p],
 *   If[
 *      p == 0, 1,
 *      Floor[N[Log[2, Abs[p]]/Log[2, 10]]] + If[p > 0, 1, 2]
 *   ],
 *
 *   Head[p] === Rational,
 *   SimplifyCount[Numerator[p]] + SimplifyCount[Denominator[p]] + 1,
 *
 *   Head[p] === Complex,
 *   SimplifyCount[Re[p]] + SimplifyCount[Im[p]] + 1,
 *
 *   NumberQ[p], 2,
 *
 *   True, SimplifyCount[Head[p]] +
 *    If[
 *      Length[p] == 0, 0,
 *      Plus @@ (SimplifyCount /@ (List @@ p))]
 *    ]
 * ```
 */
function numericCostFunction(n) {
    if (Number.isInteger(n) && n !== 0) {
        return Math.floor(Math.log2(Math.abs(n)) / Math.log2(10)) + (n > 0 ? 1 : 2);
    }
    return 2;
}
function costFunction(expr) {
    //
    // 1/ Symbols
    //
    if (expr.symbol)
        return 1;
    //
    // 2/ Literal Numeric Values
    //
    const num = expr.numericValue;
    if (num !== null) {
        if (expr.isZero)
            return 1;
        if (expr.isInteger)
            return numericCostFunction(asFloat(expr));
        if (isRational(num)) {
            if (isMachineRational(num))
                return numericCostFunction(num[0]) + numericCostFunction(num[1]) + 1;
            else
                return (numericCostFunction(Number(num[0])) +
                    numericCostFunction(Number(num[1])) +
                    1);
        }
        if (num instanceof Complex)
            return numericCostFunction(num.re) + numericCostFunction(num.im) + 1;
        if (expr.isNumber)
            return 2;
    }
    const head = expr.head;
    let headCost = 2;
    if (typeof head === 'string') {
        if (['Add', 'Divide'].includes(head))
            headCost = 3;
        else if (['Subtract', 'Negate'].includes(head))
            headCost = 4;
        else if (['Square', 'Sqrt', 'Multiply', 'Root'].includes(head))
            headCost = 5;
        else if (['Power'].includes(head))
            headCost = 6;
        else if (['Ln', 'Exp', 'Log'].includes(head))
            headCost = 7;
        else
            headCost = 8;
    }
    else
        headCost = costFunction(head);
    return (headCost + (expr.ops?.reduce((acc, x) => acc + costFunction(x), 0) ?? 0));
}
const DEFAULT_COST_FUNCTION = costFunction;

class ExpressionMap {
    constructor(source) {
        if (!source) {
            this._items = new Map();
        }
        else if (source instanceof ExpressionMap) {
            this._items = new Map(source._items);
        }
        else {
            this._items = new Map(source);
        }
    }
    has(expr) {
        for (const x of this._items.keys())
            if (x.isSame(expr))
                return true;
        return false;
    }
    get(expr) {
        for (const [x, v] of this._items)
            if (x.isSame(expr))
                return v;
        return undefined;
    }
    clear() {
        this._items.clear();
    }
    set(expr, value) {
        for (const x of this._items.keys()) {
            if (x.isSame(expr)) {
                this._items.set(x, value);
                return;
            }
        }
        this._items.set(expr, value);
    }
    delete(expr) {
        this._items.delete(expr);
    }
    [Symbol.iterator]() {
        return this._items.entries();
    }
    entries() {
        return this._items.entries();
    }
}

function permutations(xs) {
    const result = [];
    const permute = (arr, m = []) => {
        if (arr.length === 0) {
            result.push(m);
        }
        else {
            for (let i = 0; i < arr.length; i++) {
                const curr = arr.slice();
                const next = curr.splice(i, 1);
                permute(curr.slice(), m.concat(next));
            }
        }
    };
    permute(xs);
    return result;
}

class BoxedPattern extends AbstractBoxedExpression {
    constructor(ce, pattern, metadata) {
        super(ce, metadata);
        this._pattern = isLatexString(pattern)
            ? ce.parse(pattern, { canonical: false })
            : ce.box(pattern, { canonical: false });
    }
    get hash() {
        return hashCode('Pattern') ^ this._pattern.hash;
    }
    unbind() {
        this._pattern.unbind();
    }
    get json() {
        return serializeJsonFunction(this.engine, 'Pattern', [this._pattern]);
    }
    get head() {
        return 'Pattern';
    }
    get domain() {
        return this.engine.domain('Pattern');
    }
    get isCanonical() {
        return true;
    }
    set isCanonical(_val) {
        return;
    }
    isSame(rhs) {
        if (this === rhs)
            return true;
        return rhs instanceof BoxedPattern && this._pattern.isSame(rhs._pattern);
    }
    isEqual(rhs) {
        return rhs instanceof BoxedPattern && this._pattern.isEqual(rhs._pattern);
    }
    match(expr, options) {
        return match(expr, this._pattern, {
            recursive: options?.recursive ?? false,
            numericTolerance: options?.numericTolerance ?? 0,
            substitution: options?.substitution ?? {},
        });
    }
    test(expr, options) {
        return this.match(expr, options) !== null;
    }
    count(exprs, options) {
        let result = 0;
        for (const expr of exprs) {
            if (this.match(expr, options) !== null)
                result += 1;
        }
        return result;
    }
    subs(sub, options) {
        return this._pattern.subs(sub, options);
    }
}
function hasWildcards(expr) {
    if (typeof expr === 'string')
        return expr.startsWith('_');
    if (expr.symbol?.startsWith('_'))
        return true;
    if (expr.ops)
        return hasWildcards(expr.head) || expr.ops.some(hasWildcards);
    if (expr.keys)
        for (const key of expr.keys)
            if (hasWildcards(expr.getKey(key)))
                return true;
    return false;
}
function captureWildcard(wildcard, expr, substitution) {
    const name = getWildcardName(wildcard);
    // If this is a universal wildcard, it always matches and no need to add it
    // to the substitution record.
    if (name === '')
        return substitution;
    if (substitution[name] !== undefined) {
        // There was already a matching wildcard, make sure this one is identical
        if (!expr.isSame(substitution[name]))
            return null;
        return substitution;
    }
    if (hasWildcards(expr))
        return null;
    return { ...substitution, [name]: expr };
}
/**
 * If `expr` matches pattern, given `substitution` (checks for inconsistency)
 * return `substitution`, amended with additional matched. Otherwise, `null`.
 * @param expr
 * @param pattern
 * @param substitution
 * @param options
 * @returns
 */
function matchOnce(expr, pattern, substitution, options) {
    const ce = expr.engine;
    if (pattern.head === 'Pattern')
        return pattern.match(expr, { substitution, ...options });
    //
    // Match a number
    //
    if (pattern instanceof BoxedNumber) {
        if (!(expr instanceof BoxedNumber))
            return null;
        if (options.numericTolerance === 0)
            return pattern.isSame(expr) ? substitution : null;
        return pattern.isEqualWithTolerance(expr, options.numericTolerance)
            ? substitution
            : null;
    }
    //
    // Match a string
    //
    const str = pattern.string;
    if (str !== null)
        return expr.string === str ? substitution : null;
    //
    // Match a symbol or capture symbol
    //
    const symbol = pattern.symbol;
    if (symbol !== null) {
        if (symbol.startsWith('_'))
            return captureWildcard(symbol, expr, substitution);
        return symbol === expr.symbol ? substitution : null;
    }
    // If the number of operands or keys don't match, it's not a match
    if (pattern.nops !== expr.nops)
        return null;
    //
    // Match a dictionary
    //
    const keys = pattern.keys;
    if (keys !== null) {
        const exprKeys = expr.keys;
        if (exprKeys === null)
            return null; // A dictionary vs not a dictionary
        for (const key of keys) {
            const r = matchOnce(exprKeys[key], keys[key], substitution, options);
            if (r === null)
                return null;
            substitution = r;
        }
        return substitution;
    }
    //
    // Match a function
    //
    if (pattern.ops) {
        const head = pattern.head;
        // Match the function head
        if (typeof head === 'string' && head.startsWith('_'))
            return captureWildcard(head, ce.box(expr.head), substitution);
        let def = undefined;
        if (typeof head === 'string' && typeof expr.head === 'string') {
            if (head !== expr.head)
                return null;
            def = ce.lookupFunction(head);
        }
        else {
            const r = matchOnce(ce.box(expr.head, { canonical: false }), ce.box(head, { canonical: false }), substitution, options);
            if (r === null)
                return null;
            substitution = r;
        }
        return def?.commutative
            ? matchCommutativeArguments(expr, pattern, substitution, options)
            : matchNonCommutativeArguments(expr, pattern, substitution, options);
    }
    return null; // no match
}
function matchPermutation(ce, ops, patterns, substitution, options) {
    let result = { ...substitution };
    ops = [...ops];
    // Iterate over each argument in pattern
    let hasRest = false;
    for (const arg of patterns) {
        if (arg.symbol === '__')
            hasRest = true;
        else {
            let r = null;
            if (arg.symbol?.startsWith('_')) {
                for (let i = 0; i <= ops.length - 1; i++) {
                    r = captureWildcard(arg.symbol, ops[i], result);
                    if (r !== null) {
                        // Found a matching argument, remove it
                        ops.splice(i, 1);
                        break;
                    }
                }
            }
            else {
                for (let i = 0; i <= ops.length - 1; i++) {
                    r = matchOnce(ops[i], arg, result, options);
                    if (r !== null) {
                        ops.splice(i, 1);
                        break;
                    }
                }
            }
            if (r === null)
                return null;
            result = r;
        }
    }
    // If not all ops matched, and we don't have a 'rest' capture, fail
    if (!hasRest && ops.length > 0)
        return null;
    //  If the pattern included a 'rest' pattern, use any remaining arguments
    if (result !== null && hasRest)
        result['__'] = ce._fn('Sequence', ops);
    return result;
}
function matchCommutativeArguments(expr, pattern, substitution, options) {
    const patterns = permutations(pattern.ops);
    for (const pat of patterns) {
        const result = matchPermutation(expr.engine, expr.ops, pat, substitution, options);
        if (result !== null)
            return result;
    }
    return null;
}
function matchNonCommutativeArguments(expr, pattern, substitution, options) {
    const ce = expr.engine;
    const ops = [...expr.ops];
    let result = { ...substitution };
    let i = 0; // Index in pattern
    const patterns = pattern.ops; // pattern.ops!.map((x) => ce.pattern(x));
    while (i < pattern.nops) {
        const pat = patterns[i];
        const argName = pat.symbol;
        if (argName !== null) {
            if (argName.startsWith('__')) {
                // Match 0 or more expressions (__) or 1 or more (___)
                let j = 0; // Index in subject
                if (patterns[i + 1] === undefined) {
                    // No more args after, go till the end
                    j = ops.length + 1;
                }
                else {
                    // Capture till the next matching arg
                    let found = false;
                    while (!found && j < ops.length) {
                        found =
                            matchOnce(ops[j], patterns[i + 1], result, options) !== null;
                        j += 1;
                    }
                    if (!found)
                        return null;
                }
                if (!argName.startsWith('___') && j <= 1)
                    return null;
                result = captureWildcard(argName, ce.fn('Sequence', ops.splice(0, j - 1)), result);
            }
            else if (argName.startsWith('_')) {
                result = captureWildcard(argName, ops.shift(), result);
            }
            else {
                const sub = matchOnce(ops.shift(), pat, result, options);
                if (sub === null)
                    return null;
                result = sub;
            }
        }
        else {
            const sub = matchOnce(ops.shift(), pat, result, options);
            if (sub === null)
                return null;
            result = sub;
        }
        if (result === null)
            return null;
        i += 1;
    }
    return result;
}
/**
 * The function attempts to match a [pattern](http://cortexjs.io/compute-engine/guides/patterns-and-rules/)
 * with a subject expression.
 *
 * If the match is successful, it returns a `Substitution` indicating how to
 * transform the pattern to become the subject.
 *
 * If the pattern is not a match, it returns `null`.
 *
 * This function attempts the match purely structurally, without any
 * knowledge about commutative and associative properties of functions. To
 * account for those properties, use the canonical form of the pattern and
 * the subject.
 *
 */
function match(subject, pattern, options) {
    const substitution = matchOnce(subject, pattern, options.substitution ?? {}, {
        numericTolerance: options?.numericTolerance ?? NUMERIC_TOLERANCE,
    });
    if (substitution)
        return substitution;
    if (!options.recursive)
        return null;
    // Attempt to match recursively on the arguments of a function (or the keys
    // of a dictionary) @todo
    return null;
}
// function boxedSubstitution(ce: IComputeEngine, sub: null): null;
// function boxedSubstitution(
//   ce: IComputeEngine,
//   sub: Substitution
// ): BoxedSubstitution;
// function boxedSubstitution(
//   ce: IComputeEngine,
//   sub: Substitution | null
// ): BoxedSubstitution | null;
// function boxedSubstitution(
//   ce: IComputeEngine,
//   sub: Substitution | null
// ): BoxedSubstitution | null {
//   if (sub === null) return null;
//   return Object.fromEntries(
//     Object.entries(sub).map(([k, v]) => [k, ce.box(v)])
//   );
// }

function isSymbolDefinition(def) {
    if (def === null || def === undefined)
        return false;
    if ('constant' in def)
        return true;
    return false;
}
function isFunctionDefinition(def) {
    if (def === null || def === undefined)
        return false;
    if ('signature' in def)
        return true;
    return false;
}
/**
 * BoxedSymbol
 *
 * A boxed symbol is a reference to a `BoxedSymbolDefinition` or a
 * `BoxedFunctionDefinition`.
 *
 * If a `BoxedSymbolDefinition`, it "owns" all the information
 * about the symbol, its value, domain and various attributes.
 *
 * If a `BoxedFunctionDefinition`, it it a reference to a function name,
 * not a function expression, i.e. `Sin`, not `["Sin", "Pi"]`. This is used
 * for example in `["InverseFunction", "Sin"]`
 */
class BoxedSymbol extends AbstractBoxedExpression {
    constructor(ce, name, options) {
        super(ce, options?.metadata);
        // MathJSON symbols are always stored in Unicode NFC canonical order.
        // See https://unicode.org/reports/tr15/
        console.assert(name === name.normalize());
        this._name = name;
        console.assert(isValidIdentifier(this._name));
        this._scope = options?.canonical ? ce.context : null;
        this._def = options?.def ?? null; // Mark the def as not cached if not provided
    }
    get hash() {
        if (this._hash === undefined)
            this._hash = hashCode(this._name);
        return this._hash;
    }
    unbind() {
        this._def?.reset();
        this._def = null;
    }
    get isPure() {
        return ((this.symbolDefinition?.constant &&
            this.symbolDefinition.value?.isPure) ??
            this.functionDefinition?.pure ??
            false);
    }
    get json() {
        return serializeJsonSymbol(this.engine, this._name, {
            latex: this._latex,
            wikidata: this._wikidata,
        });
    }
    get scope() {
        return this._scope;
    }
    /** A free variable either has no definition, or it has a definition, but no value */
    get isFree() {
        // Don't use `.symbolDefinition` as this has a side effect of creating
        // a def, which is not desirable whn we're just doing a test.
        const def = this._def ?? this.engine.lookupSymbol(this._name, this._wikidata);
        return !isSymbolDefinition(def) || def.value === undefined;
    }
    get isConstant() {
        // Don't use `.symbolDefinition` as this has a side effect of creating
        // a def, which is not desirable whn we're just doing a test.
        const def = this._def ?? this.engine.lookupSymbol(this._name, this._wikidata);
        return !isSymbolDefinition(def) || def.constant;
    }
    get isCanonical() {
        return this._scope !== null;
    }
    set isCanonical(val) {
        this._scope = val ? this.engine.context : null;
        this._def = null;
    }
    get canonical() {
        // If a scope has been provided, this symbol is canonical
        if (this._scope)
            return this;
        // Return a new canonical symbol, scoped in the current context
        return this.engine.box(this._name);
    }
    get wikidata() {
        return this._wikidata ?? this.baseDefinition?.wikidata ?? undefined;
    }
    get description() {
        if (!this.baseDefinition)
            return undefined;
        if (!this.baseDefinition.description)
            return undefined;
        if (typeof this.baseDefinition.description === 'string')
            return [this.baseDefinition.description];
        return this.baseDefinition.description;
    }
    get url() {
        return this.baseDefinition?.url ?? undefined;
    }
    get complexity() {
        return 7;
    }
    get head() {
        return 'Symbol';
    }
    get symbol() {
        return this._name;
    }
    get isNothing() {
        return this._name === 'Nothing';
    }
    //  A base definition is the base class of both symbol and function definition
    get baseDefinition() {
        if (this._def === null)
            this.bind(this._scope);
        return this._def ?? undefined;
    }
    get symbolDefinition() {
        if (this._def === null)
            this.bind(this._scope);
        return isSymbolDefinition(this._def) ? this._def : undefined;
    }
    get functionDefinition() {
        if (this._def === null)
            this.bind(this._scope);
        return isFunctionDefinition(this._def) ? this._def : undefined;
    }
    bind(scope) {
        if (scope === null) {
            this._def = undefined;
            return;
        }
        // Look for a definition in the scope when the symbol was boxed
        let def;
        //
        // 1. Bind to a symbol definition over a function definition
        // (since symbols can be redefined)
        //
        def = this.engine.lookupSymbol(this._name, this._wikidata, scope);
        // Is the wikidata consistent?
        if (def?.wikidata && this._wikidata && def.wikidata !== this._wikidata)
            def = undefined;
        if (def) {
            // In case the symbol was found by its wikidata and the name of the
            // symbol doesn't match, update it to match the definition in our dictionary
            this._name = def.name;
            // Bind the definition and value to this symbol
            this._def = def;
            return;
        }
        //
        // 2. Bind to a function definition
        //
        def = this.engine.lookupFunction(this._name, scope);
        if (def) {
            this._def = def;
            return;
        }
        //
        // 3. Auto-binding
        //
        if (this.engine.defaultDomain !== null) {
            // No definition, create one if a default domain is specified
            this._def = this.engine.defineSymbol(this._name, {
                wikidata: this._wikidata,
                domain: this.engine.defaultDomain,
            });
            this._name = this._def.name;
        }
    }
    get value() {
        return this.symbolDefinition?.value;
    }
    set value(value) {
        // Symbols starting with `_` are wildcards and never have an associated
        // value
        if (this._name[0] === '_')
            throw new Error(`The value of the wildcard "${this._name}" cannot be changed`);
        //
        // Clear assumptions  about this symbol
        //
        this.engine.forget(this._name);
        //
        // Determine the new value
        //
        let v;
        if (value !== undefined) {
            const boxedValue = this.engine.box(value);
            v = boxedValue.value ?? boxedValue.evaluate();
        }
        //
        // Assign the value to the corresponding definition
        //
        if (v?.domain.isCompatible('Function')) {
            // New function definitions always completely replace an existing one
            this._def = this.engine.defineFunction(this._name, {
                signature: {
                    domain: v.domain,
                    evaluate: v, // Evaluate as a lambda
                },
            });
        }
        else if (this._def && isSymbolDefinition(this._def)) {
            // We are already bound to a symbol definition, update it
            // (this may throw if the definition is readonly)
            this._def.value = v;
        }
        else {
            // Create a new symbol definition
            let dom = v?.domain;
            if (dom?.isNumeric)
                dom = this.engine.domain('Number');
            this._def = this.engine.defineSymbol(this._name, {
                value: v,
                domain: dom ?? undefined,
            });
        }
    }
    get domain() {
        if (this.functionDefinition)
            return this.engine.domain('Function');
        return (this.symbolDefinition?.domain ??
            this.engine.defaultDomain ??
            this.engine.domain('Value'));
    }
    set domain(inDomain) {
        if (this._name[0] === '_')
            throw new Error(`The domain of the wildcard "${this._name}" cannot be changed`);
        const d = this.engine.domain(inDomain);
        if (d.isCompatible('Function')) {
            this.engine.forget(this._name);
            this._def = this.engine.defineFunction(this._name, {
                signature: { domain: d },
            });
        }
        // Since setting the domain can have the side effect of creating a symbol
        // don't use `symbolDefinition` which may also create the symbol entry,
        // but with a defaultDomain
        else if (isSymbolDefinition(this._def)) {
            // Setting the domain will also update the flags
            this._def.domain = d;
        }
        else {
            // Symbol was not bound to a definition, bind it in the current scope
            this.engine.forget(this._name);
            this._def = this.engine.defineSymbol(this._name, { domain: d });
        }
    }
    get explicitDomain() {
        if (this.functionDefinition)
            return this.engine.domain('Function');
        return this.symbolDefinition?.domain ?? undefined;
    }
    get sgn() {
        // If available, use the value associated with this symbol.
        // Note that `null` is an acceptable and valid value
        const v = this.value;
        if (v && v !== this) {
            const s = v.sgn;
            if (s !== undefined)
                return s;
        }
        // We didn't get a definitive answer from the value
        // of this symbol. Check flags.
        const def = this.symbolDefinition;
        if (def) {
            if (def.zero === true)
                return 0;
            if (def.positive === true)
                return 1;
            if (def.negative === true)
                return -1;
        }
        else
            return null;
        return undefined;
    }
    has(x) {
        if (typeof x === 'string')
            return this._name === x;
        return x.includes(this._name);
    }
    isSame(rhs) {
        if (this === rhs)
            return true;
        if (!(rhs instanceof BoxedSymbol))
            return false;
        return this._name === rhs._name;
    }
    match(rhs, _options) {
        if (!(rhs instanceof BoxedSymbol))
            return null;
        if (this._name === rhs._name)
            return {};
        return null;
    }
    isEqual(rhs) {
        if (!this.isCanonical)
            return this.canonical.isEqual(rhs);
        rhs = rhs.canonical;
        //  Boxed Identity
        if (this === rhs)
            return true;
        // Idempotency ('x' = 'x')
        if (rhs.symbol !== null)
            return rhs.symbol === this._name;
        // Mathematical/numeric equality
        const lhsVal = this.symbolDefinition?.value?.N();
        if (lhsVal)
            return lhsVal.isEqual(rhs.N());
        if (rhs.isZero) {
            if (this.isZero)
                return true;
            if (this.isNotZero)
                return false;
        }
        if (this.isZero && rhs.isNotZero)
            return false;
        // @todo could test other contradictory properties: prime vs composite, etc...
        // Direct assumptions
        if (this.engine.ask(['Equal', this, rhs]).length > 0)
            return true;
        if (this.engine.ask(['NotEqual', this, rhs]).length > 0)
            return false;
        //@todo: could use range
        return false;
    }
    isLess(rhs) {
        // Idempotency
        if (rhs.symbol !== null && rhs.symbol === this._name)
            return false;
        // Mathematical/numeric equality
        const lhsVal = this.symbolDefinition?.value?.N();
        if (lhsVal)
            return lhsVal.isLess(rhs.N());
        if (rhs.isZero) {
            const s = this.sgn;
            if (s === null)
                return false;
            if (s !== undefined)
                return s < 0;
        }
        //  @todo Check assumptions, use range
        //  let x = assumeSymbolValue(this._engine, this._symbol, 'Less');
        return undefined;
    }
    isLessEqual(rhs) {
        // Idempotency
        if (rhs.symbol !== null && rhs.symbol === this._name)
            return true;
        // Mathematical/numeric equality
        const lhsVal = this.symbolDefinition?.value?.N();
        if (lhsVal)
            return lhsVal.isLessEqual(rhs.N());
        if (rhs.isZero) {
            const s = this.sgn;
            if (s === null)
                return false;
            if (s !== undefined)
                return s <= 0;
        }
        //  @todo Check assumptions, use range
        return this.isLess(rhs) || this.isEqual(rhs);
    }
    isGreater(rhs) {
        // Idempotency
        if (rhs.symbol !== null && rhs.symbol === this._name)
            return false;
        // Mathematical/numeric equality
        const lhsVal = this.symbolDefinition?.value?.N();
        if (lhsVal)
            return lhsVal.isGreater(rhs.N());
        if (rhs.isZero) {
            const s = this.sgn;
            if (s === null)
                return false;
            if (s !== undefined)
                return s > 0;
        }
        //  @todo Check assumptions, use range
        //  let x = assumeSymbolValue(this._engine, this._symbol, 'Less');
        return undefined;
    }
    isGreaterEqual(rhs) {
        // Idempotency
        if (rhs.symbol !== null && rhs.symbol === this._name)
            return true;
        // Mathematical/numeric equality
        const lhsVal = this.symbolDefinition?.value?.N();
        if (lhsVal)
            return lhsVal.isGreaterEqual(rhs.N());
        if (rhs.isZero) {
            const s = this.sgn;
            if (s === null)
                return false;
            if (s !== undefined)
                return s >= 0;
        }
        //  @todo Check assumptions, use range
        return this.isGreater(rhs) || this.isEqual(rhs);
    }
    get isFunction() {
        return !!this.functionDefinition;
    }
    get isZero() {
        return this.symbolDefinition?.zero;
    }
    get isNotZero() {
        return this.symbolDefinition?.notZero;
    }
    get isOne() {
        return this.symbolDefinition?.one;
    }
    get isNegativeOne() {
        return this.symbolDefinition?.negativeOne;
    }
    get isOdd() {
        return this.symbolDefinition?.odd;
    }
    get isEven() {
        return this.symbolDefinition?.even;
    }
    get isPrime() {
        return this.symbolDefinition?.prime;
    }
    get isComposite() {
        return this.symbolDefinition?.composite;
    }
    get isInfinity() {
        return this.symbolDefinition?.infinity;
    }
    get isNaN() {
        return this.symbolDefinition?.NaN;
    }
    // x > 0
    get isPositive() {
        return this.symbolDefinition?.positive;
    }
    get isNonPositive() {
        return this.symbolDefinition?.nonPositive;
    }
    get isNegative() {
        return this.symbolDefinition?.negative;
    }
    get isNonNegative() {
        return this.symbolDefinition?.nonNegative;
    }
    get isNumber() {
        return this.symbolDefinition?.number;
    }
    get isInteger() {
        return this.symbolDefinition?.integer;
    }
    get isRational() {
        return this.symbolDefinition?.rational;
    }
    get isAlgebraic() {
        return this.symbolDefinition?.rational;
    }
    get isReal() {
        return this.symbolDefinition?.real;
    }
    get isExtendedReal() {
        return this.symbolDefinition?.extendedReal;
    }
    get isComplex() {
        return this.symbolDefinition?.complex;
    }
    get isImaginary() {
        return this.symbolDefinition?.imaginary;
    }
    simplify(options) {
        // If allowed replace this symbol with its value/definition.
        // In some cases this may allow for some additional simplifications (e.g. `GoldenRatio`).
        const def = this.symbolDefinition;
        if ((def?.holdUntil === 'never' || def?.holdUntil === 'simplify') &&
            def.value)
            return def.value.simplify(options);
        // By default, there is no simplification of symbols,
        // however if a custom set of rules is provided, apply them
        return options?.rules ? this.replace(options.rules) ?? this : this;
    }
    evaluate(options) {
        const def = this.symbolDefinition;
        if (def?.holdUntil !== 'N')
            return def?.value?.evaluate(options) ?? this;
        return this;
    }
    N(options) {
        // If we're doing a numeric evaluation, the `hold` does not apply
        return this.symbolDefinition?.value?.N(options) ?? this;
    }
    replace(rules, options) {
        return replace(this, rules, options);
    }
    subs(sub, options) {
        if (sub[this._name] === undefined)
            return options?.canonical ? this.canonical : this;
        return this.engine.box(sub[this._name], options);
    }
}
function makeCanonicalSymbol(ce, name) {
    const def = ce.lookupSymbol(name, undefined, ce.context);
    if (def?.holdUntil === 'never' && def.value)
        return def.value;
    return new BoxedSymbol(ce, name, { canonical: true, def });
}

/**
 *
 * To use the CortexJS Compute Engine, create a `ComputeEngine` instance.
 *
 * Use the instance to create expressions with `ce.parse()` and `ce.box()`.
 *
 *
 * ```ts
 * const ce = new ComputeEngine();
 * let expr = ce.parse("e^{i\\pi}");
 * console.log(expr.N().latex);
 * // ➔ "-1"
 *
 * expr = ce.box(["Expand", ["Power", ["Add", "a", "b"], 2]]);
 * console.log(expr.evaluate().latex);
 * // ➔ "a^2 +  2ab + b^2"
 *
 * ```
 */
class ComputeEngine {
    /**
     * Return identifier tables suitable for the specified categories, or `"all"`
     * for all categories (`"arithmetic"`, `"algebra"`, etc...).
     *
     * An identifier table defines how the symbols and function names in a
     * MathJSON expression should be interpreted, i.e. how to evaluate and
     * manipulate them.
     *
     */
    static getStandardLibrary(categories = 'all') {
        return getStandardLibrary(categories);
    }
    /**
     * Construct a new `ComputeEngine` instance.
     *
     * Identifier tables define functions and symbols (in `options.ids`).
     * If no table is provided the standard library is used (`ComputeEngine.getStandardLibrary()`)
     *
     * The LaTeX syntax dictionary is defined in `options.latexDictionary`.
     *
     * The order of the dictionaries matter: the definitions from the later ones
     * override the definitions from earlier ones. The first dictionary should
     * be the `'core'` dictionary which include some basic definitions such
     * as domains (`Boolean`, `Number`, etc...) that are used by later dictionaries.
     *
     * @param options.numericMode The default mode is `"auto"`. Use `"machine"`
     * to perform numeric calculations using 64-bit floats. Use `"bignum"` to
     * perform calculations using arbitrary precision floating point numbers.
     * Use `"auto"` or `"complex"` to allow calculations on complex numbers.
     *
     * @param options.numericPrecision Specific how many digits of precision for the
     * numeric calculations. Default is 100.
     *
     * @param options.tolerance If the absolute value of the difference of two numbers
     * is less than `tolerance`, they are considered equal. Used by `chop()` as well.
     *
     * @param options.defaultDomain If an unknown symbol is encountered, assume it should
     * be a variable in this domain. **Default** `ExtendedRealNumber`
     */
    constructor(options) {
        /** @internal */
        this._cache = {};
        /** @internal */
        this._commonSymbols = {
            True: null,
            False: null,
            Maybe: null,
            All: null,
            Nothing: null,
            None: null,
            Undefined: null,
            Function: null,
            Pi: null,
            ImaginaryUnit: null,
        };
        /** @internal */
        this._commonNumbers = {
            '-5': null,
            '-4': null,
            '-3': null,
            '-2': null,
            2: null,
            3: null,
            4: null,
            5: null,
            6: null,
            7: null,
            8: null,
            9: null,
            10: null,
            11: null,
            12: null,
            36: null,
        };
        /** @internal */
        this._commonDomains = {
            Anything: null,
            Nothing: null,
            Boolean: null,
            MaybeBoolean: null,
            String: null,
            Domain: null,
            Symbol: null,
            Integer: null,
            RationalNumber: null,
            AlgebraicNumber: null,
            RealNumber: null,
            ExtendedRealNumber: null,
            ImaginaryNumber: null,
            ComplexNumber: null,
            ExtendedComplexNumber: null,
            Number: null,
            PositiveInteger: null,
            TranscendentalNumber: null,
            PositiveNumber: null,
            Function: null,
            NumericFunction: null,
            RealFunction: null,
            TrigonometricFunction: null,
            LogicOperator: null,
            Predicate: null,
            RelationalOperator: null, // (Anything, Anything) -> MaybeBoolean
        };
        if (options !== undefined && typeof options !== 'object')
            throw Error('Unexpected argument');
        this.strict = true;
        this._latexDictionary = options?.latexDictionary;
        this._jsonSerializationOptions = {
            exclude: [],
            shorthands: ['function', 'symbol', 'string', 'dictionary', 'number'],
            metadata: [],
            precision: 'max',
            repeatingDecimals: true,
        };
        this._useRawJsonSerializationOptions = false;
        this._rawJsonSerializationOptions = {
            exclude: [],
            shorthands: ['function', 'symbol', 'string', 'dictionary', 'number'],
            metadata: [],
            precision: 'max',
            repeatingDecimals: false,
        };
        this._stats = {
            highwaterMark: 0,
            symbols: new Set(),
            expressions: new Set(),
        };
        // Prevent creation of definitions for unknown symbols until after
        // we've built the dictionary
        this._defaultDomain = null;
        // Set the default precision for `bignum` calculations
        this._numericMode = options?.numericMode ?? 'auto';
        this._precision = Math.max(options?.numericPrecision ?? 100, Math.floor(MACHINE_PRECISION));
        this._bignum = Decimal.clone({ precision: this._precision });
        this.tolerance = options?.tolerance ?? NUMERIC_TOLERANCE;
        this._ZERO = new BoxedNumber(this, 0);
        this._ONE = new BoxedNumber(this, 1);
        this._HALF = new BoxedNumber(this, [1, 2]);
        this._NEGATIVE_ONE = new BoxedNumber(this, -1);
        this._I = new BoxedNumber(this, complex.exports.Complex.I);
        this._NAN = new BoxedNumber(this, Number.NaN);
        this._POSITIVE_INFINITY = new BoxedNumber(this, Number.POSITIVE_INFINITY);
        this._NEGATIVE_INFINITY = new BoxedNumber(this, Number.NEGATIVE_INFINITY);
        this._COMPLEX_INFINITY = new BoxedNumber(this, complex.exports.Complex.INFINITY);
        // Reset the caches/create numeric constants
        this.reset();
        //
        // The first, topmost, scope contains additional info
        //
        this.context = {
            assumptions: new ExpressionMap(),
            timeLimit: 2.0,
            memoryLimit: 1.0,
            recursionLimit: 1024,
            iterationLimit: Number.POSITIVE_INFINITY,
        };
        const tables = options?.ids ?? ComputeEngine.getStandardLibrary();
        for (const table of tables)
            setCurrentContextSymbolTable(this, table);
        // Patch-up any missing definitions (domains that were
        // 'forward-declared')
        for (const d of Object.keys(this._commonDomains)) {
            if (this._commonDomains[d] && !this._commonDomains[d].symbolDefinition)
                this._commonDomains[d].bind(this.context);
            else
                this._commonDomains[d] = boxDomain(this, d);
        }
        // Populate the table of common symbols (they should be in the global context)
        for (const sym of Object.keys(this._commonSymbols)) {
            this._commonSymbols[sym] = new BoxedSymbol(this, sym, {
                canonical: true,
            });
            this._commonSymbols[sym].bind(this.context);
        }
        // Once a scope is set and the default dictionaries)
        // we can reference symbols for the domain names and other constants
        if (options?.defaultDomain) {
            const defaultDomain = this.domain(options.defaultDomain);
            if (defaultDomain.isValid)
                this._defaultDomain = defaultDomain;
            else
                this._defaultDomain = this.domain('ExtendedRealNumber');
        }
        else
            this._defaultDomain = this.domain('ExtendedRealNumber');
        // Push a fresh scope to protect global definitions:
        // this will be the "user" scope
        this.pushScope();
    }
    /** After the configuration of the engine has changed, clear the caches
     * so that new values can be recalculated.
     *
     * This needs to happen for example when the numeric precision changes.
     *
     * @internal
     */
    reset() {
        console.assert(this._bignum);
        // Recreate the bignum constants (they depend on the engine's precision)
        this._BIGNUM_NEGATIVE_ONE = this.bignum(-1);
        this._BIGNUM_NAN = this.bignum(NaN);
        this._BIGNUM_ZERO = this.bignum(0);
        this._BIGNUM_ONE = this.bignum(1);
        this._BIGNUM_TWO = this.bignum(2);
        this._BIGNUM_HALF = this._BIGNUM_ONE.div(this._BIGNUM_TWO);
        this._BIGNUM_PI = this._BIGNUM_NEGATIVE_ONE.acos();
        // Unbind all the known expressions/symbols
        const symbols = this._stats.symbols.values();
        const expressions = this._stats.expressions.values();
        this._stats.symbols = new Set();
        this._stats.expressions = new Set();
        for (const s of symbols)
            s.unbind();
        for (const s of expressions)
            s.unbind();
        // Unbind all the common  expressions (probably not necessary)
        for (const d of Object.values(this._commonDomains))
            d?.unbind();
        for (const d of Object.values(this._commonSymbols))
            d?.unbind();
        // Reset all the definitions
        let scope = this.context;
        while (scope) {
            if (scope.idTable)
                for (const [_k, v] of scope.idTable)
                    v.reset();
            // @todo purge assumptions
            scope = scope.parentScope ?? null;
        }
        // Purge any caches
        for (const k of Object.keys(this._cache))
            if (this._cache[k].value) {
                if (!this._cache[k].purge)
                    delete this._cache[k];
                else
                    this._cache[k].value = this._cache[k].purge(this._cache[k].value);
            }
    }
    /** @internal */
    _register(_expr) {
        // @debug
        // if (this._stats.expressions === null) return;
        // if (expr.symbol) {
        //   console.assert(!this._stats.symbols.has(expr));
        //   this._stats.symbols.add(expr);
        // } else {
        //   console.assert(!this._stats.expressions.has(expr));
        //   this._stats.expressions.add(expr);
        // }
        this._stats.highwaterMark += 1;
    }
    /** @internal */
    _unregister(_expr) {
        // @debug
        // if (this._stats.expressions === null) return;
        // if (expr.symbol) {
        //   console.assert(this._stats.symbols.has(expr));
        //   this._stats.symbols.delete(expr);
        // } else {
        //   console.assert(this._stats.expressions.has(expr));
        //   this._stats.expressions.delete(expr);
        // }
    }
    get stats() {
        const expressions = this._stats.expressions;
        this._stats.expressions = null;
        // @debug-begin
        // const uniques = new Map<string, number>();
        // for (const x of expressions!) {
        //   const latex = x.toJSON();
        //   uniques.set(latex, (uniques.get(latex) ?? 0) + 1);
        // }
        // const top10 = [...uniques.entries()]
        //   .sort(([_k1, c1], [_k2, c2]) => c2 - c1)
        //   .slice(0, 30);
        // const dupes = new Map<string, number>();
        // for (const x of this._stats.symbols)
        //   dupes.set(x.symbol!, (dupes.get(x.symbol!) ?? 0) + 1);
        // const topDupes = [...dupes.entries()]
        //   .sort(([_k1, c1], [_k2, c2]) => c2 - c1)
        //   .filter(([_k, c]) => c > 1)
        //   .slice(0, 30);
        // @debug-end
        this._stats.expressions = expressions;
        return {
            ...this._stats,
            // _dupeSymbols: topDupes,
            // _popularExpressions: top10,
        };
    }
    /** The precision, or number of significant digits, of numeric
     * calculations when the numeric mode is `"auto"` or `"bignum"`.
     *
     * To make calculations using more digits, at the cost of expanded memory
     * usage and slower computations, set the `precision` higher.
     *
     * If the numeric mode is not `"auto"` or `"bignum"`, it is set to `"auto"`.
     *
     * Trigonometric operations are accurate for precision up to 1,000.
     *
     */
    get precision() {
        if (this._numericMode === 'machine' || this._numericMode === 'complex')
            return Math.floor(MACHINE_PRECISION);
        return this._precision;
    }
    set precision(p) {
        if (p === 'machine')
            p = Math.floor(MACHINE_PRECISION);
        const currentPrecision = this._precision;
        if (p === currentPrecision)
            return;
        if (typeof p !== 'number' || p <= 0)
            throw Error('Expected "machine" or a positive number');
        // Set the display precision as requested.
        // It may be less than the effective precision, which is never less than 15
        this._latexSyntax?.updateOptions({
            precision: p,
            avoidExponentsInRange: [-6, p],
        });
        this._precision = Math.max(p, Math.floor(MACHINE_PRECISION));
        if (this.jsonSerializationOptions.precision > this._precision)
            this.jsonSerializationOptions = { precision: this._precision };
        if (this._numericMode !== 'auto' &&
            this._numericMode !== 'bignum' &&
            this._precision > Math.floor(MACHINE_PRECISION))
            this._numericMode = 'auto';
        this._bignum = this._bignum.config({ precision: this._precision });
        // Reset the caches
        // (the values in the cache depend on the current precision)
        this.reset();
    }
    get numericMode() {
        return this._numericMode;
    }
    set numericMode(f) {
        if (f === this._numericMode)
            return;
        if (typeof f !== 'string')
            throw Error('Expected a string');
        this._numericMode = f;
        if (f === 'complex' || f === 'machine')
            this._precision = Math.floor(MACHINE_PRECISION);
        // Make sure the display precision is not larger than the computation precision
        if (this._latexSyntax &&
            this.latexSyntax.options.precision > this._precision)
            this.latexSyntax.updateOptions({ precision: this._precision });
        if (this.jsonSerializationOptions.precision > this._precision)
            this.jsonSerializationOptions = { precision: this._precision };
        // Reset the caches: the values in the cache depend on the numeric mode)
        this.reset();
    }
    /** @experimental */
    get timeLimit() {
        let scope = this.context;
        while (scope) {
            if (scope.timeLimit !== undefined)
                return scope.timeLimit;
            scope = scope.parentScope ?? null;
        }
        return 2.0; // 2s
    }
    /** @experimental */
    get iterationLimit() {
        let scope = this.context;
        while (scope) {
            if (scope.iterationLimit !== undefined)
                return scope.iterationLimit;
            scope = scope.parentScope ?? null;
        }
        return 1024;
    }
    /** @experimental */
    get recursionLimit() {
        let scope = this.context;
        while (scope) {
            if (scope.recursionLimit !== undefined)
                return scope.recursionLimit;
            scope = scope.parentScope ?? null;
        }
        return 1024;
    }
    /**
     * If an unknown symbol is encountered, assume it should
     * be a variable in this domain.
     *
     * If set to `null`, unknown symbols will trigger an error.
     *
     * **Default:** `"ExtendedRealNumber"`
     */
    get defaultDomain() {
        return this._defaultDomain;
    }
    set defaultDomain(domain) {
        if (domain === null)
            this._defaultDomain = null;
        else {
            const defaultDomain = this.domain(domain);
            if (!defaultDomain.isValid)
                throw Error(`Invalid domain ${domain}`);
            this._defaultDomain = defaultDomain;
        }
    }
    /**
     * Values smaller than the tolerance are considered to be zero for the
     * purpose of comparison, i.e. if `|b - a| <= tolerance`, `b` is considered
     * equal to `a`.
     */
    get tolerance() {
        return this._tolerance;
    }
    set tolerance(val) {
        if (typeof val === 'number' && Number.isFinite(val))
            this._tolerance = Math.max(val, 0);
        else
            this._tolerance = NUMERIC_TOLERANCE;
        this._bignumTolerance = this.bignum(this._tolerance);
    }
    /** @internal */
    bignum(a) {
        if (typeof a === 'bigint')
            return new this._bignum(a.toString());
        return new this._bignum(a);
    }
    /** @internal */
    complex(a, b) {
        return new complex.exports.Complex(a, b);
    }
    chop(n) {
        if (typeof n === 'number' && Math.abs(n) <= this._tolerance)
            return 0;
        if (n instanceof Decimal && n.abs().lte(this._bignumTolerance))
            return 0;
        if (n instanceof complex.exports.Complex &&
            Math.abs(n.re) <= this._tolerance &&
            Math.abs(n.im) <= this._tolerance)
            return 0;
        return n;
    }
    get latexSyntax() {
        if (!this._latexSyntax)
            this._latexSyntax = new LatexSyntax({
                computeEngine: this,
                dictionary: this._latexDictionary,
                precision: this.precision,
                avoidExponentsInRange: [-6, this.precision],
                onError: (err) => {
                    throw new Error(err[0].message.toString());
                },
            });
        return this._latexSyntax;
    }
    static getLatexDictionary(domain = 'all') {
        return LatexSyntax.getDictionary(domain);
    }
    set costFunction(fn) {
        if (typeof fn !== 'function')
            this._cost = DEFAULT_COST_FUNCTION;
        this._cost = fn;
    }
    get costFunction() {
        return this._cost ?? DEFAULT_COST_FUNCTION;
    }
    /**
     * Return a matching symbol definition, starting with the current
     * scope and going up the scope chain. Prioritize finding a match by
     * wikidata, if provided.
     */
    lookupSymbol(symbol, wikidata, scope) {
        // @fastpath
        if (!this.strict) {
            scope ?? (scope = this.context ?? undefined);
            while (scope) {
                const def = scope.idTable?.get(symbol);
                if (isSymbolDefinition$1(def))
                    return def;
                scope = scope.parentScope;
            }
            return undefined;
        }
        if (typeof symbol !== 'string')
            throw Error('Expected a string');
        if (symbol.length === 0 || !this.context)
            return undefined;
        const rootScope = scope ?? this.context;
        // Try to find a match by wikidata
        if (wikidata) {
            scope = rootScope;
            while (scope) {
                if (scope.idTable)
                    for (const [_, d] of scope.idTable) {
                        if (isSymbolDefinition$1(d) && d.wikidata === wikidata)
                            return d;
                    }
                scope = scope.parentScope;
            }
        }
        // Match by name
        scope = rootScope;
        while (scope) {
            const def = scope.idTable?.get(symbol);
            if (isSymbolDefinition$1(def))
                return def;
            scope = scope.parentScope;
        }
        return undefined;
    }
    /**
     * Return the definition for a function matching this head.
     *
     * Start looking in the current context, than up the scope chain.
     *
     * This is a very rough lookup, since it doesn't account for the domain
     * of the argument or the codomain. However, it is useful during parsing
     * to differentiate between symbols that might represent a function application, e.g. `f` vs `x`.
     */
    lookupFunction(head, scope) {
        if (typeof head !== 'string')
            return undefined;
        if (!this.context)
            return undefined;
        scope ?? (scope = this.context);
        while (scope) {
            const def = scope.idTable?.get(head);
            if (isFunctionDefinition$1(def))
                return def;
            scope = scope.parentScope;
        }
        return undefined;
    }
    /**
     * Add (or replace) a definition for a symbol in the current scope.
     */
    defineSymbol(name, def) {
        if (!this.context)
            throw Error('Symbol cannot be defined: no scope available');
        if (name.length === 0 || !isValidIdentifier(name))
            throw Error('Invalid identifier ' + name);
        if (!this.context.idTable)
            this.context.idTable = new Map();
        const boxedDef = new BoxedSymbolDefinitionImpl(this, name, def);
        if (boxedDef.name)
            this.context.idTable.set(boxedDef.name, boxedDef);
        return boxedDef;
    }
    defineFunction(name, def) {
        if (!this.context)
            throw Error('Function cannot be defined: no scope available');
        if (name.length === 0 || !isValidIdentifier(name))
            throw Error('Invalid identifier ' + name);
        if (!this.context.idTable)
            this.context.idTable = new Map();
        const boxedDef = makeFunctionDefinition(this, name, def);
        if (boxedDef.name)
            this.context.idTable.set(name, boxedDef);
        return boxedDef;
    }
    /**
     *
     * Create a new scope and add it to the top of the scope stack
     *
     * The `options.scope` property can be used to specify custom precision,
     * etc... for this scope
     *
     */
    pushScope(ids, scope) {
        if (this.context === null)
            throw Error('No parent scope available');
        this.context = {
            timeLimit: this.context.timeLimit,
            memoryLimit: this.context.memoryLimit,
            recursionLimit: this.context.recursionLimit,
            iterationLimit: this.context.iterationLimit,
            ...(scope ?? {}),
            parentScope: this.context,
            // We always copy the current assumptions in the new scope.
            // This make is much easier to deal with 'inherited' assumptions
            // (and potentially modifying them later) without having to walk back
            // into parent contexts. In other words, calling `ce.forget()` will
            // forget everything **in the current scope**. When exiting the scope,
            // the previous assumptions are restored.
            assumptions: new ExpressionMap(this.context.assumptions),
        };
        // `setCurrentContextDictionary` will associate the definitions in the
        // dictionary with the current scope, so we need to set the scope first
        // above(`this.context =...`);
        if (ids) {
            if (Array.isArray(ids))
                for (const table of ids)
                    setCurrentContextSymbolTable(this, table);
            else
                setCurrentContextSymbolTable(this, ids);
        }
    }
    /** Remove the topmost scope from the scope stack.
     */
    popScope() {
        if (!this.context)
            throw Error('No scope available');
        const parentScope = this.context?.parentScope;
        this.context = parentScope ?? null;
        console.assert(this.context !== null);
    }
    set(identifiers) {
        // @fastpath
        if (!this.strict) {
            for (const k of Object.keys(identifiers)) {
                if (k !== 'Nothing') {
                    const def = this.lookupSymbol(k);
                    const idk = identifiers[k];
                    if (def)
                        def.value = idk ?? undefined;
                    else if (idk !== undefined && idk !== null) {
                        // Unknown identifier, define a new one
                        const val = this.box(idk);
                        if (val.domain.isNumeric)
                            this.defineSymbol(k, { value: val, domain: 'Number' });
                        else
                            this.defineSymbol(k, { value: val });
                    }
                }
            }
            return;
        }
        for (const k of Object.keys(identifiers)) {
            if (k !== 'Nothing') {
                const def = this.lookupSymbol(k);
                const idk = identifiers[k];
                if (idk === undefined || idk === null) {
                    if (def)
                        def.value = undefined;
                }
                else {
                    const val = this.box(idk);
                    if (def) {
                        if (def.domain && !val.domain.isCompatible(def.domain))
                            throw Error(`Expected value with domain ${def.domain.toString()} for "${k}"`);
                        def.value = val;
                    }
                    else {
                        if (val.domain.isNumeric)
                            this.defineSymbol(k, { value: val, domain: 'Number' });
                        else
                            this.defineSymbol(k, { value: val });
                    }
                }
            }
        }
    }
    let(identifiers) {
        for (const k of Object.keys(identifiers)) {
            if (k !== 'Nothing') {
                const def = identifiers[k];
                if (isSymbolDefinition$1(def))
                    this.defineSymbol(k, def);
                else if (isFunctionDefinition$1(def))
                    this.defineFunction(k, def);
                else
                    this.set({ [k]: identifiers[k] });
            }
        }
    }
    get assumptions() {
        if (!this.context)
            throw Error('No scope available');
        if (this.context.assumptions)
            return this.context.assumptions;
        // When creating a new context, the assumptions of this context
        // are a copy of all the previous assumptions
        // (as a result, there's no need to check parent assumptions,
        // and it solves the assumptions in a scope that could be contradictory
        // or complementary to previous assumptions).
        this.context.assumptions = new ExpressionMap();
        return this.context.assumptions;
    }
    /**
     * Return false if the execution should stop.
     *
     * This can occur if:
     * - an error has been signaled
     * - the time limit or memory limit has been exceeded
     *
     * @internal
     */
    shouldContinueExecution() {
        return this.deadline === undefined || this.deadline >= Date.now();
    }
    /** @internal */
    checkContinueExecution() {
        if (!this.shouldContinueExecution()) {
            // @todo: should capture stack
            throw new Error('timeout');
        }
    }
    // assert(
    //   condition: boolean,
    //   expr: BoxedExpression,
    //   msg: string,
    //   code?: SignalMessage
    // ) {
    //   if (!condition) this.signal(expr, msg, code);
    // }
    /** @internal */
    cache(cacheName, build, purge) {
        if (this._cache[cacheName] === undefined) {
            try {
                this._cache[cacheName] = { build, purge, value: build() };
            }
            catch (e) {
                console.error(`Fatal error building cache "${cacheName}":\n\t ${e.toString()}`);
            }
        }
        return this._cache[cacheName]?.value;
    }
    box(expr, options) {
        return box(this, expr, options);
    }
    canonical(xs) {
        if (!xs.every((x) => x instanceof AbstractBoxedExpression))
            return xs.map((x) => this.box(x));
        const bxs = xs;
        return bxs.every((x) => x.isCanonical) ? bxs : bxs.map((x) => x.canonical);
    }
    fn(head, ops, metadata) {
        return boxFunction(this, head, ops, { metadata, canonical: true });
    }
    /** @internal */
    _fn(head, ops, metadata) {
        return new BoxedFunction(this, head, ops, {
            metadata,
            canonical: true,
            def: this.lookupFunction(head, this.context),
        });
    }
    error(message, where) {
        if (where instanceof AbstractBoxedExpression) {
            where = this.rawJson(where);
        }
        else if (where && Array.isArray(where) && where[0] === 'Latex') {
            if (where[1] === undefined || !where[1])
                where = '';
            if (typeof where[1] === 'object' && 'str' in where[1] && !where[1].str)
                where = '';
        }
        if (Array.isArray(message) && message[0] === 'invalid-domain') {
            return boxDomain(this, [
                'Error',
                ['ErrorCode', "'invalid-domain'", message[1]],
            ]);
        }
        const msg = typeof message === 'string'
            ? this.string(message)
            : new BoxedFunction(this, 'ErrorCode', [
                this.string(message[0]),
                ...message.slice(1).map((x) => this.box(x, { canonical: false })),
            ]);
        if (!where)
            return new BoxedFunction(this, 'Error', [msg], { canonical: false });
        return new BoxedFunction(this, 'Error', [msg, this.box(where, { canonical: false })], { canonical: false });
    }
    hold(expr) {
        return this._fn('Hold', [this.box(expr, { canonical: false })]);
    }
    add(ops, metadata) {
        // Short path. Note that are arguments are **not** validated.
        const result = canonicalAdd(this, flattenOps(flattenSequence(ops), 'Add'));
        if (metadata?.latex !== undefined)
            result.latex = metadata.latex;
        if (metadata?.wikidata !== undefined)
            result.wikidata = metadata.wikidata;
        return result;
    }
    neg(expr, metadata) {
        // Short path. Note that are arguments are **not** validated.
        return canonicalNegate(expr, metadata);
    }
    mul(ops, metadata) {
        // Short path. Note that are arguments are **not** validated.
        const result = canonicalMultiply(this, flattenOps(flattenSequence(ops), ' Multiply'));
        if (metadata?.latex !== undefined)
            result.latex = metadata.latex;
        if (metadata?.wikidata !== undefined)
            result.wikidata = metadata.wikidata;
        return result;
    }
    div(num, denom, metadata) {
        // Short path. Note that are arguments are **not** validated.
        const result = canonicalDivide(this, num, denom);
        if (metadata?.latex !== undefined)
            result.latex = metadata.latex;
        if (metadata?.wikidata !== undefined)
            result.wikidata = metadata.wikidata;
        return result;
    }
    sqrt(base, metadata) {
        return canonicalPower(this, base, this._HALF, metadata);
    }
    pow(base, exponent, metadata) {
        // Short path. Note that are arguments are **not** validated.
        // The logic here handles the cases where the exponent is a number or Rational
        if (exponent instanceof AbstractBoxedExpression) {
            const num = exponent.numericValue;
            if (num !== null) {
                if (typeof num === 'number')
                    exponent = num;
                if (isRational(num))
                    exponent = num;
            }
        }
        let e = null;
        if (typeof exponent === 'number')
            e = exponent;
        else if (isRational(exponent)) {
            // Is the denominator 1?
            if (isMachineRational(exponent) && exponent[1] === 1)
                e = exponent[0];
            else if (isBigRational(exponent) && exponent[1] === BigInt(1))
                e = Number(exponent[0]);
        }
        // x^1
        if (e === 1)
            return base;
        // x^(-1)
        const r = base.numericValue;
        if (e === -1 && r !== null) {
            if (typeof r === 'number' && Number.isInteger(r))
                return this.number([1, r]);
            else if (r instanceof Decimal && r.isInteger())
                return this.number([BigInt(1), bigint(r)]);
            else if (isRational(r))
                return this.number([r[1], r[0]]);
        }
        if (typeof exponent === 'number' || isRational(exponent))
            exponent = this.number(exponent);
        return canonicalPower(this, base, exponent, metadata);
    }
    inv(expr, metadata) {
        // Short path. Note that are arguments are **not** validated.
        if (expr.isOne)
            return this._ONE;
        if (expr.isNegativeOne)
            return this._NEGATIVE_ONE;
        if (expr.isInfinity)
            return this._ZERO;
        const n = expr.numericValue;
        if (n !== null) {
            if (isRational(n))
                return this.number(inverse(n), { metadata });
            if (typeof n === 'number' && Number.isInteger(n))
                return this.number([1, n], { metadata });
            if (n instanceof Decimal && n.isInteger())
                return this.number([BigInt(1), bigint(n)], { metadata });
            return this._fn('Divide', [this._ONE, expr], metadata);
        }
        if (expr.head === 'Sqrt')
            return this._fn('Sqrt', [this.inv(expr.op1)], metadata);
        if (expr.head === 'Divide')
            return this._fn('Divide', [expr[1], expr[0]], metadata);
        if (expr.head === 'Rational')
            return this.number([expr[1], expr[0]], { metadata });
        // Inverse(expr) -> expr^{-1}
        let e = this._NEGATIVE_ONE;
        if (expr.head === 'Power') {
            // Inverse(x^{-1}) -> x
            if (expr.op2.isNegativeOne)
                return expr.op1;
            // Inverse(x^n) -> x^{-n}
            e = canonicalNegate(expr.op2);
            expr = expr.op1;
        }
        if (e.isNegativeOne)
            return this._fn('Divide', [this._ONE, expr], metadata);
        return this._fn('Power', [expr, e], metadata);
    }
    pair(first, second, metadata) {
        // Short path
        return new BoxedFunction(this, 'Tuple', [first, second], {
            metadata,
            canonical: true,
        });
    }
    tuple(elements, metadata) {
        // Short path
        return new BoxedFunction(this, 'Tuple', canonical(elements), {
            metadata,
            canonical: true,
        });
    }
    string(s, metadata) {
        return new BoxedString(this, s, metadata);
    }
    symbol(name, options) {
        options ?? (options = {});
        if (!('canonical' in options))
            options.canonical = true;
        // Symbol names should use the Unicode NFC canonical form
        name = name.normalize();
        // These three are not symbols (some of them are not even valid symbol
        // names) but they're a common type
        if (name === 'NaN')
            return this._NAN;
        if (name === 'Infinity')
            return this._POSITIVE_INFINITY;
        if (name === '+Infinity')
            return this._POSITIVE_INFINITY;
        if (name === '-Infinity')
            return this._NEGATIVE_INFINITY;
        // `Half` is a synonym for the rational 1/2
        if (name === 'Half')
            return this._HALF;
        if (this.strict && !isValidIdentifier(name)) {
            const where = options?.metadata?.latex;
            const nameStr = `'${name}'`;
            if (where)
                return this.error(['invalid-symbol-name', nameStr], where ? ['Latex', `'${where}'`] : nameStr);
        }
        // If there is some LaTeX metadata provided, we can't use the
        // `_commonSymbols` cache, as their LaTeX metadata may not match.
        if (options?.metadata?.latex !== undefined && !options.canonical)
            return new BoxedSymbol(this, name, options);
        const result = this._commonSymbols[name];
        if (result) {
            // Only use the cache if there is no metadata or it matches
            if (!options?.metadata?.wikidata ||
                !result.wikidata ||
                result.wikidata === options.metadata.wikidata)
                return result;
            if (options.canonical)
                return makeCanonicalSymbol(this, name);
            return new BoxedSymbol(this, name, options);
        }
        if (options.canonical)
            return makeCanonicalSymbol(this, name);
        return new BoxedSymbol(this, name, options);
    }
    domain(domain, metadata) {
        if (domain instanceof _BoxedDomain)
            return domain;
        if (domain instanceof AbstractBoxedExpression && domain.symbol)
            domain = domain.symbol;
        if (typeof domain === 'string') {
            if (this._commonDomains[domain])
                return this._commonDomains[domain];
        }
        if (!isDomain(domain)) {
            return this.error(['invalid-domain', { str: JSON.stringify(domain) }], ['Latex', { str: metadata?.latex ?? '' }]);
        }
        return boxDomain(this, domain, metadata);
    }
    /*
     * This function tries to avoid creating a boxed number if `num` corresponds
     * to a common value for which we have a shared instance (-1, 0, NaN, etc...)
     */
    number(value, options) {
        options ?? (options = {});
        if (!('canonical' in options))
            options.canonical = true;
        //
        // Is this number eligible to be a cached number expression?
        //
        if (options.metadata === undefined) {
            if (typeof value === 'bigint') {
                if (value === BigInt(1))
                    return this._ONE;
                if (value === BigInt(0))
                    return this._ZERO;
                if (value === BigInt(-1))
                    return this._NEGATIVE_ONE;
            }
            if (typeof value === 'number') {
                const n = value;
                if (n === 1)
                    return this._ONE;
                if (n === 0)
                    return this._ZERO;
                if (n === -1)
                    return this._NEGATIVE_ONE;
                if (Number.isInteger(n) && this._commonNumbers[n] !== undefined) {
                    if (this._commonNumbers[n] === null)
                        this._commonNumbers[n] = boxNumber(this, value) ?? this._NAN;
                    return this._commonNumbers[n];
                }
                if (Number.isNaN(n))
                    return this._NAN;
                if (!Number.isFinite(n))
                    return n < 0 ? this._NEGATIVE_INFINITY : this._POSITIVE_INFINITY;
            }
        }
        if (typeof value === 'bigint')
            value = this.bignum(value);
        return boxNumber(this, value, options) ?? this._NAN;
    }
    rules(rules) {
        return boxRules(this, rules);
    }
    pattern(expr) {
        return new BoxedPattern(this, expr);
    }
    parse(latex, options) {
        if (typeof latex !== 'string')
            return null;
        return this.box(this.latexSyntax.parse(latexString(latex) ?? latex), options);
    }
    serialize(x) {
        if (typeof x === 'object' && 'json' in x) {
            const ce = 'engine' in x ? x.engine : this;
            return this.latexSyntax.serialize(this.rawJson(ce.box(x, { canonical: false })));
        }
        return this.latexSyntax.serialize(x);
    }
    get latexOptions() {
        const latexSyntax = this.latexSyntax;
        return new Proxy({
            ...this.latexSyntax.options,
            ...this.latexSyntax.serializer.options,
        }, {
            set(options, prop, value) {
                if (!(prop in options))
                    return false;
                latexSyntax.updateOptions({ [prop]: value });
                return true;
            },
        });
    }
    set latexOptions(opts) {
        this.latexSyntax.updateOptions(opts);
    }
    get jsonSerializationOptions() {
        if (this._useRawJsonSerializationOptions)
            return this._rawJsonSerializationOptions;
        return this._jsonSerializationOptions;
    }
    set jsonSerializationOptions(val) {
        if (val.exclude)
            this._jsonSerializationOptions.exclude = [...val.exclude];
        if (val.shorthands) {
            if (val.shorthands === 'all' ||
                val.shorthands.includes('all')) {
                this._jsonSerializationOptions.shorthands = [
                    'function',
                    'symbol',
                    'string',
                    'dictionary',
                    'number',
                ];
            }
            else
                this._jsonSerializationOptions.shorthands = [...val.shorthands];
        }
        if (val.metadata) {
            if (val.metadata === 'all' ||
                val.metadata.includes('all')) {
                this._jsonSerializationOptions.metadata = ['latex', 'wikidata'];
            }
            else
                this._jsonSerializationOptions.metadata = [...val.metadata];
        }
        if (typeof val.precision === 'number' && val.precision > 0) {
            this._jsonSerializationOptions.precision = val.precision;
        }
        if (typeof val.repeatingDecimals === 'boolean') {
            this._jsonSerializationOptions.repeatingDecimals = val.repeatingDecimals;
        }
    }
    rawJson(expr) {
        const save = this._useRawJsonSerializationOptions;
        this._useRawJsonSerializationOptions = true;
        const result = expr.json;
        this._useRawJsonSerializationOptions = save;
        return result;
    }
    /**
     * Return a list of all the assumptions that match a pattern.
     *
     * ```js
     *  ce.assume(x, 'PositiveInteger');
     *  ce.ask(['Greater', 'x', '_val'])
     *  //  -> [{'val': 0}]
     * ```
     */
    ask(pattern) {
        const pat = this.pattern(pattern);
        const result = [];
        for (const [assumption, val] of this.assumptions) {
            const m = pat.match(assumption, {
                numericTolerance: this._tolerance,
            });
            if (m !== null && val === true)
                result.push(m);
        }
        return result;
    }
    // Based on contextual usage, infer domain of a symbol
    infer(symbol, _domain) {
        if (typeof symbol !== 'string') {
            if (!symbol.symbol)
                return 'internal-error';
            symbol = symbol.symbol;
        }
        // @todo
        return 'ok';
    }
    assume(arg1, arg2) {
        try {
            const latex = latexString(arg1);
            const predicate = latex
                ? this.parse(latex, { canonical: false })
                : this.box(arg1, { canonical: false });
            if (!arg2)
                return assume(predicate);
            if (isDomain(arg2))
                return assume(this.box(['Element', predicate, this.domain(arg2)]));
            return assume(this.box(['Equal', predicate, arg2]));
        }
        catch (e) {
            console.error(e);
            return 'internal-error';
        }
    }
    forget(symbol) {
        if (!this.context)
            throw Error('No scope available');
        //
        // Theory of Operations
        //
        // When forgeting we need to preserve existing definitions for symbols,
        // as some expressions may be pointing to them. Instead, we
        // reset the value/domain of those definitions.
        //
        if (symbol === undefined) {
            if (this.context.idTable)
                for (const k of this.context.idTable.keys())
                    this.forget(k);
            this.assumptions.clear();
            return;
        }
        if (Array.isArray(symbol)) {
            for (const x of symbol)
                this.forget(x);
            return;
        }
        if (typeof symbol === 'string') {
            // Remove symbol definition in the current scope (if any)
            if (this.context.idTable) {
                const def = this.context.idTable.get(symbol);
                if (isSymbolDefinition$1(def)) {
                    def.value = undefined;
                    if (def.domain?.isNumeric) {
                        def.domain = this.defaultDomain ?? this.domain('Number');
                    }
                    else
                        def.domain = undefined;
                } // @todo: if a function....
            }
            // Remove any assumptions that make a reference to this symbol
            // (note that when a scope is created, any assumptions from the
            // parent scope are copied over, so this effectively removes any
            // reference to this symbol, even if there are assumptions about
            // it in a parent scope. However, when the current scope exits,
            // any previous assumptions about the symbol will be restored).
            for (const [assumption, _val] of this.assumptions) {
                if (assumption.symbols.includes(symbol))
                    this.assumptions.delete(assumption);
            }
        }
    }
}

// This file is the root of the `compute-engine` package
const version = '0.12.3';
globalThis[Symbol.for('io.cortexjs.compute-engine')] = {
    ComputeEngine: ComputeEngine.prototype.constructor,
    version: '0.12.3',
};

export { ComputeEngine, isEnvironmentEntry, isFunctionEntry, isInfixEntry, isMatchfixEntry, isPostfixEntry, isPrefixEntry, isSymbolEntry, version };
