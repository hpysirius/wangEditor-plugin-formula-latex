/* 0.12.3 */import { Decimal } from 'decimal.js';
import { Complex } from 'complex.js';
import { Expression, MathJsonNumber } from '../math-json/math-json-format';
import type { LibraryCategory, LatexDictionary, LatexDictionaryEntry, LatexString, NumberFormattingOptions, ParseLatexOptions, SerializeLatexOptions } from './latex-syntax/public';
import { AssumeResult, BoxedExpression, BoxedFunctionDefinition, BoxedSymbolDefinition, IComputeEngine, IdTable, ExpressionMapInterface, NumericMode, Pattern, RuntimeScope, Scope, SemiBoxedExpression, SymbolDefinition, BoxedRuleSet, Rule, JsonSerializationOptions, ComputeEngineStats, Metadata, BoxedDomain, DomainExpression, FunctionDefinition, Rational, BoxedSubstitution, Substitution } from './public';
/**
 *
 * To use the CortexJS Compute Engine, create a `ComputeEngine` instance.
 *
 * Use the instance to create expressions with `ce.parse()` and `ce.box()`.
 *
 *
 * ```ts
 * const ce = new ComputeEngine();
 * let expr = ce.parse("e^{i\\pi}");
 * console.log(expr.N().latex);
 * // ➔ "-1"
 *
 * expr = ce.box(["Expand", ["Power", ["Add", "a", "b"], 2]]);
 * console.log(expr.evaluate().latex);
 * // ➔ "a^2 +  2ab + b^2"
 *
 * ```
 */
export declare class ComputeEngine implements IComputeEngine {
    /** @internal */
    readonly _ZERO: BoxedExpression;
    /** @internal */
    readonly _ONE: BoxedExpression;
    /** @internal */
    readonly _HALF: BoxedExpression;
    /** @internal */
    readonly _NEGATIVE_ONE: BoxedExpression;
    /** @internal */
    readonly _I: BoxedExpression;
    /** @internal */
    readonly _NAN: BoxedExpression;
    /** @internal */
    readonly _POSITIVE_INFINITY: BoxedExpression;
    /** @internal */
    readonly _NEGATIVE_INFINITY: BoxedExpression;
    /** @internal */
    readonly _COMPLEX_INFINITY: BoxedExpression;
    /** @internal */
    _BIGNUM_NAN: Decimal;
    /** @internal */
    _BIGNUM_ZERO: Decimal;
    /** @internal */
    _BIGNUM_ONE: Decimal;
    /** @internal */
    _BIGNUM_TWO: Decimal;
    /** @internal */
    _BIGNUM_HALF: Decimal;
    /** @internal */
    _BIGNUM_PI: Decimal;
    /** @internal */
    _BIGNUM_NEGATIVE_ONE: Decimal;
    /** @internal */
    private _precision;
    /** @internal */
    private _numericMode;
    /** @internal */
    private _latexSyntax?;
    /** @internal */
    private _tolerance;
    /** @internal */
    private _bignumTolerance;
    /** @internal */
    private _cache;
    /** @internal */
    private _stats;
    /** @internal */
    private _cost?;
    /** @internal */
    private _jsonSerializationOptions;
    /**
     * During certain operations  (serializing to LaTeX, constructing error
     * messages) we need to use a "raw" JSON serialization without any customization. Setting the `_useRawJsonSerializationOptions` will bypass
     * the `_jsonSerializationOptions` and use `_rawJsonSerializationOptions`
     * instead
     * @internal */
    private _useRawJsonSerializationOptions;
    private _rawJsonSerializationOptions;
    /** The domain of unknown symbols. If `null` unknown symbols do not have a
     * definition automatically associated with them.
     *
     *  @internal
     */
    private _defaultDomain;
    /** @internal */
    private _commonSymbols;
    /** @internal */
    private _commonNumbers;
    /** @internal */
    private _commonDomains;
    /** @internal */
    private _latexDictionary?;
    /**
     * The current scope.
     *
     * A **scope** stores the definition of symbols and assumptions.
     *
     * Scopes form a stack, and definitions in more recent
     * scopes can obscure definitions from older scopes.
     *
     * The `ce.context` property represents the current scope.
     *
     */
    context: RuntimeScope | null;
    strict: boolean;
    /** Absolute time beyond which evaluation should not proceed.
     * @internal
     */
    deadline?: number;
    /**
     * Return identifier tables suitable for the specified categories, or `"all"`
     * for all categories (`"arithmetic"`, `"algebra"`, etc...).
     *
     * An identifier table defines how the symbols and function names in a
     * MathJSON expression should be interpreted, i.e. how to evaluate and
     * manipulate them.
     *
     */
    static getStandardLibrary(categories?: LibraryCategory[] | LibraryCategory | 'all'): Readonly<IdTable>[];
    /**
     * Construct a new `ComputeEngine` instance.
     *
     * Identifier tables define functions and symbols (in `options.ids`).
     * If no table is provided the standard library is used (`ComputeEngine.getStandardLibrary()`)
     *
     * The LaTeX syntax dictionary is defined in `options.latexDictionary`.
     *
     * The order of the dictionaries matter: the definitions from the later ones
     * override the definitions from earlier ones. The first dictionary should
     * be the `'core'` dictionary which include some basic definitions such
     * as domains (`Boolean`, `Number`, etc...) that are used by later dictionaries.
     *
     * @param options.numericMode The default mode is `"auto"`. Use `"machine"`
     * to perform numeric calculations using 64-bit floats. Use `"bignum"` to
     * perform calculations using arbitrary precision floating point numbers.
     * Use `"auto"` or `"complex"` to allow calculations on complex numbers.
     *
     * @param options.numericPrecision Specific how many digits of precision for the
     * numeric calculations. Default is 100.
     *
     * @param options.tolerance If the absolute value of the difference of two numbers
     * is less than `tolerance`, they are considered equal. Used by `chop()` as well.
     *
     * @param options.defaultDomain If an unknown symbol is encountered, assume it should
     * be a variable in this domain. **Default** `ExtendedRealNumber`
     */
    constructor(options?: {
        numericMode?: NumericMode;
        numericPrecision?: number;
        ids?: Readonly<IdTable>[];
        latexDictionary?: readonly LatexDictionaryEntry[];
        tolerance?: number;
        defaultDomain?: string;
    });
    /** After the configuration of the engine has changed, clear the caches
     * so that new values can be recalculated.
     *
     * This needs to happen for example when the numeric precision changes.
     *
     * @internal
     */
    reset(): void;
    /** @internal */
    _register(_expr: BoxedExpression): void;
    /** @internal */
    _unregister(_expr: BoxedExpression): void;
    get stats(): ComputeEngineStats;
    /** @internal */
    _bignum: Decimal.Constructor;
    /** The precision, or number of significant digits, of numeric
     * calculations when the numeric mode is `"auto"` or `"bignum"`.
     *
     * To make calculations using more digits, at the cost of expanded memory
     * usage and slower computations, set the `precision` higher.
     *
     * If the numeric mode is not `"auto"` or `"bignum"`, it is set to `"auto"`.
     *
     * Trigonometric operations are accurate for precision up to 1,000.
     *
     */
    get precision(): number;
    set precision(p: number | 'machine');
    get numericMode(): NumericMode;
    set numericMode(f: NumericMode);
    /** @experimental */
    get timeLimit(): number;
    /** @experimental */
    get iterationLimit(): number;
    /** @experimental */
    get recursionLimit(): number;
    /**
     * If an unknown symbol is encountered, assume it should
     * be a variable in this domain.
     *
     * If set to `null`, unknown symbols will trigger an error.
     *
     * **Default:** `"ExtendedRealNumber"`
     */
    get defaultDomain(): BoxedDomain | null;
    set defaultDomain(domain: BoxedDomain | string | null);
    /**
     * Values smaller than the tolerance are considered to be zero for the
     * purpose of comparison, i.e. if `|b - a| <= tolerance`, `b` is considered
     * equal to `a`.
     */
    get tolerance(): number;
    set tolerance(val: number);
    /** @internal */
    bignum(a: Decimal.Value | bigint): Decimal;
    /** @internal */
    complex(a: number | Complex, b?: number): Complex;
    /** Replace a number that is close to 0 with the exact integer 0.
     *
     * How close to 0 the number has to be to be considered 0 is determined by {@link tolerance}.
     */
    chop(n: number): number;
    chop(n: Decimal): Decimal | 0;
    chop(n: Complex): Complex | 0;
    private get latexSyntax();
    static getLatexDictionary(domain?: LibraryCategory | 'all'): Readonly<LatexDictionary>;
    set costFunction(fn: ((expr: BoxedExpression) => number) | undefined);
    get costFunction(): (expr: BoxedExpression) => number;
    /**
     * Return a matching symbol definition, starting with the current
     * scope and going up the scope chain. Prioritize finding a match by
     * wikidata, if provided.
     */
    lookupSymbol(symbol: string, wikidata?: string, scope?: RuntimeScope): undefined | BoxedSymbolDefinition;
    /**
     * Return the definition for a function matching this head.
     *
     * Start looking in the current context, than up the scope chain.
     *
     * This is a very rough lookup, since it doesn't account for the domain
     * of the argument or the codomain. However, it is useful during parsing
     * to differentiate between symbols that might represent a function application, e.g. `f` vs `x`.
     */
    lookupFunction(head: string | BoxedExpression, scope?: RuntimeScope | null): undefined | BoxedFunctionDefinition;
    /**
     * Add (or replace) a definition for a symbol in the current scope.
     */
    defineSymbol(name: string, def: SymbolDefinition): BoxedSymbolDefinition;
    defineFunction(name: string, def: FunctionDefinition): BoxedFunctionDefinition;
    /**
     *
     * Create a new scope and add it to the top of the scope stack
     *
     * The `options.scope` property can be used to specify custom precision,
     * etc... for this scope
     *
     */
    pushScope(ids?: Readonly<IdTable> | Readonly<IdTable>[], scope?: Partial<Scope>): void;
    /** Remove the topmost scope from the scope stack.
     */
    popScope(): void;
    set(identifiers: Substitution<SemiBoxedExpression | null | undefined>): void;
    let(identifiers: IdTable): void;
    get assumptions(): ExpressionMapInterface<boolean>;
    /**
     * Return false if the execution should stop.
     *
     * This can occur if:
     * - an error has been signaled
     * - the time limit or memory limit has been exceeded
     *
     * @internal
     */
    shouldContinueExecution(): boolean;
    /** @internal */
    checkContinueExecution(): void;
    /** @internal */
    cache<T>(cacheName: string, build: () => T, purge: (T: any) => T | undefined): T;
    box(expr: Decimal | Complex | [num: number, denom: number] | SemiBoxedExpression, options?: {
        canonical?: boolean;
    }): BoxedExpression;
    canonical(xs: SemiBoxedExpression[]): BoxedExpression[];
    fn(head: string, ops: BoxedExpression[], metadata?: Metadata): BoxedExpression;
    /** @internal */
    _fn(head: string | BoxedExpression, ops: BoxedExpression[], metadata?: Metadata): BoxedExpression;
    error(message: ['invalid-domain', ...SemiBoxedExpression[]], where?: SemiBoxedExpression): BoxedDomain;
    error(message: string | [string, ...SemiBoxedExpression[]], where?: SemiBoxedExpression): BoxedExpression;
    hold(expr: SemiBoxedExpression): BoxedExpression;
    add(ops: BoxedExpression[], metadata?: Metadata): BoxedExpression;
    neg(expr: BoxedExpression, metadata?: Metadata): BoxedExpression;
    mul(ops: BoxedExpression[], metadata?: Metadata): BoxedExpression;
    div(num: BoxedExpression, denom: BoxedExpression, metadata?: Metadata): BoxedExpression;
    sqrt(base: BoxedExpression, metadata?: Metadata): BoxedExpression;
    pow(base: BoxedExpression, exponent: number | Rational | BoxedExpression, metadata?: Metadata): BoxedExpression;
    inv(expr: BoxedExpression, metadata?: Metadata): BoxedExpression;
    pair(first: BoxedExpression, second: BoxedExpression, metadata?: Metadata): BoxedExpression;
    tuple(elements: BoxedExpression[], metadata?: Metadata): BoxedExpression;
    string(s: string, metadata?: Metadata): BoxedExpression;
    symbol(name: string, options?: {
        metadata?: Metadata;
        canonical?: boolean;
    }): BoxedExpression;
    domain(domain: BoxedExpression | DomainExpression | BoxedDomain, metadata?: Metadata): BoxedDomain;
    number(value: number | bigint | string | MathJsonNumber | Decimal | Complex | Rational, options?: {
        canonical?: boolean;
        metadata?: Metadata;
    }): BoxedExpression;
    rules(rules: Rule[]): BoxedRuleSet;
    pattern(expr: LatexString | SemiBoxedExpression): Pattern;
    parse(latex: LatexString | string, options?: {
        canonical?: boolean;
    }): BoxedExpression;
    parse(s: null, options?: {
        canonical?: boolean;
    }): null;
    parse(latex: LatexString | string | null, options?: {
        canonical?: boolean;
    }): null | BoxedExpression;
    serialize(x: Expression | BoxedExpression): string;
    get latexOptions(): NumberFormattingOptions & ParseLatexOptions & SerializeLatexOptions;
    set latexOptions(opts: Partial<NumberFormattingOptions> & Partial<ParseLatexOptions> & Partial<SerializeLatexOptions>);
    get jsonSerializationOptions(): Readonly<JsonSerializationOptions>;
    set jsonSerializationOptions(val: Partial<JsonSerializationOptions>);
    rawJson(expr: BoxedExpression): Expression;
    /**
     * Return a list of all the assumptions that match a pattern.
     *
     * ```js
     *  ce.assume(x, 'PositiveInteger');
     *  ce.ask(['Greater', 'x', '_val'])
     *  //  -> [{'val': 0}]
     * ```
     */
    ask(pattern: LatexString | SemiBoxedExpression): BoxedSubstitution[];
    infer(symbol: BoxedExpression | string, _domain: BoxedDomain | DomainExpression): AssumeResult;
    assume(symbol: LatexString | SemiBoxedExpression, domainValue: BoxedDomain | Expression | BoxedExpression): AssumeResult;
    assume(predicate: LatexString | SemiBoxedExpression): AssumeResult;
    forget(symbol: undefined | string | string[]): void;
}
