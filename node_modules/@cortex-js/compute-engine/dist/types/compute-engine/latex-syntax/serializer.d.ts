/* 0.12.3 */import type { Expression } from '../../math-json/math-json-format';
import { WarningSignalHandler } from '../../common/signals';
import { NumberFormattingOptions, LatexString, SerializeLatexOptions, FunctionEntry } from './public';
import { IndexedLatexDictionary, SymbolEntry } from './dictionary/definitions';
export declare class Serializer {
    readonly onError: WarningSignalHandler;
    options: NumberFormattingOptions & SerializeLatexOptions;
    readonly dictionary: IndexedLatexDictionary;
    level: number;
    constructor(options: NumberFormattingOptions & SerializeLatexOptions, dictionary: IndexedLatexDictionary, onError: WarningSignalHandler);
    updateOptions(opt: Partial<NumberFormattingOptions> & Partial<SerializeLatexOptions>): void;
    /**
     * Serialize the expression, and if the expression is an operator
     * of precedence less than or equal to prec, wrap it in some paren.
     * @todo: don't wrap Abs, Floor, Ceil, Delimiter
     */
    wrap(expr: Expression | null, prec?: number): string;
    /** If this is a "short" expression (atomic), wrap it.
     *
     */
    wrapShort(expr: Expression | null): string;
    wrapString(s: string, style: 'paren' | 'leftright' | 'big' | 'none', fence?: string): string;
    wrapArguments(expr: Expression): string;
    serializeSymbol(expr: Expression, def?: SymbolEntry | FunctionEntry): string;
    serializeFunction(expr: Expression, def?: FunctionEntry | SymbolEntry): string;
    serializeDictionary(dict: {
        [key: string]: Expression;
    }): string;
    serialize(expr: Expression | null): LatexString;
    applyFunctionStyle(expr: Expression, level: number): 'paren' | 'leftright' | 'big' | 'none';
    groupStyle(expr: Expression, level: number): 'paren' | 'leftright' | 'big' | 'none';
    rootStyle(expr: Expression, level: number): 'radical' | 'quotient' | 'solidus';
    fractionStyle(expr: Expression, level: number): 'quotient' | 'inline-solidus' | 'nice-solidus' | 'reciprocal' | 'factor';
    logicStyle(expr: Expression, level: number): 'word' | 'boolean' | 'uppercase-word' | 'punctuation';
    powerStyle(expr: Expression, level: number): 'root' | 'solidus' | 'quotient';
    numericSetStyle(expr: Expression, level: number): 'compact' | 'regular' | 'interval' | 'set-builder';
}
export declare function appendLatex(src: string, s: string): string;
/**
 * Replace '#1', '#2' in the LaTeX template stings with the corresponding
 * values from `replacement`, in a LaTeX syntax safe manner (i.e. inserting spaces when needed)
 */
export declare function replaceLatex(template: string, replacement: string[]): string;
