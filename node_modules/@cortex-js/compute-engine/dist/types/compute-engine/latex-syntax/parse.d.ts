/* 0.12.3 */import { ParseLatexOptions, LatexToken, NumberFormattingOptions, Delimiter, Terminator, Parser, FunctionEntry } from './public';
import { IndexedLatexDictionary, InfixEntry, PostfixEntry, PrefixEntry, SymbolEntry } from './dictionary/definitions';
import { IComputeEngine } from '../public';
import { Expression } from '../../math-json/math-json-format';
export declare const DEFAULT_LATEX_NUMBER_OPTIONS: NumberFormattingOptions;
export declare const DEFAULT_PARSE_LATEX_OPTIONS: ParseLatexOptions;
export declare class _Parser implements Parser {
    readonly computeEngine: IComputeEngine;
    readonly options: NumberFormattingOptions & ParseLatexOptions;
    index: number;
    private readonly _tokens;
    private _positiveInfinityTokens;
    private _negativeInfinityTokens;
    private _notANumberTokens;
    private _decimalMarkerTokens;
    private _groupSeparatorTokens;
    private _exponentProductTokens;
    private _beginExponentMarkerTokens;
    private _endExponentMarkerTokens;
    private _truncationMarkerTokens;
    private _beginRepeatingDigitsTokens;
    private _endRepeatingDigitsTokens;
    private _imaginaryNumberTokens;
    private readonly _dictionary;
    private _boundaries;
    private _lastPeek;
    private _peekCounter;
    constructor(tokens: LatexToken[], options: NumberFormattingOptions & ParseLatexOptions, dictionary: IndexedLatexDictionary, computeEngine: IComputeEngine);
    updateOptions(opt: Partial<NumberFormattingOptions> & Partial<ParseLatexOptions>): void;
    get atEnd(): boolean;
    get peek(): LatexToken;
    next(): LatexToken;
    /**
     * Return true if
     * - at end of the token stream
     * - the upcoming tokens match `t.tokens`
     * - the `t.condition` function returns true
     * Note: the `minPrec` condition is not checked. It should be checked separately.
     */
    atTerminator(t?: Terminator): boolean;
    /** True if the current token matches any of the boundaries we are waiting for */
    get atBoundary(): boolean;
    addBoundary(boundary: LatexToken[]): void;
    removeBoundary(): void;
    matchBoundary(): boolean;
    boundaryError(msg: string | [string, ...Expression[]]): Expression;
    latex(start: number, end?: number): string;
    latexAhead(n: number): string;
    latexBefore(): string;
    latexAfter(): string;
    /**
     * Return at most `this._dictionary.lookahead` strings made from the tokens
     * ahead.
     *
     * The index in the returned array correspond to the number of tokens.
     * Note that since a token can be longer than one char ('\\pi', but also
     * some astral plane unicode characters), the length of the string
     * does not match that index. However, knowing the index is important
     * to know by how many tokens to advance.
     *
     */
    lookAhead(): string[];
    /** Return all the definitions that potentially match the tokens ahead */
    peekDefinitions(kind: 'function'): [FunctionEntry, number][] | null;
    peekDefinitions(kind: 'symbol'): [SymbolEntry, number][] | null;
    peekDefinitions(kind: 'postfix'): [PostfixEntry, number][] | null;
    peekDefinitions(kind: 'infix'): [InfixEntry, number][] | null;
    peekDefinitions(kind: 'prefix'): [PrefixEntry, number][] | null;
    peekDefinitions(kind: 'operator'): [InfixEntry | PrefixEntry | PostfixEntry, number][] | null;
    /** Skip strictly `<space>` tokens.
     * To also skip `{}` see `skipSpace()`.
     * To skip visual space (e.g. `\,`) see `skipVisualSpace()`.
     */
    skipSpaceTokens(): void;
    /** While parsing in math mode, skip applicable spaces, which includes `{}`.
     * Do not use to skip spaces while parsing a string. See  `skipSpaceTokens()`
     * instead.
     */
    skipSpace(): boolean;
    skipVisualSpace(): void;
    matchChar(): string | null;
    matchColor(_background?: boolean): string | null;
    matchLatexDimension(): string | null;
    match(token: LatexToken): boolean;
    matchAll(tokens: LatexToken | LatexToken[]): boolean;
    matchAny(tokens: LatexToken[]): LatexToken;
    matchSequence(tokens: LatexToken[]): LatexToken[];
    matchOptionalSign(): string;
    matchDecimalDigits(options?: {
        withGrouping?: boolean;
    }): string;
    matchSignedInteger(options?: {
        withGrouping?: boolean;
    }): string;
    matchExponent(): string;
    matchRepeatingDecimal(): string;
    matchNumber(): string;
    /**
     * A Latex number can be a decimal, hex or octal number.
     * It is used in some Latex commands, such as `\char`
     *
     * From TeX:8695 (scan_int):
     * > An integer number can be preceded by any number of spaces and `+' or
     * > `-' signs. Then comes either a decimal constant (i.e., radix 10), an
     * > octal constant (i.e., radix 8, preceded by '), a hexadecimal constant
     * > (radix 16, preceded by "), an alphabetic constant (preceded by `), or
     * > an internal variable.
     */
    matchLatexNumber(isInteger?: boolean): null | number;
    matchPrefixOperator(until?: Terminator): Expression | null;
    matchInfixOperator(lhs: Expression, until?: Terminator): Expression | null;
    /**
     * - 'enclosure' : will look for an argument inside an enclosure (open/close fence)
     * - 'implicit': either an expression inside a pair of `()`, or just a product
     *  (i.e. we interpret `\cos 2x + 1` as `\cos(2x) + 1`)
     */
    matchArguments(kind: undefined | '' | 'enclosure' | 'implicit'): Expression[] | null;
    /**
     * A function can be followed by the following suffixes:
     * - a `\prime`, `\doubleprime`, `'`, `(n)` to indicate a derivative
     * - a subscript to indicate an argument
     * - an argument, optionally inside an enclosure
     */
    matchFunctionSuffix(): Expression | null;
    /** If matches the normalized open delimiter, return the
     * expected closing delimiter.
     *
     * For example, if `delimiter` is `(`, it would match `\left\lparen` and
     * return `['\right', '\rparen']`, which can be matched with `matchAll()`
     *
     * If you need to match several tokens, use `matchAll()`
     */
    matchOpenDelimiter(openDelim: Delimiter, closeDelim: Delimiter): LatexToken[] | null;
    matchMiddleDelimiter(delimiter: '|' | ':' | LatexToken): boolean;
    /** For error handling, when there is potentially a mismatched delimiter.
     * Return a LaTeX fragment of the expected closing delimiter
     */
    matchEnclosureOpen(): string | null;
    matchEnclosureClose(): string | null;
    /**
     * An enclosure is an opening matchfix operator, an optional expression,
     * optionally followed multiple times by a separator and another expression,
     * and finally a closing matching operator.
     */
    matchEnclosure(): Expression | null;
    /**
     * Match an identifier. It can be:
     * - a symbol
     * - a simple multi-letter identifier: `\mathrm{speed}`
     * - a complex multi-letter identifier: `\mathrm{\alpha_{12}}` or `\mathit{speed\unicode{"2012}of\unicode{"2012}sound}`
     * - a command: `\alpha`  @todo
     */
    matchIdentifier(): string | Expression | null;
    /**
     * A function is a function identifier followed by arguments
     * - a function with explicit arguments `f(x)`
     * - a function with explicit arguments `\mathrm{floor}(x)`
     * - a function name: `\mathrm{floor}`
     * - a function with implicit arguments: `\cos x` (via a  custom parser)
     *
     */
    matchFunction(): Expression | null;
    /**
     * A symbol can be:
     * - a single-letter variable: `x`
     * - a single LaTeX command: `\pi`
     */
    matchSymbol(): Expression | null;
    matchOptionalLatexArgument(): Expression | null;
    matchRequiredLatexArgument(excluding?: string[]): Expression | null;
    matchSupsub(lhs: Expression | null): Expression | null;
    matchPostfix(lhs: Expression | null): Expression | null;
    /** Match a string used as a LaTeX identifier, for example an environment
     * name.
     * Not suitable for general purpose text, e.g. argument of a `\text{}
     * command. See `matchChar()` instead.
     */
    matchString(): string;
    /** Match a string as an argument (in a `{}` pair) */
    matchStringArgument(): string | null;
    /**
     * Match an expression in a tabular format, where rows are separated by `\\`
     * and columns by `&`.
     *
     * Return rows of sparse columns: empty rows are indicated with `Nothing`,
     * and empty cells are also indicated with `Nothing`.
     */
    matchTabular(): null | Expression[][];
    matchEnvironment(): Expression | null;
    /**
     * Apply an invisible operator between two expressions.
     *
     * If the `lhs` is an literal integer and the `rhs` is a literal rational
     * -> 'invisible plus'
     *
     * That is '2 3/4' -> ['Add', 2, ['Rational', 3, 4]]
     *
     * If `lhs` is a number and `rhs` is a number but not a literal -> 'invisible multiply'.
     * - 2x
     * - 2(x+1)
     * - x(x+1)
     * - f(x)g(y)
     * - 2 sin(x)
     * - 2 f(x)
     * - x f(x)
     * - (x-1)(x+1)
     * - (x+1)2 -> no
     * - x2 -> no
     * => lhs is a number, rhs is a number, but not a literal
     */
    applyInvisibleOperator(terminator: Terminator, lhs: Expression | null): Expression | null;
    matchUnexpectedLatexCommand(): Expression | null;
    /**
     * <primary> :=
     * (<number> | <symbol> | <environment> | <matchfix-expr>) <subsup>* <postfix-operator>*
     *
     * <symbol> ::= (<symbol-id> | (<latex-command><latex-arguments>)) <arguments>
     *
     * <matchfix-expr> :=
     *  <matchfix-op-open> <expression> [<matchfix-op-separator> <expression>] <matchfix-op-close>
     *
     */
    matchPrimary(): Expression | null;
    /**
     *  Parse an expression:
     *
     * <expression> ::=
     *  | <primary>
     *  | <prefix-op> <primary>
     *  | <primary> <infix-op> <expression>
     *
     * Stop when an operator of precedence less than `until.minPrec` is encountered
     */
    matchExpression(until?: Partial<Terminator>): Expression | null;
    /**
     * Add LaTeX or other requested metadata to the expression
     */
    decorate(expr: Expression | null, start: number): Expression | null;
    error(code: string | [string, ...Expression[]], fromToken: number): Expression;
}
