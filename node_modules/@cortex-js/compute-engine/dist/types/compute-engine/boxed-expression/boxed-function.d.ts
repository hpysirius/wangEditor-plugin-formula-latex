/* 0.12.3 */import { AbstractBoxedExpression } from './abstract-boxed-expression';
import { Expression } from '../../math-json/math-json-format';
import { BoxedExpression, BoxedFunctionDefinition, IComputeEngine, EvaluateOptions, NOptions, BoxedRuleSet, SemiBoxedExpression, SimplifyOptions, Substitution, ReplaceOptions, Metadata, PatternMatchOptions, BoxedDomain, RuntimeScope, BoxedSubstitution } from '../public';
/**
 * BoxedFunction
 */
export declare class BoxedFunction extends AbstractBoxedExpression {
    private _scope;
    private readonly _head;
    private readonly _ops;
    private _canonical;
    private _def;
    private _isPure;
    /** The domain of the value of the function applied to its arguments */
    private _codomain;
    /** The cached values of applying the tail to the head.
     * If the function is not pure, it is never cached.
     */
    private _value;
    private _numericValue;
    private _hash;
    constructor(ce: IComputeEngine, head: string | BoxedExpression, ops: BoxedExpression[], options?: {
        metadata?: Metadata;
        canonical?: boolean;
        def?: BoxedFunctionDefinition;
    });
    get hash(): number;
    get isCanonical(): boolean;
    set isCanonical(val: boolean);
    get isPure(): boolean;
    get json(): Expression;
    get scope(): RuntimeScope | null;
    get head(): string | BoxedExpression;
    get ops(): BoxedExpression[];
    get nops(): number;
    get op1(): BoxedExpression;
    get op2(): BoxedExpression;
    get op3(): BoxedExpression;
    get isValid(): boolean;
    get canonical(): BoxedExpression;
    map<T = BoxedExpression>(fn: (x: BoxedExpression) => T): IterableIterator<T>;
    subs(sub: Substitution, options?: {
        canonical?: boolean;
    }): BoxedExpression;
    replace(rules: BoxedRuleSet, options?: ReplaceOptions): BoxedExpression | null;
    has(x: string | string[]): boolean;
    /** `isSame` is structural/symbolic equality */
    isSame(rhs: BoxedExpression): boolean;
    match(rhs: BoxedExpression, options?: PatternMatchOptions): BoxedSubstitution | null;
    unbind(): void;
    get wikidata(): string | undefined;
    get description(): string[] | undefined;
    get url(): string | undefined;
    get complexity(): number | undefined;
    get functionDefinition(): BoxedFunctionDefinition | undefined;
    bind(_scope: RuntimeScope | null): void;
    get value(): BoxedExpression | undefined;
    /** `isEqual` is mathematical equality */
    isEqual(rhs: BoxedExpression): boolean;
    isLess(rhs: BoxedExpression): boolean | undefined;
    isLessEqual(rhs: BoxedExpression): boolean | undefined;
    isGreater(rhs: BoxedExpression): boolean | undefined;
    isGreaterEqual(rhs: BoxedExpression): boolean | undefined;
    get isZero(): boolean | undefined;
    get isNotZero(): boolean | undefined;
    get isOne(): boolean | undefined;
    get isNegativeOne(): boolean | undefined;
    get isPositive(): boolean | undefined;
    get isNonPositive(): boolean | undefined;
    get isNegative(): boolean | undefined;
    get isNonNegative(): boolean | undefined;
    get isNumber(): boolean | undefined;
    get isInteger(): boolean | undefined;
    get isRational(): boolean | undefined;
    get isAlgebraic(): boolean | undefined;
    get isReal(): boolean | undefined;
    get isExtendedReal(): boolean | undefined;
    get isComplex(): boolean | undefined;
    get isImaginary(): boolean | undefined;
    get sgn(): -1 | 0 | 1 | undefined | null;
    get domain(): BoxedDomain;
    simplify(options?: SimplifyOptions): BoxedExpression;
    evaluate(options?: EvaluateOptions): BoxedExpression;
    N(options?: NOptions): BoxedExpression;
    solve(vars: string[]): null | BoxedExpression[];
}
export declare function makeCanonicalFunction(ce: IComputeEngine, head: string | BoxedExpression, ops: SemiBoxedExpression[], metadata?: Metadata): BoxedExpression;
/** Apply arguments to an expression. If the expression is a lambda expression
 * it's wildcard arguments are substituted before being evaluated. Otherwise
 * the expression is just evaluated.
 */
export declare function apply(fn: BoxedExpression, args: BoxedExpression[]): BoxedExpression;
/** Apply the function `f` to elements of `xs`, except to the elements
 * described by `skip`:
 * - `all`: don't apply f to any elements
 * - `none`: apply `f` to all elements
 * - `first`: apply `f` to all elements except the first
 * - `rest`: apply `f` to the first element, skip the  others
 * - 'last': apply `f` to all elements except the last
 * - 'most': apply `f` to the last elements, skip the others
 *
 * Account for `Hold`, `ReleaseHold`, `Sequence`, `Symbol` and `Nothing`.
 *
 * If `f` returns `null`, the element is not added to the result
 */
export declare function holdMap(xs: BoxedExpression[], skip: 'all' | 'none' | 'first' | 'rest' | 'last' | 'most', associativeHead: string, f: (x: BoxedExpression) => BoxedExpression | null): BoxedExpression[];
