/* 0.12.3 */import { Expression } from '../../math-json/math-json-format';
import { AbstractBoxedExpression } from './abstract-boxed-expression';
import { BoxedExpression, BoxedRuleSet, BoxedSymbolDefinition, IComputeEngine, EvaluateOptions, NOptions, ReplaceOptions, SimplifyOptions, Substitution, Metadata, PatternMatchOptions, BoxedDomain, RuntimeScope, BoxedFunctionDefinition, BoxedBaseDefinition, DomainExpression, BoxedSubstitution } from '../public';
/**
 * BoxedSymbol
 *
 * A boxed symbol is a reference to a `BoxedSymbolDefinition` or a
 * `BoxedFunctionDefinition`.
 *
 * If a `BoxedSymbolDefinition`, it "owns" all the information
 * about the symbol, its value, domain and various attributes.
 *
 * If a `BoxedFunctionDefinition`, it it a reference to a function name,
 * not a function expression, i.e. `Sin`, not `["Sin", "Pi"]`. This is used
 * for example in `["InverseFunction", "Sin"]`
 */
export declare class BoxedSymbol extends AbstractBoxedExpression {
    private _scope;
    protected _name: string;
    private _hash;
    private _def;
    constructor(ce: IComputeEngine, name: string, options?: {
        metadata?: Metadata;
        canonical?: boolean;
        def?: BoxedSymbolDefinition | BoxedFunctionDefinition;
    });
    get hash(): number;
    unbind(): void;
    get isPure(): boolean;
    get json(): Expression;
    get scope(): RuntimeScope | null;
    /** A free variable either has no definition, or it has a definition, but no value */
    get isFree(): boolean;
    get isConstant(): boolean;
    get isCanonical(): boolean;
    set isCanonical(val: boolean);
    get canonical(): BoxedExpression;
    get wikidata(): string | undefined;
    get description(): string[] | undefined;
    get url(): string | undefined;
    get complexity(): number;
    get head(): string;
    get symbol(): string;
    get isNothing(): boolean;
    get baseDefinition(): BoxedBaseDefinition | undefined;
    get symbolDefinition(): BoxedSymbolDefinition | undefined;
    get functionDefinition(): BoxedFunctionDefinition | undefined;
    bind(scope: RuntimeScope | null): void;
    get value(): BoxedExpression | undefined;
    set value(value: BoxedExpression | number | undefined);
    get domain(): BoxedDomain;
    set domain(inDomain: BoxedExpression | DomainExpression | BoxedDomain);
    get explicitDomain(): BoxedDomain | undefined;
    get sgn(): -1 | 0 | 1 | undefined | null;
    has(x: string | string[]): boolean;
    isSame(rhs: BoxedExpression): boolean;
    match(rhs: BoxedExpression, _options?: PatternMatchOptions): BoxedSubstitution | null;
    isEqual(rhs: BoxedExpression): boolean;
    isLess(rhs: BoxedExpression): boolean | undefined;
    isLessEqual(rhs: BoxedExpression): boolean | undefined;
    isGreater(rhs: BoxedExpression): boolean | undefined;
    isGreaterEqual(rhs: BoxedExpression): boolean | undefined;
    get isFunction(): boolean | undefined;
    get isZero(): boolean | undefined;
    get isNotZero(): boolean | undefined;
    get isOne(): boolean | undefined;
    get isNegativeOne(): boolean | undefined;
    get isOdd(): boolean | undefined;
    get isEven(): boolean | undefined;
    get isPrime(): boolean | undefined;
    get isComposite(): boolean | undefined;
    get isInfinity(): boolean | undefined;
    get isNaN(): boolean | undefined;
    get isPositive(): boolean | undefined;
    get isNonPositive(): boolean | undefined;
    get isNegative(): boolean | undefined;
    get isNonNegative(): boolean | undefined;
    get isNumber(): boolean | undefined;
    get isInteger(): boolean | undefined;
    get isRational(): boolean | undefined;
    get isAlgebraic(): boolean | undefined;
    get isReal(): boolean | undefined;
    get isExtendedReal(): boolean | undefined;
    get isComplex(): boolean | undefined;
    get isImaginary(): boolean | undefined;
    simplify(options?: SimplifyOptions): BoxedExpression;
    evaluate(options?: EvaluateOptions): BoxedExpression;
    N(options?: NOptions): BoxedExpression;
    replace(rules: BoxedRuleSet, options?: ReplaceOptions): BoxedExpression | null;
    subs(sub: Substitution, options?: {
        canonical: boolean;
    }): BoxedExpression;
}
export declare function makeCanonicalSymbol(ce: IComputeEngine, name: string): BoxedExpression;
